<attributes>
  <attribute>
    <description>Time between invocations of auxiliary function on GPE1. The time (in is as 2^ATTR_AUX_FUNC_INVOCATION_TIME_MS with 0 indicating the is OFF. Consumer: p10_hcode_image_build.c -&gt; XGPE Header field Provided by the Machine Readable Workbook to tune the collection. Platform default:1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_AUX_FUNC_INVOCATION_TIME_MS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>AUX_FUNC_INVOCATION_TIME_MS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x01</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates the response of the DPLL frequency upon DDS events if is not ON. NONE -&gt; DPLL Mode 2, JUMP_PROTECT -&gt; DPLL Mode 3, SLEW_MODE -&gt; DPLL Mode 4 Producer: MRWB</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_DPLL_SLEW_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_DPLL_SLEW_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>if set to 1, p10_dump_stop_info output will be written to error logs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DUMP_STOP_INFO_ENABLE_ERRORLOG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>if set to 1, FAPI_ERR records are suppressed from being produced by</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables pstate parameter block code to use the static #W data Consumer: p10_pstate_parameter_build.C Platform default:OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_POUND_W_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>POUND_W_STATIC_DATA_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables pstate parameter block code to use the static #V data Consumer: p10_pstate_parameter_block.C Platform default:OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_POUND_V_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>POUND_V_STATIC_DATA_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables pstate parameter block code to use the static system vrt data Consumer: p10_pstate_parameter_build.C -&gt; PGPE Hcode Platform default:OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS_VRT_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYS_VRT_STATIC_DATA_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Debug modes supported for QME Scan layout in HOMER.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_RING_DBG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_RING_DBG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Switch to enable or disable Power Management Complex FFDC collection during the PM Complex Halt flow to HOMER to assist with failure analysis and recovery. Producer: HB must set or reset this based on the platform use-case and p10_pm_halt.C, p10_pm_callout.C</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_HALT_FFDC_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_HALT_FFDC_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Disables RVRM enablement in the system Producer: Override Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_RVRM_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_RVRM_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Disables Work Load Optimized Frequency (WOF) algorithms to modify frequency active core count and other inputs. OFF:Will enable WOF given all validity check pass. If validity checks fail, be disabled for the present IPL. ON: Will disable WOF OFF_SKIP_DD: as but skips any validity checking of the design level (lab use Producer: Override Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_WOF_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_WOF_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Disables Workload Optimized Voltage (WOV) undervolting algorithms which voltage below the value calculated from VPD. OFF: Will enable WOV overvolting given all validity check pass. If validity WOV overvolting will be disabled for the present IPL. ON:Will disable overvolting Producer: Override Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_WOV_OVERV_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_WOV_OVERV_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Disables Workload Optimized Voltage (WOV) undervolting algorithms which voltage below the value calculated from VPD. OFF:Will enable WOV undervolting given all validity check pass. If validity WOV undervolting will be disabled for the present IPL. ON: Will disable undervolting Producer: Override Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_WOV_UNDERV_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_WOV_UNDERV_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>If WOF Throttle Control Loop is enabled, then selects the mode to update throttle control values. BINARY: Will update the throttle control values by half the current value of throttle. DECINC: Will update throttle control value by one in each step. Producer: Override Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_THROTTLE_CONTROL_LOOP_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_THROTTLE_CONTROL_LOOP_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>BINARY</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables the PGPE to clip Pstates based on the sibling Dual Chip Module (DCM) Pstate value to have the combination generally track. The DCM values are NOT interlocked as this is to aid in thermal management. Producer: p10_build_pstate_datablock Consumers: PGPE HCode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_DCM_TRACKING_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_DCM_TRACKING_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the mode of #V checking in relationship to system reaction FAIL - if not ATTR_SYSTEM_PSTATE_DISABLE, fails the IPL (product default). else act as OFF INFO - if not ATTR_SYSTEM_PSTATE_DISABLE, Info error log; Pstates are disabled; IPL continues. else act as OFF WARN - if not ATTR_SYSTEM_PSTATE_DISABLE, error messages to traces; no error logs, Pstates are disabled (as #V is bad), IPL continues. else act as OFF OFF - no checking performed; IPL continues. Pstates are follow ATTR_SYSTEM_PSTATE_DISABLE (user beware if not Disabled). Producer: Override Consumers: p10_pstate_parameter_build</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_PDV_VALIDATION_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_PDV_VALIDATION_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>FAIL</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the mode of #W checking in relationship to system reaction FAIL - if not ATTR_SYSTEM_WOF_DISABLE or not ATTR_SYSTEM_DDS_DISABLE, fails the IPL (product default); else act as OFF. INFO - if not ATTR_SYSTEM_WOF_DISABLE or not ATTR_SYSTEM_DDS_DISABLE, error messages to traces; Info error log; WOF AND DDS are disabled; IPL continues. else if act as OFF WARN - if not ATTR_SYSTEM_WOF_DISABLE or not ATTR_SYSTEM_DDS_DISABLE, error messages to traces; no error logs, WOF and DDS are disabled, IPL continues. else if act as OFF OFF - no checking performed; IPL continues. WOF and DDS follow ATTR_SYSTEM_WOF_DISABLE and ATTR_SYSTEM_DDS_DISABLE (user beware if not Disabled).</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_PDW_VALIDATION_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_PDW_VALIDATION_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>FAIL</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the mode of IQ checking in relationship to system reaction FAIL - if not ATTR_SYSTEM_WOF_DISABLE or not ATTR_SYSTEM_DDS_DISABLE, fails the IPL (product default); else act as OFF. INFO - if not ATTR_SYSTEM_WOF_DISABLE or not ATTR_SYSTEM_DDS_DISABLE, error messages to traces; Info error log; WOF AND DDS are disabled; IPL continues. else if act as OFF WARN - if not ATTR_SYSTEM_WOF_DISABLE or not ATTR_SYSTEM_DDS_DISABLE, error messages to traces; no error logs, WOF and DDS are disabled, IPL continues. else if act as OFF OFF - no checking performed; IPL continues. WOF and DDS follow ATTR_SYSTEM_WOF_DISABLE and ATTR_SYSTEM_DDS_DISABLE (user beware if not Disabled).</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_IQ_VALIDATION_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_IQ_VALIDATION_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>FAIL</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Receive PBAX Chipid. Value that indicates this PBA's PBAX Chipid within the Is matched to pbax_chipid of the Address phase if Provided by the Machine Readable Workbook. Platform default:Nimbus systems - set so value in ATTR_FABRIC_GROUP_ID</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PBAX_CHIPID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PBAX_CHIPID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Receive PBAX Groupid. Value that indicates this PBA's PBAX Group affinity. matched to pbax_groupid of the PMISC Address phase. Provided by the Machine Readable Workbook. Platform default:Nimbus systems = 0</description>
    <global />
    <hwpfToHbAttrMap>
      <id>ATTR_PBAX_GROUPID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PBAX_GROUPID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>SPIPSS Clock Frequency (binary in KHz) Valid range: 500KHz to 2500KHz Consumer: p10_pss_init Overridden by the Machine Readable Workbook. If default of 0 is read, HWP will set SPIPSS frequency to 10MHz.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SPIPSS_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SPIPSS_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines which of the PSS chip selects (0 or 1) that the APSS is connected Producer: Machine Readable Workbook Consumer: p10_pm_pss_init</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SPIPSS_SELECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SPIPSS_SELECT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary in microOhms) of the distribution loss sense point to the value is applied to each processor instance. [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p10_pstate_parameter_build</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_DISTLOSS_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_DISTLOSS_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary microOhms) of the load line from a processor VRM to the pins. This value is applied to each processor instance. [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO Note:no loadline may be present in the system; thus, a value of 0 is legal. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p10_pstate_parameter_build</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_LOADLINE_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_LOADLINE_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Offset voltage (binary in microvolts) to apply to the VDD VRM distribution processor module. This value is applied to each processor instance. [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p10_pstate_parameter_build</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_VRM_VOFFSET_UV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_VRM_VOFFSET_UV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus (0, 1 or 2) which has the indicated rail VRM [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO Producer:Machine Readable Workbook Consumers: p10_set_evid; p10_set_voltage (tool) -&gt; Global Pstate Parameter Block (GPPB) for PGPE; OCC Pstate Parameter Block OCC *MOST* systems use Bus 0 for VDD, Bus 1 for VCS, Bus 2 for VIO and VDN. If is not the case, the value must be appropriately set by the platform (eg MRW or equivalent)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_AVSBUS_BUSNUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>AVSBUS_BUSNUM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>AVSBus Clock Frequency (binary in KHz) Consumer: p10_ocb_init.C Overridden by the Machine Readable Workbook. If default of 0 is read, HWP will set AVSBus frequency to 1MHz.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_AVSBUS_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>AVSBUS_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus rail selector number (0 - 15) for the VRM on the bus by ATTR_AVSBUS_BUSNUM[x]. [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO Producer:Machine Readable Workbook Consumers: p10_set_evid; p10_set_voltage (tool) -&gt; Global Pstate Parameter Block (GPPB) for PGPE OCC Pstate Parameter Block OCC *MOST* systems use Bus 0 for VDD, Bus 1 for VCS, Bus 2 for VIO and VDN. If is not the case, the value must be appropriately set by the platform (eg or equivalent)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_AVSBUS_RAIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>AVSBUS_RAIL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Step size (binary in microvolts) to take upon external VRM voltage. This provide a limit of the external VRMs steps. Consumer: p10_pstate_parameter_build -&gt; p10_setup_evid Pstate Parameter (PSPB) for PGPE [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO; Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_STEPSIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_STEPSIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Transition rate (binary in microVolts per microsecond) of the VRM for an transition.This is used as part of the overall voltage time calculation provides a default value of 10000 uV/us (eg if this attribute is zero. the fastest possible rate is limited to Consumer: p10_pstate_parameter_build -&gt; Pstate Parameter Block (PSPB) for PGPE [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO; Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Transition rate (binary in microVolts per microsecond) of the VRM for an transition.This is used as part of the overall voltage time calculation provides a default value of 10000 uV/us (eg if this attribute is zero. the fastest possible rate is limited to Consumer: p10_pstate_parameter_build -&gt; Pstate Parameter Block (PSPB) for PGPE [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO; Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Time (binary in nanoseconds) to allow the voltage rail to stabilize before transition to be fully complete. This value is used for both and transitions as part of the overall voltage transition calculation. provides a default value of 5000ns (5us) if this is zero. Note: the delay is limited to 1ns. Consumer: p10_pstate_parameter_build -&gt; Pstate Parameter Block (PSPB) for PGPE [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO; Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Delay (binary in nanoseconds) from the time the VRM receives the write until the voltage actually moves.This value is used for both and transitions as part of the overall voltage transition calculation. provides a default value of 8000ns (eg 8us)) if attribute is zero. Note: smallest possible delay is limited to 1ns. Consumer: p10_pstate_parameter_build -&gt; Pstate Parameter Block (PSPB) for PGPE [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO; Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_START_NS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_START_NS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Safe mode frequency in MHZ. This attribute is used within the hwp to update DPLL frequency register. Consumer: p10_setup_evid.C Modified by p10_pstate_parameter_build</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SAFE_MODE_FREQUENCY_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SAFE_MODE_FREQUENCY_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Safe mode voltages for VDD and VCS in mV. If not overridden, computed from #V PowerSave voltages uplifted by ATTR_BOOT_VOLTAGE_BIAS_0P5PCT. [index] -&gt;0: VDD; 1: VCS; Consumer: p10_setup_evid.C Modified in p10_pstate_parameter_build</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SAFE_MODE_VOLTAGE_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SAFE_MODE_VOLTAGE_MV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Enables the platform mode where the most recent PMCR update will be the controlling value for Pstate changes. If disabled, the legacy "fastest one wins" algorithm is used. Producer: p10_build_pstate_datablock Consumers: p10_hcode_image_build -&gt; PGPE Header QME attribute</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PMCR_MOST_RECENT_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PMCR_MOST_RECENT_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Size of memory which hostboot must copy from a temp buffer to an unsecure region of main store memory. Once HOMER is built, hostboot reads the attribute and copies the amount of memory specified in this attribute from a temp buffer to an unsecure region of main memory specifed in an attribute ATTR_UNSECURE_HOMER_ADDRESS Producer: Initialized by hostboot firmware based on platform support Consumers: Read by p10_hcode_image_build.C</description>
    <hwpfToHbAttrMap>
      <id>ATTR_UNSECURE_HOMER_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>UNSECURE_HOMER_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x1000</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Time to delay before powering off the MMA due to the lack of MMA instructions. Time = 1ms * 2**ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS. Valid values of 0x00 - 0x17 to yield times from 1ms to 2.3 hours -: 0x00 - 1ms ... 0x01 - 1 second (default) ... 0x17 - 1 day 0x18 - 0xFD - Reserved (maps as 0x17) 0xFE - every QME FIT timer interrupt (~250us) 0xFF - no power off of MMA (QME Hcode still runs; different behavior ATTR_SYSTEM_MMA_POWEROFF_DISABLE) Producer: Machine Readable Workbook Consumer: QME Hcode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xA</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the STOP levels supported by the Hcode in the present driver. Represented as bit vector where bit 0 = STOP0; bit 1 = STOP 1, ..., bit 15 = STOP15.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP_LEVELS_SUPPORTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP_LEVELS_SUPPORTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0xA410</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Disables STOP Level operat?ions in the Power Management complex by mapping the respective level to the next lower supported level in a additive manner. Represented as bit vector where bit 0 = STOP0; bit 1 = STOP 1, ..., bit 15 = STOP15.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP_LEVELS_DISABLED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP_LEVELS_DISABLED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Set the index into a 64 entry Core Throttle Table to use while in Safe Mode. Legal values are 0 to 63. All others are invalid. Consumer: p10_pstate_parameter_build -&gt; PGPE Hcode -&gt; QME Hcode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SAFE_MODE_THROTTLE_IDX</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SAFE_MODE_THROTTLE_IDX</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Limits the number of Pstates below the frequency floor that can be used for throttling. Valid responsive values: 0 to 63. Values above 63 will be capped to 63. Consumer: p10_pstate_parameter_build -&gt; OCC Parameter Block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Establishes the minimum voltage offset at the module pins in mV that the VCS rail is above the VDD rail during Pstate operations when VCS above any established VCS floor defined by ATTR_VCS_FLOOR_MV. If ATTR_VCS_FLOOR_MV is 0, this offset will apply across the entire VCS voltage range. Producer: MRW Consumers: p10_pstate_parameter_build -&gt; PGPE Hcode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VCS_VDD_OFFSET_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VCS_VDD_OFFSET_MV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>20</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Set to indicate clock-start/instruction execution in cache-contained or chip-contained mode will be managed by runn Provided by: platform (FW platforms init to OFF)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_RUNN_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>RUNN_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Base number of clock cycles to execute in runn mode In cache-contained, this is the base number of clock cycles to execute per quad In chip-contained, this is the base number of clock cycles to execute per chip Consumed by: p10_runn HWP (Cronus platform only, chip/cache-contained mode) Provided by: platform (FW platforms init to 0)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_RUNN_CYCLE_COUNT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>RUNN_CYCLE_COUNT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>OMI inband BAR enable. Set by platform.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OMI_INBAND_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OMI_INBAND_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>OMI inband BAR address offset. Set by platform. One OMI bar register is set per MC channel for MMIO and another is set per MC channel for config space. The bar is shared between both sub-channels each with an OCMB. The upper bit of the bar size is used to determine which sub-channel is selected. This means that for two OCMB's their config space is contiguous and their MMIO space is contiguous. Therefore a single OCMB's MMIO and config space cannot be contiguous. However, we can still use one BAR attribute. The p10_omi_setup_bars procedure can interleave the config space and MMIO space as shown in the table bellow. For example, both MMIO and config bar sizes are 2GB. The 2GB bit becomes the selector for the subchannel. The 4GB bit becomes the offset applied for MMIO operations. Each OCMB is assigned one base address attribute. ocmb | BAR ATTRIBUTE | Type | Base reg - end addr | size | sub-ch +-----+--------------------+------+-----------------------------------------+------+------- ocmb0 | 0x0006030200000000 | cnfg | 0x0006030200000000 - 0x000603027FFFFFFF | 2GB | 0 ocmb1 | 0x0006030280000000 | cnfg | 0x0006030280000000 - 0x00060302FFFFFFFF | 2GB | 1 ocmb0 | N/A | mmio | 0x0006030300000000 - 0x000603037FFFFFFF | 2GB | 0 ocmb1 | N/A | mmio | 0x0006030380000000 - 0x00060303FFFFFFFF | 2GB | 1 +-----+--------------------+------+-----------------------------------------+------+------- ocmb2 | 0x0006030400000000 | cnfg | 0x0006030400000000 - 0x000603047FFFFFFF | 2GB | 0 ocmb3 | 0x0006030480000000 | cnfg | 0x0006030480000000 - 0x00060304FFFFFFFF | 2GB | 1 ocmb2 | N/A | mmio | 0x0006030500000000 - 0x000603057FFFFFFF | 2GB | 0 ocmb3 | N/A | mmio | 0x0006030580000000 - 0x00060305FFFFFFFF | 2GB | 1 Used by p10_omi_setup_bars</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OMI_INBAND_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OMI_INBAND_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>True or false whether row repair is supported MRW attribute</description>
    <hwpfToHbAttrMap>
      <id>ATTR_ROW_REPAIR_SUPPORTED_MRW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>ROW_REPAIR_SUPPORTED_MRW</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>UNSUPPORTED</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used in the setting of groups. It is a bit vector. If the value BITWISE_AND 0x01 = 0x01 then groups of 1 are enabled, if the value BITWISE_AND 0x02 = 0x02, then groups of 2 are possible, if the value BITWISE_AND 0x04 = 0x04, then groups of 3 are possible, if the value BITWISE_AND 0x08 = 0x08, then groups of 4 are possible, if the value BITWISE_AND 0x20 = 0x20, then groups of 6 are possible, if the value BITWISE_AND 0x80 = 0x80, then groups of 8 are possible. If no groups can formed according to this input, then an error will be thrown. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_INTERLEAVE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_INTERLEAVE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xAF</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Determines the stride covered by each granule in an interleaving group. The default stride -- 128B -- is the only value intended for production FW use. All other combinations are for experimental performance evaluation. Regardless of this attribute value, groups of size 1, 3, and 6 will be forced to 128B stride based on the logic capabilities.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_INTERLEAVE_GRANULARITY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_INTERLEAVE_GRANULARITY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>REQUIRED: HW mirroring is enabled, and all channels are required to be part of a mirrored group. REQUESTED: HW mirroring is enabled. Mirroring will be configured for groups which support it, but not all channels are required to be mirrored. OFF: HW mirroring is disabled. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_HW_MIRRORING_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MRW_HW_MIRRORING_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Define OMI Ref clock/Swizzle for OCMB/Explorer.. Mapper from OMI unit id -&gt; ROOT CNTL 7 refclk drive enable bit consumer: p10_ocmb_enable</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OMI_REFCLOCK_SWIZZLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OMI_REFCLOCK_SWIZZLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor fabric SL domain (proxime) configuration.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_SL_DOMAIN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_SL_DOMAIN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor fabric broadcast scope configuration. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_BROADCAST_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_BROADCAST_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Processor fabric topology mode, determines format of the topology ID. MODE0 = GGG_C (max 8x2) MODE1 = GG_CC (max 4x4) Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_TOPOLOGY_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_TOPOLOGY_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Processor fabric topology ID associated with this chip. This is a 4-bit field in the format specified by ATTR_PROC_FABRIC_TOPOLOGY_MODE. Provided by the MRW.</description>
    <global />
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_TOPOLOGY_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_TOPOLOGY_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Processor fabric topology ID based on memory availability. If the master chip has memory then EFF_TOPOLOGY_ID = TOPOLOGY_ID, if not then the first socket with memory behind it will swap topology IDs with the master chip to form EFF_TOPOLOGY_ID. All else remains the same. This is a 4-bit field in the format specified by ATTR_PROC_FABRIC_TOPOLOGY_MODE.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_EFF_TOPOLOGY_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_EFF_TOPOLOGY_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Per-link optics configuration OPT0 = SMPA/SMPX/OCAPI/NV OPT1 = SMPA/SMPX OPT2 = SMPA/SMPX OPT3 = SMPA/SMPX/OCAPI/NV OPT4 = SMPA/SMPX/OCAPI/NV OPT5 = SMPA/SMPX/OCAPI/NV OPT6 = SMPA/SMPX/OCAPI/NV OPT7 = SMPA/SMPX/OCAPI/NV Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_CONFIG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IOHS_CONFIG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor optics bus width per link. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_IOHS_BUS_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_IOHS_BUS_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>8</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if the link is used to connect between drawers. Should be considered valid only if ATTR_IOHS_CONFIG_MODE for the given link is configured as an SMPX or SMPA. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_DRAWER_INTERCONNECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IOHS_DRAWER_INTERCONNECT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates the bitrate for the link.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_LINK_SPEED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>LINK_SPEED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>25G</default>
      </uint16_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Processor epsilon table type. Used to calculate the processor nest epsilon register values. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_TABLE_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_EPS_TABLE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of the OMI channel.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_OMI_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_OMI_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>An OMI target's relative logical postion to its OMIC parent target. pos | DL_GROUP_POS -----+-------------- 4 | 0 5 | 1 6 | 2 7 | 0 2 | 1 3 | 2 0 | 0 1 | 1 12 | 0 13 | 1 14 | 2 15 | 0 10 | 1 11 | 2 8 | 0 9 | 1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OMI_DL_GROUP_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OMI_DL_GROUP_POS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>An OMI target's logical DL number pos | DL_NUM -----+-------------- 0 | 6 1 | 7 2 | 4 3 | 5 4 | 0 5 | 1 6 | 2 7 | 3 8 | 14 9 | 15 10 | 12 11 | 13 12 | 8 13 | 9 14 | 10 15 | 11</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OMI_DL_NUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OMI_DL_NUM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Tracks the sequence id for OCMB command transactions. The platform is expected to guarantee a unique value on each read.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OCMB_COUNTER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OCMB_COUNTER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute controls the latches required to configure the PEC as a x16, x8x8, or x8x4x4 based on what PHBs are active defined from the MRW. creator: platform consumer: p10_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. Attribute Name Definition Example Comments Targeted Register Latches ATTR_PROC_PCIE_PHB_ACTIVE (Stack0, Stack1, Stack2) (1, 0, 0) PHB0 enabled TC_PCI_LANE_CFG_DC_0H, TC_PCI_LANE_CFG_DC_1H PHB1 disabled PHB2 disabled Register Latch Definition: PCI0 / PCI1 Register Address Register Name Bit Signal Name Bit Description 8000009 / 9000009 TPPCI.PCI.CPLT_CONF1 0 TC_PCI_LANE_CFG_DC_0H MSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 1 TC_PCI_LANE_CFG_DC_1H LSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 2 TC_PCI_SWAP_DC_2H LANE SWAP control for Stack0 3 TC_PCI_SWAP_DC_3H LANE SWAP control for Stack0 4 TC_PCI_SWAP_DC_4H LANE SWAP control for Stack0 8 TC_PCI_IOVALID_DC_8H IOVALID control for Stack0 9 TC_PCI_IOVALID_DC_9H IOVALID control for Stack1 10 TC_PCI_IOVALID_DC_10H IOVALID control for Stack2</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PHB_ACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PHB_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>3</array>
      <uint8_t>
        <default>ENABLE,DISABLE,DISABLE</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>This attribute controls the latches required to configure the PHBs to swap its lanes if wiring to the connector/device is straight or reverse. creator: platform consumer: p10_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. Attribute Name Definition Example Comments Targeted HWP Attributes ATTR_PROC_PCIE_LANE_REVERSAL (Stack0, Stack1, Stack2) (1, 0, 0) Reverse lanes on PHB0. TC_PCI_LANE_CFG_DC_2H Do not reverse lanes on PHB1. TC_PCI_LANE_CFG_DC_3H Do not reverse lanes on PHB2. TC_PCI_LANE_CFG_DC_4H Register Address Register Name Bit Signal Name Bit Description 8000009 / 9000009 TPPCI.PCI.CPLT_CONF1 0 TC_PCI_LANE_CFG_DC_0H MSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 1 TC_PCI_LANE_CFG_DC_1H LSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 2 TC_PCI_SWAP_DC_2H LANE SWAP control for Stack0 3 TC_PCI_SWAP_DC_3H LANE SWAP control for Stack0 4 TC_PCI_SWAP_DC_4H LANE SWAP control for Stack0 8 TC_PCI_IOVALID_DC_8H IOVALID control for Stack0 9 TC_PCI_IOVALID_DC_9H IOVALID control for Stack1 10 TC_PCI_IOVALID_DC_10H IOVALID control for Stack2</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_LANE_REVERSAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_LANE_REVERSAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>3</array>
      <uint8_t>
        <default>DISABLE,DISABLE,DISABLE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE MMIO BAR enable creator: platform consumer: p10_pcie_config firmware notes: Array index: BAR number (0:2) index 0~1 for MMIO BAR0/1 index 2 for PHB register space</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>3</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE MMIO0 BAR base address offset creator: platform consumer: p10_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 8:47 (excludes system/memory select/group/chip fields) Array index: PHB number (0:5)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>6</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE MMIO1 BAR base address offset creator: platform consumer: p10_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 8:47 (excludes system/memory select/group/chip fields) Array index: PHB number (0:5)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>6</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE PHB register space BAR base address offset creator: platform consumer: p10_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 8:49 (excludes system/memory select/group/chip fields) Array index: PHB number (0:5)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>6</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE MMIO BAR size values creator: platform consumer: p10_pcie_config firmware notes: Array index: BAR number (0:2) NOTE: supported MMIO BAR0/1 sizes are from 64KB-32PB NOTE: only supported PHB register size is 16KB</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_BAR_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>3</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of SYS0 refclock receiver termination</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS0_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYS0_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>NONE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of SYS1 refclock receiver termination</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS1_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYS1_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>NONE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of PCI0 refclock receiver termination</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PCI0_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PCI0_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>NONE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of PCI1 refclock receiver termination</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PCI1_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PCI1_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>NONE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>RCS PLL input for TOD Filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX0A_RCS_PLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX0A_RCS_PLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>RCS PLL input for Nest Filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX0B_RCS_PLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX0B_RCS_PLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>RCS PLL input for IO Filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX0C_RCS_PLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX0C_RCS_PLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>RCS PLL input for IO Spread Spectrum Filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX0D_RCS_PLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX0D_RCS_PLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>MUX 1 input</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX1_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX1_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>MUX 2a input</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX2A_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX2A_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>MUX 2b input</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX2B_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX2B_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>MUX 3 input</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX3_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX3_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PAU DPLL input from Filter PLLs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX10_PAU_DPLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX10_PAU_DPLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>NEST DPLL input from Filter PLLs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX11_NEST_DPLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX11_NEST_DPLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>OMI LCPLL input</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX12_OMI_LCPLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX12_OMI_LCPLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Mux 13 input</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX13_OPT_133_SOURCE_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX13_OPT_133_SOURCE_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Mux 14 input</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX14_OPT_156_SOURCE_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX14_OPT_156_SOURCE_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>IOHS LCPLL input IOHS0: Mux15 IOHS1: Mux16 (no Mux13 input) IOHS2: Mux17 (no Mux13 input) IOHS3: Mux18 IOHS4: Mux19 IOHS5: Mux20 IOHS6: Mux21 IOHS7: Mux22</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX_IOHS_LCPLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX_IOHS_LCPLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>8</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Mux 23 input from FPLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX23_PCI_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX23_PCI_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCI LCPLL input mux control PCI0: Mux24 PCI1: Mux25</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX_PCI_LCPLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_MUX_PCI_LCPLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>setup clock mux settings for TOD Refclock input 0b0 = 32 MHz LPC reference clock 0b1 = 16 MHz I/O Filter PLL Output</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_PLL_MUX_TOD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_PLL_MUX_TOD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Holds the state of Security Access Bit (SAB)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SECURITY_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SECURITY_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Consumed by p10_sbe_select_ex. Dictates policy for selection of active cores and backing caches CRONUS_MAX_ACTIVE -- request maximum set of active cores possible (use case for Cronus istep 4 to establish run state on all functional cores), no backing caches HB_DEFAULT -- request minset of active cores (2 in fused core mode, 1 otherwise) and backing caches (2) HB_MAX_FOOTPRINT -- request the maximum set of backing caches possible (maintaining a power of 2 size, and guaranteeing minset of active cores) HB_MAX_THREADS -- request the maximum set of active cores possible, logically applied after processing HB_MAX_FOOTPRINT directive if set For memory preserving IPLs, the attribute will be honored in the calcuation of active cores, but no backing caches will be requested For cache-contained IPL types, the selection policy is fixed in code -- request maximum set of active cores possible, no backing caches For chip-contained IPL types, the selection policy is fixed in code -- request based on contents of ATTR_CHIP_CONTAINED_ACTIVE_CORES_VEC, ATTR_CHIP_CONTAINED_BACKING_CACHES_VEC</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_SELECT_EX_POLICY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SBE_SELECT_EX_POLICY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Bit vector indicating the active cores to be set by p10_sbe_select_ex for a chip contained IPL. Bit 0 = Core 0, Bit 1 = Core 1, ..., Bit 31 = Core 31.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CHIP_CONTAINED_ACTIVE_CORES_VEC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CHIP_CONTAINED_ACTIVE_CORES_VEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Bit vector indicating the backing caches to be set by by p10_sbe_select_ex. Bit 0 = Cache 0, Bit 1 = Cache 1, ..., Bit 31 = Cache 31.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CHIP_CONTAINED_BACKING_CACHES_VEC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CHIP_CONTAINED_BACKING_CACHES_VEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Chiplet partial good information, direct from module VPD PG keyword</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PG_MVPD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PG_MVPD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Indicates if SBE on this chip is serving as hostboot drawer master</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_SBE_MASTER_CHIP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_SBE_MASTER_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Sector buffer strength</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SECTOR_BUFFER_STRENGTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SECTOR_BUFFER_STRENGTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>enable the pulse mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PULSE_MODE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PULSE_MODE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>DISABLE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>value for pulse mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PULSE_MODE_VALUE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PULSE_MODE_VALUE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>To skip the locking sequence and check for lock of CP TOD Filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_PLLTODFLT_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CP_PLLTODFLT_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>To skip the locking sequence and check for lock of CP Nest Filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_PLLNESTFLT_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CP_PLLNESTFLT_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>To skip the locking sequence and check for lock of CP IO Filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_PLLIOFLT_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CP_PLLIOFLT_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>To skip the locking sequence and check for lock of CP IO Spread Spectrum Filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_PLLIOSSFLT_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CP_PLLIOSSFLT_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Skip locking sequence and check for lock of PAU DPLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PAU_DPLL_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PAU_DPLL_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Skip locking sequence and check for lock of NEST DPLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_DPLL_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NEST_DPLL_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Skip locking sequence and check for lock of IO PLLs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_TANK_PLL_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_TANK_PLL_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Keep skew adjust logic between nest, cores and caches bypassed</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SKEWADJ_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SKEWADJ_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Skew Adjust: Set fixed value for core-cache delay bit 0: override enabled bits 12:15: override value Taken from CP00 MK keyword in VPD</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SKEWADJ_CORE_PDLY_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SKEWADJ_CORE_PDLY_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Skew Adjust: Set fixed value for cache-nest delay bit 0: override enabled bits 12:15: override value Taken from CP00 MK keyword in VPD</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SKEWADJ_CACHE_PDLY_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SKEWADJ_CACHE_PDLY_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Keep core duty cycle adjust logic bypassed</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DCADJ_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DCADJ_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Duty Cycle Adjust: Set fixed value for duty cycle control bit 0: override enabled bits 8:15: override value Taken from CP00 MK keyword in VPD</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DCADJ_DCC_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DCADJ_DCC_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Duty Cycle Adjust: Set duty cycle target different from 50% bit 0: override enabled bits 8:15: override value (signed integer, delta from 50%) Taken from CP00 MK keyword in VPD</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DCADJ_TARGET_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DCADJ_TARGET_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if LPC console is enabled on system</description>
    <hwpfToHbAttrMap>
      <id>ATTR_LPC_CONSOLE_CNFG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>LPC_CONSOLE_CNFG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>ENABLE</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The frequency of the processor refclock in KHz. Provided by the Machine Readable Workbook. This can be overridden to adjust the refclock frequency.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CP_REFCLOCK_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_CP_REFCLOCK_KHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>100000</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of the processor DPLL refclock in KHz. Provided by the Machine Readable Workbook. This can be overridden to adjust the refclock frequency.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_DPLL_REFCLOCK_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_DPLL_REFCLOCK_KHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>133333</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of the IO refclock in KHz. Provided by the Machine Readable Workbook. This can be overridden to adjust the refclock frequency.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_IO_REFCLOCK_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_IO_REFCLOCK_KHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>100000</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The minimum frequency of the core mesh clock, in MHz. Determines the core frequency; nest and caches run at half this value. Must be less than or equal to ATTR_FREQ_CORE_CEILING_MHZ. This can differ per chip in the system. Provided by the #V bucket of module VPD.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_FLOOR_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_CORE_FLOOR_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>2200</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The system-wide minimum frequency of the core mesh clock, in MHz. This is the lowest floor frequency across all chips in the system. Used for fabric epsilon calculations.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_SYSTEM_CORE_FLOOR_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The system-wide maximum frequency of the core mesh clock, in MHz. This is the highest ceiling frequency across all chips in the system. Used for fabric epsilon calculations.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_SYSTEM_CORE_CEILING_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Core boot frequency at 1:1 from Nest DPLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_BOOT_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_CORE_BOOT_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The frequency of the memory controller mesh clock, in MHz. This clock is asynchronous to the nest and drives the MCU queues, and all the associated logic that drives the inputs to the OMI. This can be set differently for each memory controller in the chip.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_MC_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_MC_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of a processor's IOHS mesh clocks, in MHz. This can be set differently on a by-link basis.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_IOHS_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_IOHS_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of a processor's PAU mesh clocks, in MHz. Determines pau and ppe frequency for a given processor. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PAU_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PAU_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The frequency of a processor's PCIe bus in MHz. This is the same for all PCIe buses in the system. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PCIE_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PCIE_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Ref clock SPI bus divider consumed by code running out of OTPROM</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SPI_BUS_DIV_REF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SPI_BUS_DIV_REF</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0x41</default>
      </uint16_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Maximum frequency (in MHz) that this system can run the DIMMs at. There are 5 possible values determined by the dimm configuration. For configurations which have mixed rank configurations, the lowest frequency based on ranks of either DIMM is chosen. For example if there was a 1R and a 2R DIMM installed, and 1R dual drop was a lower max freq than 2R dual drop, then the 1R max freq would be the max allowed. [0]=One rank, single drop [1]=Two rank, single drop [2]=Four rank, single drop [3]=One rank, dual drop [4]=Two rank, dual drop A value of zero would indicate an unsupported configuration. Note: Do not use this attribute to limit configurations, it is not checked during plug rules. If you have an unsupported configuration, use the value 0 as the maximum freq.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MAX_ALLOWED_DIMM_FREQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MAX_ALLOWED_DIMM_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint32_t>
        <default>2400,2400,2400,2400,2400</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Specify the system policy to enforce synchronous mode between memory and nest. This drives the value of ATTR_MEM_IN_SYNCH_MODE. UNDETERMINED : Run synchronously if the dimm and nest freq matches ALWAYS : Require matching frequencies and deconfigure memory that does not match the nest NEVER : Do not run synchronously, even if the frequencies match</description>
    <hwpfToHbAttrMap>
      <id>ATTR_REQUIRED_SYNCH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>REQUIRED_SYNCH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines offset to be applied to SBE bootloader installation this will be added with the base address and hostboot HRMOR offset to get the target base address</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_BOOTLOADER_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SBE_BOOTLOADER_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines offset to be applied to HB bootloader installation this will be added with the bootloader offset and the base address to get the target base addres</description>
    <hwpfToHbAttrMap>
      <id>ATTR_HOSTBOOT_HRMOR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>HOSTBOOT_HRMOR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines sbe boot side that will be put into the exception vector if written</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_BOOT_SIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SBE_BOOT_SIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines if the lpc console is initialized for Hostboot to use</description>
    <hwpfToHbAttrMap>
      <id>ATTR_LPC_CONSOLE_INITIALIZED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>LPC_CONSOLE_INITIALIZED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Instruction for exception vector that will be put into the exception vector if not 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_HBBL_EXCEPTION_INSTRUCT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SBE_HBBL_EXCEPTION_INSTRUCT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Instruction for HB Boatloader to pick the Add-Key Stash Pair from this memory into the exception vector</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_ADDR_KEY_STASH_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SBE_ADDR_KEY_STASH_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the number of key-addr pair available to hostboot</description>
    <hwpfToHbAttrMap>
      <id>ATTR_NUM_KEY_ADDR_PAIR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NUM_KEY_ADDR_PAIR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The minimum number of valid ECs that is required to be used when customizing an SBE image. The customization will fail if it cannot create an image with at least this many ECs.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_IMAGE_MINIMUM_VALID_ECS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SBE_IMAGE_MINIMUM_VALID_ECS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the maximum Seeprom storage size for the fully-customized SBE image permitted by the platform. For platforms (FSP/HB FW) which require the image to be constrained into a physical storage device (SEEPROM), this should reflect the maximum size of that memory (e.g., 512KB). For platforms (Cronus) which may use a customized image in a virtual envrionment with no physical storage constraints, this size may be larger than the physical SEEPROM size.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MAX_SBE_SEEPROM_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MAX_SBE_SEEPROM_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x80000</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Bit vector of dynamic init features which are applied when customizing the IPL image. Individual features are selected/deselected by setting/clearing the corresponding bit in this vector. Note: multiple features can be selected at once.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DYNAMIC_INIT_FEATURE_VEC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DYNAMIC_INIT_FEATURE_VEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Configures position of where to set bit for mmio addr bar. (Bit position = dialvalue + 43)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_DSTLCFG_MMIO_ADDRBIT_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_DSTLCFG_MMIO_ADDRBIT_POS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enable proc downstream transmit template 1. Should be enabled by default.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_ENABLE_DL_TMPL_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_ENABLE_DL_TMPL_1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>ENABLED</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Enable proc downstream transmit template 4. Should be enabled by default.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_ENABLE_DL_TMPL_4</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_ENABLE_DL_TMPL_4</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>ENABLED</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Enable proc downstream transmit template 7. Should be disabled by default.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_ENABLE_DL_TMPL_7</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_ENABLE_DL_TMPL_7</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>DISABLED</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Enable proc downstream transmit template A. Should be disabled by default.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_ENABLE_DL_TMPL_A</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_ENABLE_DL_TMPL_A</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>DISABLED</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Downstream Template 0 pacing</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_TMPL_0_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_TMPL_0_PACING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xF</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Downstream Template 1 pacing</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_TMPL_1_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_TMPL_1_PACING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Downstream Template 4 pacing</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_TMPL_4_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_TMPL_4_PACING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Downstream Template 7 pacing</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_TMPL_7_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_TMPL_7_PACING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Downstream Template A pacing</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_TMPL_A_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_TMPL_A_PACING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The OMI OpenCAPI major version supported by this processor</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_OMI_OC_MAJOR_VER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_OMI_OC_MAJOR_VER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x3</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The OMI OpenCAPI minor version supported by this processor</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_OMI_OC_MINOR_VER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_OMI_OC_MINOR_VER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x1</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Controls the enabling and disabling of smf. Used by unit initfiles, p10_mss_eff_grouping.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SMF_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SMF_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x1</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Device type of I2C slave device</description>
    <hwpfToHbAttrMap>
      <id>ATTR_I2C_DEV_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>I2C_DEV_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Represents the ordinal position of this target compared to other peer GENERICI2CSLAVE targets with the same ATTR_I2C_DEV_TYPE</description>
    <hwpfToHbAttrMap>
      <id>ATTR_I2C_SUB_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>I2C_SUB_POS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Logical position of target within a system. This is derived from the SMP location of each processor and each target's relationship to a proc. - PROC = based on SMP groupid+chipid - MEMBUF = PROC:FAPI_POS * [max membuf per proc] - 1st level child unit = [parent chip]:FAPI_POS * [max children of this type per chip] - 2nd+ level child unit = [immediate parent unit]:FAPI_POS * [max units below parent] Note: This should not be used algorithmically by HWPs directly. Note: Value ignores physical drawer boundaries, the value is unique across the entire system. This data is derived from the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FAPI_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FAPI_POS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>env: 1 = Awan/HWSimulator. 0 = Simics/RealHW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IS_SIMULATION</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IS_SIMULATION</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Which execution platform the HW Procedure is running on Some HWPs (e.g. special wakeup) use different registers for different platforms to avoid arbitration problems when multiple platforms do the same thing concurrently</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXECUTION_PLATFORM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXECUTION_PLATFORM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The manufacturing flags. These enums represent which bit/flag to set in numeric form, NOT binary form. These values/policies can no longer be bit wised together. These numeric values match the flags as found in the PDF document: 'Hypervisor Interface Data Specifications v10.5o-1.pdf', section 6.1.9 and should stay in sync with this document and updated when said document gets updated.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MFG_FLAGS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MFG_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>NOTE: This is being deprecated and being replaced by the attribute ATTR_MFG_FLAGS, found above. Please switch over to the new attribute, ATTR_MFG_FLAGS, ASAP. @TODO: RTC 252027: Remove this attribute when possible The manufacturing flags. This is a bitfield. Each bit is a flag and multiple flags can be set</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MNFG_FLAGS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MNFG_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000000000000000</default>
      </uint64_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>EDPL (Error Detection Per Lane) is a feature in the DL that adds some additional checks to the traffic going across the OpenCAPI link in order to better track which lanes are having issues. Note: EDPL must be set the same on both sides of the link. This attribute affects both the proc/mc side and the OCMB side.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OMI_EDPL_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OMI_EDPL_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>List of memory frequencies supported by the current system.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SUPPORTED_FREQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_SUPPORTED_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>1866,2133,2400,2667</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if the DIMM connected to this controller are in a planar configuration</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_MRW_IS_PLANAR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_MRW_IS_PLANAR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>FALSE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_port Set to below optimum value/ rate. On a per port basis Also used for emergency mode throttle FARB4Q_EMERGENCY_N Used to thermally protect the system in all supported environmental conditions when OCC is not functional Consumer: thermal_init, initfile</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>32</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Thermal Memory Power Limit Used to calculate throttles to be at or under the power limit Per DIMM basis KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY = 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID = 16-18, DIMMS_PER_PORT = 19-20, Bits 21-32: Not used VALUE (bits 32-63) in cW: VMEM+VPP thermal power limit per DIMM = 32-63 Consumers: eff_config_thermal and bulk_pwr_throttles</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>10</array>
      <uint64_t>
        <default>0xffffe000000006a4,0,0,0,0,0,0,0,0,0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Power Curve Intercept for DIMM Used to get the VDDR and VDDR+VPP power curve for each DIMM Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT Key Value pair KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY = 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID = 16-18, DIMMS_PER_PORT = 19-20, Bits 21-32: Not used VALUE (bits 32-63) in cW: VMEM power curve = 32-47 VMEM+VPP power curve = 48-63 Consumers: eff_config_thermal</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PWR_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PWR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>100</array>
      <uint64_t>
        <default>0xffffe00002CC03AE,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Power Curve Slope for DIMM Used to get the VDDR and VDDR+VPP power curve for each DIMM Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT Key Value pair KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY = 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID = 16-18, DIMMS_PER_PORT = 19-20, Bits 21-32: Not used VALUE (bits 32-63) in cW: VMEM power curve = 32-47 VMEM+VPP power curve = 48-63 Consumers: eff_config_thermal</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PWR_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PWR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>100</array>
      <uint64_t>
        <default>0xffffe00003FD0546,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Refresh Rate Desired refresh interval used in refresh register 0, MBAREF0Q_CFG_REFRESH_INTERVAL 7.8 us (SINGLE) 3.9 us (DOUBLE) 7.02 us (SINGLE_10_PERCENT_FASTER) 3.51 us (DOUBLE_10_PERCENT_FASTER)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_REFRESH_RATE_REQUEST</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_REFRESH_RATE_REQUEST</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook DIMM power curve percent uplift for this system at max utilization. Value should be 0 for ISDIMMs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook DIMM power curve percent uplift for this system at idle utilization. Value should be 0 for ISDIMMs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook for the number of M DRAM clocks. One approach to curbing DRAM power usage is by throttling traffic through a programmable N commands over M window.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MEM_M_DRAM_CLOCKS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00000200</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook value for maximum dram data bus utilization in centi percent (c%). Used to determine memory throttle values. Max databus utilization on a per port basis Default to 90%</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MAX_DRAM_DATABUS_UTIL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00002328</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory power control settings programmed during IPL Used by OCC when exiting idle power-save mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_POWER_CONTROL_REQUESTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory power control settings for IDLE powersave mode Used by OCC when entering idle power-save mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook enablement of the HWP code to adjust the VMEM regulator power limit based on number of installed DIMMs.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook VMEM regulator power limit per CDIMM assuming a full configuration. Units in cW Used for Cumulus Consumed in mss_eff_config_thermal</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook VMEM regulator power limit per DIMM assuming a full configuration. Units in cW Consumed in mss_eff_config_thermal</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x000006A4</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook value for the maximum possible number of dimms that can be installed under any of the VMEM regulators. Consumed in eff_config_thermal to calculate mem_watt_target</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to AVDD. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_AVDD_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_AVDD_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to VDD. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VDD_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VDD_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VCS_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VCS_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VPP_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VPP_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to VDDR. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VDDR_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VDDR_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Fine refresh mode. Sets DDR4 MRS3. ZZ uses normal mode. From JEDEC DDR4 Spec 1716.78C from 07-2016 Page 47 Table 4.9.1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_FINE_REFRESH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_FINE_REFRESH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>NORMAL</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Temperature refresh range. Sets DDR4 MRS4. Should be defaulted to extended range. NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less degrees C Used for calculating periodic refresh intervals JEDEC DDR4 spec 1716.78C from 07-2016 page 46 4.8.1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_TEMP_REFRESH_RANGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_TEMP_REFRESH_RANGE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>For resetting the phy delay values at the beginning of calling mss_draminit_training. YES means the vaules will be reset.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>YES</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Describes the settings for periodic calibration for all ports: Reading left to right. (DEFAULT: 0xD90C -&gt; Byte 0(11011001), Byte 1(00001100)) For each bit: OFF = 0, ON = 1. Setting to 0 indicates to disable periodic memcal. Byte 0: 0: ZCAL 1: SYSCK_ALIGN 2: RDCENTERING 3: RDLCK_ALIGN 4: DQS_ALIGN 5: RDCLK_UPDATE 6: PER_DUTYCYCLE 7: PERCAL_PWR_DIS Byte 1: 0: PERCAL_REPEAT 1: PERCAL_REPEAT 2: PERCAL_REPEAT 3: SINGLE_BIT_MPR 4: MBA_CFG_0 5: MBA_CFG_1 6: SPARE 7: SPARE</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0xD90C</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Describes the settings for periodic ZQ calibration for all ports: Reading left to right. For each bit: OFF = 0, ON = 1. Setting to 0 indicates to disable periodic zqcal. Byte 0: 0: ZQCAL All others reserved for future use</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0x8000</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Allows user to manually turn on and off 2N Mode. AUTO indicates to use Signal Integrity generated setting (from VPD).</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DRAM_2N_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DRAM_2N_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>AUTO</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables DRAM Write CRC</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DRAM_WRITE_CRC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DRAM_WRITE_CRC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used in MR4 A3 Temperature refresh mode Should be defaulted to disable</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_TEMP_REFRESH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>An override switch to shut off broadcast mode Enum values: YES: broadcast mode is forced off NO: broadcast mode uses the default value</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_FORCE_BCMODE_OFF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_FORCE_BCMODE_OFF</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>A bitmap containing the plug rules for NVDIMM. 1 if a DIMM supports an NVDIMM being plugged in, 0 if it does not DIMM slot 0 is the left most bit The index to the bitmap is the position of the DIMM target As such, a bitmap of 0b10010000, would allow NVDIMM plugged into DIMM0 and DIMM3 Note: this attribute is a 64 bit number to account for 16 DIMM per processor if there is ever a 4 processor system</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_NVDIMM_PLUG_RULES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_NVDIMM_PLUG_RULES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Switch that allows unsupported raw card references by providing a default raw card setting.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_ALLOW_UNSUPPORTED_RCW</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Bitmap of DRAM widths supported by a system. A 1 indicates that the system supports a density. Enums below represent the the bit location in the attribute for a given DRAM width. Default value is 0xC -&gt; both x4/x8 supported</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_SUPPORTED_DRAM_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xc0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Thermal Memory Power Limit Used to calculate throttles to meet the thermal power per DIMM limit Per DIMM basis, uses first matching KEY entry KEY (0-21): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-8, DIMM_WIDTH = 9-11, DIMM_DENSITY = 12-14, DIMM_STACK_TYPE = 15-16, DRAM_MFGID = 17-19, DIMM_HEIGHT = 20-21, Bits 22-32: Not used VALUE (bits 32-47) in cW: thermal power limit DDIMM: Total OCMB+DRAM power limit per DDIMM non-DDIMM: VMEM+VPP power limit per DIMM</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>25</array>
      <uint64_t>
        <default>0xfffffc0009c40000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Power Curve Slope for DIMM Used to calculate thermal throttles and port power Per DIMM basis, uses first matching KEY entry KEY (0-21): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-8, DIMM_WIDTH = 9-11, DIMM_DENSITY = 12-14, DIMM_STACK_TYPE = 15-16, DRAM_MFGID = 17-19, DIMM_HEIGHT = 20-21, Bits 22-32: Not used VALUE (bits 32-47) in cW/utilization: DIMM power slope DDIMM: Total OCMB+DRAM power slope per DDIMM non-DDIMM: VMEM+VPP power slope per DIMM</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OCMB_PWR_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_OCMB_PWR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>50</array>
      <uint64_t>
        <default>0xfffffc0004620000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Power Curve Intercept for DIMM Used to calculate thermal throttles and port power Per DIMM basis, uses first matching KEY entry KEY (0-21): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-8, DIMM_WIDTH = 9-11, DIMM_DENSITY = 12-14, DIMM_STACK_TYPE = 15-16, DRAM_MFGID = 17-19, DIMM_HEIGHT = 20-21, Bits 22-32: Not used VALUE (bits 32-47) in cW/utilization: DIMM power intercept DDIMM: Total OCMB+DRAM power intercept per DDIMM non-DDIMM: VMEM+VPP power intercept per DIMM</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OCMB_PWR_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_OCMB_PWR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>50</array>
      <uint64_t>
        <default>0xfffffc0005260000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Current Curve Intercept and limit for DIMM Used to calculate throttles to meet regulator current per DIMM limit Per DIMM basis, uses first matching KEY entry For DDIMM, use PMIC SW output that provides worst case throttling KEY (0-21): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-8, DIMM_WIDTH = 9-11, DIMM_DENSITY = 12-14, DIMM_STACK_TYPE = 15-16, DRAM_MFGID = 17-19, DIMM_HEIGHT = 20-21, Bits 22-32: Not used VALUE (bits 32-39): Current limit (dA) DDIMM: PMIC output current limit per DDIMM non-DDIMM: VMEM regulator current limit per DIMM VALUE (bits 40-51): Current slope (cA/utilization) DDIMM: PMIC output current slope per DDIMM non-DDIMM: VMEM regulator current slope per DIMM VALUE (bits 52-63): Current intercept (cA) DDIMM: PMIC output current intercept per DDIMM non-DDIMM: VMEM regulator current intercept per DIMM</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>25</array>
      <uint64_t>
        <default>0xFFFFFC0064152094</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook value for safe mode dram data bus utilization in centi percent (c%). Set to below optimum value/ rate. On a per port basis Also used for emergency mode throttle Used to thermally protect the system in all supported environmental conditions when OCC is not functional Consumer: thermal_init, initfile Default to 2500 c%%</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x000009C4</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates whether the OCMB is allowed to run in enterprise mode, commodity mode, or either. ALLOW_ENTERPRISE = Most permissive, uses whatever is installed in the way it is intended to be used. REQUIRE_ENTERPRISE = Throws an error for any commodity dimms that are installed. FORCE_NONENTERPRISE = Throws an error for any enterprise dimms that are installed.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_ENTERPRISE_POLICY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_ENTERPRISE_POLICY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>ALLOW_ENTERPRISE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Safe mode throttle value for numerator cfg_nm_n_per_port Set to below optimum value/ rate. On a per port basis Also used for emergency mode throttle MBA_FARB4Q_EMERGENCY_N Used to thermally protect the system in all supported environmental conditions when OCC is not functional</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>32</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The lane width of the OpenCapi channel</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of the OpenCAPI</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>3</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates whether to enable adaptation</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>ENABLE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of a processor's nest mesh clock, in MHz. This is the same for all chips in the system. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PB_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PB_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The frequency of a processor's Xbus mesh clocks, in MHz. This is the same for all chips in the system.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_X_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_X_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>2000</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>EQ boot frequency</description>
    <hwpfToHbAttrMap>
      <id>ATTR_BOOT_FREQ_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BOOT_FREQ_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>2400</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Select Nest I2C and pll setting from one of the supported frequencies</description>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_PLL_BUCKET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NEST_PLL_BUCKET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x05</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The frequency of a processor's Obus mesh clocks, in MHz. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_O_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_O_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>1611,1611,1611,1611</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Per-link optics configuration 0 = default = SMP 1 = CAPI 2.0 2 = NV 2.0 3 = OPENCAPI Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OPTICS_CONFIG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OPTICS_CONFIG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>NV</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor SMP Fabric broadcast scope configuration. CHIP_IS_NODE = MODE1 = default CHIP_IS_GROUP = MODE2 Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_PUMP_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_PUMP_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Time between invocations of the 24x7 performance collection function on GPE1. The time (in milliseconds) is derived as 2^PERF_24x7_INVOCATION_TIME_MS with 0 indicating the function is OFF. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Provided by the Machine Readable Workbook to tune the collection. Platform default: 1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PERF_24x7_INVOCATION_TIME_MS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PERF_24x7_INVOCATION_TIME_MS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the L3 Trace array for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_INSTRUCTION_TRACE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CME_INSTRUCTION_TRACE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables pstate parameter block code to use the static system vfrt data Consumer: p9_pstate_parameter_block.C -&gt; Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS_VFRT_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYS_VFRT_STATIC_DATA_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of margin to be applied.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_MARGIN_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OBUS_TX_MARGIN_RATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of tx ffe precusor to apply.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_FFE_PRECURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OBUS_TX_FFE_PRECURSOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of tx ffe postcusor to apply.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_FFE_POSTCURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OBUS_TX_FFE_POSTCURSOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicate if manufacturing tests should be taken pre / post linktraining.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_X_MFG_CHK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_X_MFG_CHK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum eye width to allow passing through manufacturing.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_X_MFG_MIN_EYE_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_X_MFG_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute provides an a way to stress the SMP Abus Even Lanes in Manufacturing. By applying a phase rotator offset we can further stress the phy. This is a 6-bit 2's complement value that would be right justified in the 8 bit UINT attribute value.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_STRESS_PR_OFFSET_EVEN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_STRESS_PR_OFFSET_EVEN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>i This attribute provides an a way to stress the SMP Abus Odd Lanes in Manufacturing. By applying a phase rotator offset we can further stress the phy. This is a 6-bit 2's complement value that would be right justified in the 8 bit UINT attribute value.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_STRESS_PR_OFFSET_ODD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_STRESS_PR_OFFSET_ODD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the CHTM for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_CHTM_TRACE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CME_CHTM_TRACE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>CHTM Trace Memory Configuration value goes directly into CHTM_MEM register. User is responsible to put correct data for each bit field of the register. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_CHTM_TRACE_MEMORY_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CME_CHTM_TRACE_MEMORY_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x00</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Disables the enablement of Voltage Droop Monitors (VDM) in the system. Producer: MRW Consumers: p9_pstate_parameter_block to clear flag for CME QuadManager Hcode reaction</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_VDM_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_VDM_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Disables IVRM enablement in the system Producer: Override Consumers: p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE/OCC CME Quad Pstate Region (CQPR) for CM Quad Manager</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_IVRM_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_IVRM_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>If wof_enabled, defines the Frequency Ratio calculation performed. (THIS IS NOT SUPPORTED IN P9 GA1!).</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_ENABLE_FRATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_ENABLE_FRATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>If wof_enabled, defines the Voltage Ratio calculation performed. THIS IS NOT SUPPORTED AT PRESENT. GA1 SUPPORT IS TBD).</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_ENABLE_VRATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_ENABLE_VRATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>If wof_enabled AND ATTR_WOF_ENABLE_VRATIO = CALCULATED, this attribute selects the Vratio calculation type. ACTIVE_CORES: Vratio is the number of active cores to the number of good cores FULL: Vratio is Vaverage to Vclip(Fclip) where Vclip(Fclip) is the normal interpolated regulator voltage (including load line uplife @ RDP current) derated with presently measured Idd current (from the AVSBus) and the loadline.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_VRATIO_SELECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_VRATIO_SELECT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>SYSTEM Attribute Nest leakage percentage used to calculate the Core leakage. Will eventually be read into OCC Pstate Parameter Block so the OCC can see it for it's calculations. Valid Values: 0% thru 100% Producer: Machine Readable Workbook Consumer: OCC Firmware</description>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_LEAKAGE_PERCENT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NEST_LEAKAGE_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x3C</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicate if manufcaturing tests should be taken pre / post linktraining.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_CHK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_CHK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum eye width to allow passing through manufacturing.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_MIN_EYE_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Alternate settings for short Xbus channels bit 0 -- Disable RX LTE bit 1 -- Disable AC BOOST bit 2 -- Low Gain/Peaking Init Settings bit 3 -- Lower VGA Gain Target -10%</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_XBUS_CHAN_EQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_XBUS_CHAN_EQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if the Obus channel is a board or a cable</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_CHANNEL_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_CHANNEL_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Hierarchical path to the target with respect to logical affinity</description>
    <id>AFFINITY_PATH</id>
    <mrwRequired />
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>System attribute. If all MCS chiplets are in an interleaving group (1=true, 0=false). - If true the SMP fabric is setup in normal mode and multiple MCSs are grouped (disallowing systems with memory only under 1 MCS (i.e. systems with a single C-DIMM)) - If false the SMP fabric is setup in checkerboard mode. Provided by the Machine Readable Workbook. This attribute is based on Machine-Type-Model (MTM) and is setup by the service processor.</description>
    <id>ALL_MCS_IN_INTERLEAVING_GROUP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The asynchronous nest frequency</description>
    <id>ASYNC_NEST_FREQ_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>2000</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory AVDD voltage domain ID. All memory buffers in the same AVDD voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by MRW processing scripts.</description>
    <id>AVDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>BMC FRU ID attribute to report the system firmware levels to the BMC.</description>
    <id>BMC_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Cec Degraded Mode Policy flags Use the CDM_POLICIES enum to decode. If the appropriate bit is 1 then the policy mode is enabled, and those type of Guard records are disabled.</description>
    <id>CDM_POLICIES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>FRU ID attribute for centaur ECID data. This fru ID is used to report the ECID data to the BMC and make it available for systems which have then centaur chips soldered to the backplane.</description>
    <id>CENTAUR_ECID_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The address offset which each Chiplet types pervasive address space used to represent the a chiplet. 0x00 to 0x0F =&gt; For P9 all non-core and non-cache chiplets 0x10 to 0x1F =&gt; All Cache Chiplets 0x20 to 0x37 =&gt; All Core Chiplets 0x38 to 0x3F =&gt; Multicast Operation</description>
    <id>CHIPLET_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>A unit's position within the chip with respect to similar units. Note that this value is relative to the parent chip, not a parent unit. This data is from the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CHIP_UNIT_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CHIP_UNIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's class</description>
    <hasStringConversion />
    <id>CLASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>CLASS</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used to tell I2C code whether to run I2C Engine 2 Port 0 in diag mode or not 0 = Use Diag Mode 1 = Disable Diag Mode</description>
    <id>DISABLE_I2C_ENGINE2_PORT0_DIAG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if system should consider abus logic when deconfiguring in _deconfigureAssocProc(), will be overwritten on multi-node system</description>
    <id>DO_ABUS_DECONFIG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines a negative percentage value that is applied to the ATTR_NOMINAL_FREQ_MHZ determined from MVPD #V. It is used to explicitly raise the value of MIN_FREQ_MHZ above what is specified by MVPD #V data. On FSP systems this is sourced from the power_management def file. Value must be between 0 and -100. A value of zero indicates no override.</description>
    <id>DPO_MIN_FREQ_PERCENT</id>
    <persistency>non-volatile</persistency>
    <range>
      <max>0</max>
      <min>-100</min>
    </range>
    <readable />
    <simpleType>
      <int32_t>
        <default>0</default>
      </int32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Dummy attribute with read-only permissions</description>
    <id>DUMMY_RO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Specifies a target's eeprom content type.</description>
    <hasStringConversion />
    <id>EEPROM_CONTENT_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>EEPROM_CONTENT_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for NV controller.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master.</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value, but then shifted 2 bits left.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value, but then shifted 6 bits left.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x03</default>
        <description>The number of bytes a device requires to set its internal address/offset. For NV controller it's only one byte addressing with no page select (3) 0 = Zero Byte Addressing 1 = One Byte Addressing with page select 2 = Two Byte Addressing 3 = OneByte Addressing with no page select</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x05</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the NV controller on the NVDIMM</description>
    <id>EEPROM_NV_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached I2C eeprom device that contains secondary VPD info.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_VPD_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached I2C eeprom device that contains primary VPD info.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of bytes a device requires to set its internal address/offset. DDR4 DIMMs require a special EEPROM page switching mechanic denoted here by a value of 1 0 = Zero Byte Addressing 1 = One Byte Addressing with page select 2 = Two Byte Addressing 3 = OneByte Addressing with no page select</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM slaves</description>
    <id>EEPROM_VPD_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Attribute indicating the target's engine type</description>
    <hasStringConversion />
    <id>ENGINE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>ENGINE_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Chip attribute. Logical fabric chip id for this chip (position within the fabric). Provided by the Machine Readable Workbook. Can vary across drawers.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CHIP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FABRIC_CHIP_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Chip attribute. Logical fabric group the chip belongs to. Provided by the Machine Readable Workbook. Can vary across drawers.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_GROUP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FABRIC_GROUP_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define addressing this I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>FAPI_I2C_CONTROL_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Common name across FAPI environments chip target -&gt; pu:k0:n0:s0:p00 DIMM target -&gt; dimm:k0:n0:s0:p00 chip unit target -&gt; pu.core:k0:n0:s0:p00:c0 cage/system target -&gt; k0 (chip type).(unit type):k(cage,always zero for us):n(node/drawer) :s(slot,always zero for us):p(chip position):c(core/unit position) pu = generic processor</description>
    <id>FAPI_NAME</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>unknown</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Line Deletes allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Line Deletes allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Column Repairs allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_P8EX_L2_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>7</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Line Deletes allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_P8EX_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Column Repairs allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_P8EX_L3_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>7</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Line Deletes allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_P8EX_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The frequency of the processor refclock in MHz. Provided by the MRW.</description>
    <id>FREQ_PROC_REFCLOCK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FRU ID attribute used to report FRU information to the BMC for each fru in the system.</description>
    <global />
    <id>FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>FSI flags</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Set on FSI master chips (procs) if that chip uses slaveB to attach to the acting master chip.</description>
        <name>flipPort</name>
        <type>uint16_t</type>
      </field>
      <field>
        <bits>15</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint16_t</type>
      </field>
    </complexType>
    <description>Reserved for any special flags we might need to access FSI</description>
    <id>FSI_OPTION_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Size of FSP IO Region</description>
    <id>FSP_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000000100000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure which defines a system's HB settings. Applicable for System target only.</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Enable / Disable continuous trace. 0b0: Continuous trace is disabled. 0b1: Continuous trace is enabled.</description>
        <name>traceContinuous</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Override trace debug selection for SCAN component. 0b0: TRACS entries for SCAN have default behavior. 0b1: TRACS entries for SCAN are enabled.</description>
        <name>traceScanDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Override trace debug selection for DBG component. 0b0: TRACS entries for DBG have default behavior. 0b1: TRACS entries for DBG are enabled.</description>
        <name>traceFapiDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute which describes how the SP has configured features in Hostboot.</description>
    <id>HB_SETTINGS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <writeable />
  </attribute>
  <attribute>
    <description>Hot Plug Controller values for a specific processor. Purpose: Holds information about the hot plug controllers so that a Hardware procedure is able to turn them on and off. Data Format: up to 8 Hot Plug Controllers x 7 variables of information This data is at the processor level. The needed information and their individual sizes are as follows: (1) I2C Master processor engine (uint8_t) (2) I2C Master processor port (uint8_t) (3) Bus Speed (uint16_t value: 2 uint8_t values: MSB, LSB) (4) Slave address (uint8_t) (5) Device type (uint8_t: see SUPPORTED_HOT_PLUG enum) (6) I2C Master processor node (uint8_t) (7) I2C Master processor position (uint8_t) Thus, the information will be 8 bytes.</description>
    <id>HOT_PLUG_POWER_CONTROLLER_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>8,8</array>
      <uint8_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Designates the speed at which a given I2C bus should run. Creator: MRW Purpose: Used by FW to know the fastest possible bus speed that all of the devices on a given bus are able to use. Data Format: 4x16 array of uint16_t values. The first index indicates the engine number of the bus. The second index indicates the port number of the bus. The value in the array is the I2C bus speed used for that engine/port combination in KHz.</description>
    <id>I2C_BUS_SPEED_ARRAY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,16</array>
      <uint16_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define addressing this I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the I2C mux for this device must enable to connect this device to its I2C master, if applicable. 0xFF indicates no I2C mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path of the I2C mux for this device, if any.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>I2C_CONTROL_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>MCS Inband Scom base address</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MCS_INBAND_BASE_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IBSCOM_MCS_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PROC Inband Scom base address</description>
    <id>IBSCOM_PROC_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates types of Key Clear Requests are being made</description>
    <id>KEY_CLEAR_REQUEST</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <default>NONE</default>
        <id>KEY_CLEAR_REQUEST</id>
      </enumeration>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Location code of the Fru target</description>
    <id>LOCATION_CODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max DIMMs per MBA Port available in the system.</description>
    <id>MAX_DIMMS_PER_MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max DMI units per proc available in the system.</description>
    <id>MAX_DMI_PER_PROC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max EX units per proc chip available in the system.</description>
    <id>MAX_EXS_PER_PROC_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max MBAS per membuf available in the system.</description>
    <id>MAX_MBAS_PER_MEMBUF_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max MBA ports per MBA available in the system.</description>
    <id>MAX_MBA_PORTS_PER_MBA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>MBA port DIMM number of this DIMM (deprecated in favor of POS_ON_MEM_PORT)</description>
    <id>MBA_DIMM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>MBA port this DIMM is connected to (deprecated in favor of MEM_PORT)</description>
    <id>MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory port this DIMM is connected to</description>
    <id>MEM_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Due to fabric limitations, we can only enable 2 links at a time during wrap testing. This attribute defines which set this ABUS link belong to. This attribute will live on the OBUS target. The value will come from MRW. When the value for this attribute matches MFG_WRAP_TEST_ABUS_LINKS_SET_ENABLE, then we leave the OBUSes configured. Otherwise, we deconfigure them.</description>
    <id>MFG_WRAP_TEST_ABUS_LINKS_SET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <default>SET_NONE</default>
        <id>MFG_WRAP_TEST_ABUS_LINKS_SET</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute 8 bit rx_min_eye_height value for A bus interfaces during system manufacturing creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_ABUS_MIN_EYE_HEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute 6 bit rx_min_eye_width value for A bus interfaces during system manufacturing creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_ABUS_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. 8 bit rx_min_eye_height value for DMI bus interfaces during system manufacturing; used for both centaur and p8 creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_DMI_MIN_EYE_HEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. 6 bit rx_min_eye_width value for DMI bus interfaces during system manufacturing; used for both centaur and p8 creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_DMI_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the maximum number of L4 Cache CEs allowed. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_CEN_L4_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Base threshold (for 2GB DRAM ) of Memory CEs allowed during IPL. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_CEN_MBA_IPL_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the maximum number of Memory RCEs allowed per Rank during runtime. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_CEN_MBA_RT_RCE_PER_RANK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Base threshold (for 2GB DRAM ) of Memory CEs allowed during runtime. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_CEN_MBA_RT_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Cache CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_L2_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Directory CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_L2_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Line Deletes allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Cache CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_L3_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>3</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Directory CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_L3_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Line Deletes allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>With MNFG thresholds enabled, PRD will make a predictive callout when a memory intermittent MPE attention count is equal to this value. A value of 0 defaults to the max threshold of 0xff.</description>
    <id>MNFG_TH_MEMORY_IMPES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Base threshold (for 2GB DRAM ) of Memory CEs allowed during IPL. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>With MNFG thresholds enabled, PRD will make a predictive callout when a memory intermittent UE attention count is equal to this value. A value of 0 defaults to the max threshold of 0xff.</description>
    <id>MNFG_TH_MEMORY_IUES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>With MNFG thresholds enabled, PRD will make a predictive callout when an RCD parity error (recovery enabled) attention count is equal to this value. A value of 0 defaults to the max threshold of 0xff.</description>
    <id>MNFG_TH_MEMORY_RCD_PARITY_ERRORS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the maximum number of Memory RCEs allowed per Rank during runtime. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_MEMORY_RT_RCE_PER_RANK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Base threshold (for 2GB DRAM ) of Memory CEs allowed during runtime. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Cache CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L2_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Column Repairs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L2_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Directory CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L2_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Line Deletes allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Cache CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L3_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>3</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Column Repairs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L3_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Directory CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L3_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Line Deletes allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>With MNFG thresholds enabled, PRD will make a predictive callout when an RCD parity error (recovery enabled) attention count is equal to this value. A value of 0 defaults to the max threshold of 0xff.</description>
    <id>MNFG_TH_RCD_PARITY_ERRORS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute 6 bit rx_min_eye_width value for X bus interfaces during system manufacturing creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_XBUS_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's model</description>
    <hasStringConversion />
    <id>MODEL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>MODEL</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Attribute indicating the default risk level for the system. Applied if scratch registers are not overriden</description>
    <id>MRW_DEFAULT_RISK_LEVEL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook throttle value for denominator cfg_nm_m</description>
    <id>MRW_MEM_THROTTLE_DENOMINATOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>AVDD memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion />
    <id>MSS_AVDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_CENT_AVDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_ACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_CENT_AVDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_CENT_AVDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_CENT_VCS_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VCS_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VCS_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_CENT_VDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>sets the Centaur address bits used to interleave addresses between MBA01 and MBA23. valid values are 23 through 32.</description>
    <id>MSS_MBA_ADDR_INTERLEAVE_BIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>centaur interleave mode. 1 = 256-BIT, 0 = 128-BIT.</description>
    <id>MSS_MBA_CACHELINE_INTERLEAVE_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VCS memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion />
    <id>MSS_VCS_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VDDR memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic, 3 = DEFAULT - domain needs to be programmed, pgm values in sys xml file</description>
    <hasStringConversion />
    <id>MSS_VDDR_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VDD memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion />
    <id>MSS_VDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_VPP_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/DRAM</description>
    <id>MSS_VOLT_VPP_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: uV/DRAM</description>
    <id>MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>VPP memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion />
    <id>MSS_VPP_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VCS Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the MRW processing scripts.</description>
    <id>NEST_VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VDDR Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the MRW processing scripts.</description>
    <id>NEST_VDDR_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VDD Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the MRW processing scripts.</description>
    <id>NEST_VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VDN Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the MRW processing scripts.</description>
    <id>NEST_VDN_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VIO Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the MRW processing scripts.</description>
    <id>NEST_VIO_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>NPU MMIO BAR base address values creator: platform consumer: proc_setup_bars firmware notes: 64-bit address representing BAR RA NOTE: BAR register covers RA 14:51 first dimension: unit number (0:3) second dimension: BAR number (0:1)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NPU_MMIO_BAR_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>NPU MMIO BAR size values creator: platform consumer: proc_setup_bars firmware notes: none first dimension: unit number (0:3) second dimension: BAR number (0:1)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NPU_MMIO_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Numeric POD type test structure</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path for testing purposes</description>
        <name>fsiPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>CHIP</default>
        <description>Class for testing purposes</description>
        <name>className</name>
        <type>CLASS</type>
      </field>
      <field>
        <default>0xAB</default>
        <description>Test uint8</description>
        <name>uint8</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xABCD</default>
        <description>Test uint16</description>
        <name>uint16</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xABCDEF01</default>
        <description>Test uint32</description>
        <name>uint32</name>
        <type>uint32_t</type>
      </field>
      <field>
        <default>0xABCDEF0123456789</default>
        <description>Test uint64</description>
        <name>uint64</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>-124</default>
        <description>Test int8</description>
        <name>int8</name>
        <type>int8_t</type>
      </field>
      <field>
        <default>-32764</default>
        <description>Test int16</description>
        <name>int16</name>
        <type>int16_t</type>
      </field>
      <field>
        <default>-2147483644</default>
        <description>Test int32</description>
        <name>int32</name>
        <type>int32_t</type>
      </field>
      <field>
        <default>-9223372036854775804</default>
        <description>Test int64</description>
        <name>int64</name>
        <type>int64_t</type>
      </field>
    </complexType>
    <description>Attribute which tests numeric POD types</description>
    <id>NUMERIC_POD_TYPE_TEST</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Lane mask for which 8 lanes belong to this brick This is a right justified 24-bit value. Only 8 of the 24 bits will be set representing the lanes belonging to the associated brick. Provided by the MRW.</description>
    <id>OBUS_BRICK_LANE_MASK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating what kind of payload is to be started.</description>
    <hasStringConversion />
    <id>PAYLOAD_KIND</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <default>PHYP</default>
        <id>PAYLOAD_KIND</id>
      </enumeration>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Base Address of PCI 32 bit Memory Space</description>
    <id>PCI_BASE_ADDRS_32</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Base Address of PCI 64 bit Memory Space</description>
    <id>PCI_BASE_ADDRS_64</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of PCI refclock receiver termination (FSI GP4 bits 10:11)</description>
    <hasStringConversion />
    <id>PCI_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute indicates if the PEC can be bifurcated. The value is determined from the workbook. 0 - PEC is not bifurcateable 1 - PEC can be bifurcated Note: Altering the lane map can be done using the HX keyword.</description>
    <id>PEC_IS_BIFURCATABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Effective PCIE IOP reversal configuration Creator: Firmware Purpose: Holds the effective PCIE IOP reversal value after taking into account any IOP bifurcations. If no IOP bifurcations present, this is just the value of the PROC_PCIE_IOP_REVERSAL_NON_BIFURCATED attribute. Data Format: x4 array of uint8_t values. The first uint8_t value is for lane set 0, the second for lane set 1 and so on. The given index in the array is a mask which specifies which bit to invert in the lane swap settings for the given PEC/lane set.</description>
    <id>PEC_PCIE_IOP_REVERSAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Base PCIE IOP reversal configuration Creator: Firmware Purpose: Holds the PCIE IOP reversal value for cases where the IOP is bifurcated Data Format: x4 array of uint8_t values. The first uint8_t value is lane set 0, the second for lane set 2 and so on. The given index in the array is a mask which specifies which bit to invert in the lane swap settings for the given lane set</description>
    <id>PEC_PCIE_IOP_REVERSAL_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Base PCIE IOP reversal configuration Creator: Firmware Purpose: Holds the base PCIE IOP reversal value without considering IOP bifurcation. Data Format: x4 array of uint8_t values. The first uint8_t value is for lane set 0, the second for lane set 1 and so on. The given index in the array is a mask which specifies which bit to invert in the lane swap settings for the given lane set.</description>
    <id>PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Bifurcated PCIE IOP swap configuration value Creator: MRW Purpose: Holds the base IOP swap configuration value for the IOPs in the case where they are bifurcated. The swap value controls how PCIE lanes are recordered when the leave the IOP, to provide lane routing flexibility. Data Format: A uint8_t value. The value specifices for the hardware how to swap the PCIE lanes for the given PEC.</description>
    <id>PEC_PCIE_IOP_SWAP_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE Lane Mask bifurcated configuration Creator: MRW Purpose: Holds the PCIE lane mask assuming IOPs are bifurcated. Data Format: x4 array of uint16_t values. The first uint8_t value is lane set 0, the second for lane set 2 and so on. A lane set mask indicates which groups of lanes are assigned to an IOP. For instance, lane set 0 value of 0xFF00 and lane set 1 value of 0x00FF means the IOP is bifurcated into two x8s.</description>
    <id>PEC_PCIE_LANE_MASK_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Peer target's address of a bus (IOHS) connection. NULL means address 0 for no peer target. If a target instance overrides the default with the peer target's PHYS_PATH. The target compiler will convert the valid PHYS_PATH string into the runtime virtual address of the peer target instance.</description>
    <id>PEER_TARGET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <Target_t>
        <default>NULL</default>
      </Target_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Base Address of PHB Register Space</description>
    <id>PHB_BASE_ADDRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Physical hierarchical path to the target</description>
    <id>PHYS_PATH</id>
    <mrwRequired />
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Set to 1 by HWSV to indicate that attribute overrides exist in a PLCK IPL (not an IPL by steps). This is read by Hostboot to determine if it needs to request the attribute overrides from HWSV before starting its IPL.</description>
    <id>PLCK_IPL_ATTR_OVERRIDES_EXIST</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Position of target relative to node</description>
    <id>POSITION</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Position of this DIMM on its memory port</description>
    <id>POS_ON_MEM_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Hierarchical path to the target with respect to power</description>
    <id>POWER_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Required Processor Compatibility Setting</description>
    <id>PROC_COMPATIBILITY_REQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>PROC_COMPATIBILITY_REQ</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>PROC_CHIP Attribute If true, the chip is installed on a Dual Chip Module Provided by the Machine Readable Workbook</description>
    <id>PROC_DCM_INSTALLED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Enumeration of the type of processor module used in the system. Expected to be filled out by the MRW and expected to be the same for every processor module in the system</description>
    <id>PROC_MODULE_TYPE</id>
    <mrwRequired />
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>PROC_MODULE_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE IOP lane configuration creator: platform consumer: proc_pcie_scominit firmware notes: Encoded PCIE IOP lane configuration</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_IOP_CONFIG</id>
    <ignoreEkb />
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Indicates whether PCIE lanes terminate at a pluggable slot Creator: MRW Purpose: Used by FW to know whether the given PCIE lanes terminate at a pluggable slot or not. If this is the case, and the platform supports bifurcation, the card's VPD should be interrogated to determine whether to bifurcate the IOP or not. Data Format: x4 array of uint8_t values. The first value indicates whether lane set 0 terminates at a pluggable slot. The next three values indicate the same for lane sets 1-3. A value of 1 at a given array index indicates the lanes terminate at a pluggable slot, 0 otherwise.</description>
    <id>PROC_PCIE_IS_SLOT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE Lane Equalization values for each PHB Creator: MRW Purpose: Holds settings which are loaded into the HW to optimize the PCIE lane signal eye between the chips + PCIE Gen3 endpoints Data Format: 16 entries of 16 bytes of EQ data per PHB. Each PHB has an EQ value for each of its 16 lanes. Each value is a uint16 formatted as follows: Bit 0:3 - up_rx_hint (bit 0 reserved) Bit 4:7 - up_tx_preset Bit 8:11 - dn_rx_hint (bit 0 reserved) Bit 12:15 - dn_tx_preset</description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE Lane Equalization values for each PHB Creator: MRW Purpose: Holds settings which are loaded into the HW to optimize the PCIE lane signal eye between the chips + PCIE Gen4 endpoints Data Format: 16 entries of 16 bytes of EQ data per PHB. Each PHB has an EQ value for each of its 16 lanes. Each value is a uint16 formatted as follows: Bit 0:3 - up_rx_hint (bit 0 reserved) Bit 4:7 - up_tx_preset Bit 8:11 - dn_rx_hint (bit 0 reserved) Bit 12:15 - dn_tx_preset</description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN4</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx loff control creator: platform consumer: p9_pcie_scominit firmware notes: The value of rx loff control for PCS. Array index: Configuration number index 0~3 for CONFIG0~3</description>
    <id>PROC_PCIE_PCS_RX_LOFF_CONTROL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS rx phase rotator control creator: platform consumer: p9_pcie_scominit</description>
    <id>PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS rx sigdet control creator: platform consumer: p9_pcie_scominit</description>
    <id>PROC_PCIE_PCS_RX_SIGDET_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx vga control register3 creator: platform consumer: p9_pcie_scominit firmware notes: The value of rx vga control register3. Array index: Configuration number index 0~3 for CONFIG0~3</description>
    <id>PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS system control creator: platform consumer: p9_pcie_scominit</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_SYSTEM_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_SYSTEM_CNTL</id>
    <ignoreEkb />
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Value of PCS tx fifo config offset creator: platform consumer: p9_pcie_scominit</description>
    <id>PROC_PCIE_PCS_TX_FIFO_CONFIG_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of processor refclock receiver termination (FSI GP4 bits 8:9)</description>
    <hasStringConversion />
    <id>PROC_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The number of reconfig loops allowed due to RCD parity errors when recovery is disabled. PRD will make a predictive callout and stop issuing reconfigs due to RCD parity errors when RCD_PARITY_RECONFIG_LOOP_COUNT is greater than this value. A value of 0 indicates that no reconfig loops are allowed due to RCD parity errors.</description>
    <id>RCD_PARITY_RECONFIG_LOOPS_ALLOWED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>1 = System has redundant clock oscillators 0 = System does not have redundant clock oscillators From the Machine Readable Workbook</description>
    <id>REDUNDANT_CLOCKS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used to tell if a resource is critical to perform an IPL. If this attribute is set to 1 and the target is deconfigured, the IPL MUST terminate.</description>
    <id>RESOURCE_IS_CRITICAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Size of RNG IO Region</description>
    <id>RNG_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x000000000001000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Base Address of RNG IO Region</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>RNG_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Control execution of updateProcessorSbeSeeproms() if 0, enable SBE update of processor SEEPROM if 1, disable SBE update of processor SEEPROM Consumer: sbe_update.C Default: 0</description>
    <id>SBE_UPDATE_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure which defines a system's SP functions. Applicable for System target only. Structure is read-only. Default values match OpenBMC implementation.</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>If this flag is set then mailboxEnabled MUST also be set 0b0: SP does not support for VPD, payload, ATTR sync, VDDR, TOD; 0b1: SP supports VPD, payload, ATTR sync, VDDR, TOD</description>
        <name>baseServices</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: SP does not initialize FSI slave logic, Hostboot must; 0b1: SP does initialize FSI slave logic so Hostboot should not</description>
        <name>fsiSlaveInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: There is no SP mailbox support; 0b1: There is SP mailbox support</description>
        <name>mailboxEnabled</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: SP does not initialize FSI master logic, Hostboot must; 0b1: SP does initialize FSI master logic so Hostboot should not</description>
        <name>fsiMasterInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: SP does not perform hardware change detection, Hostboot must; 0b1: SP does perform hardware change detection (HCDB) so Hostboot should not</description>
        <name>hardwareChangeDetection</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: SP does not perform Power Line Disturbance (PLD) detection, Hostboot must; 0b1: SP does perform Power Line Disturbance (PLD) detection so Hostboot should not</description>
        <name>powerLineDisturbance</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>26</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Attribute which describes what the SP is or is not doing in this system</description>
    <id>SP_FUNCTIONS</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP5 as STOP5 if ON, treat STOP5 as STOP4 Producer: ??? Consumer: p8_hcode_image_build.C Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP5_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP5_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>STOP levels supported at runtime (sent to Host via HDAT): Bit 0: STOP0 Supported - Quiesce thread only Bit 1: STOP1 Supported - P8 Nap Bit 2: STOP2 Supported - P8 Fast Sleep Bit 3: STOP3 Supported - P8 Fast Sleep using iVRMs Bit 4: STOP4 supported - P8 Deep Sleep Bit 5: STOP5 Supported - WOF-friendly "Instant on" Bit 6,7: Reserved Bit 8: STOP8 supported - Half Quad Sleep Bit 9: STOP9 supported - P8 Fast Winkle Bit 10: Reserved Bit 11: STOP11 supported - P8 Deep Winkle Bit 12-15 : Reserved Bits 16..31 - Reserved</description>
    <id>SUPPORTED_STOP_STATES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0xEC100000</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Do we support dynamically updating memory voltages? 0 = no, 1 = yes</description>
    <id>SUPPORTS_DYNAMIC_MEM_VOLT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This field is of the form "vendor,name" where the name indicates the family of the systems. The textual portion of the string has a maximum length of 63 characters to accommodate a terminating NULL. Both vendor and name fields are lower case US ASCII. No special characters other than ",", "-", and "+" as described below should be used in the string.</description>
    <id>SYSTEM_FAMILY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ibm,p9</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>This field is of the form ?vendor,type? where the type indicates a type of system within the System Family. The textual portion of the string has a maximum length of 63 characters to accommodate a terminating NULL. Both vendor and name fields are lower case US ASCII. No special characters other than ",", "-", and "+" as described below should be used in the string. If identification of specific models within a system type is desired, "-model" should be appended to the end of the name. The "-model" portion is optional and could be used to identify the packaging, specific model numbers, etc. NOTE: No Hostboot code should ever key off of this value.</description>
    <id>SYSTEM_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ibm,miscopenpower</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>TEMP_SENSOR_I2C_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C TPM.</description>
      <field>
        <default>0x0</default>
        <description>Boolean indicating whether this TPM is available in the system</description>
        <name>tpmEnabled</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x01</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xAE</default>
        <description>Device address on the I2C bus for Locality 0. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality0</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA8</default>
        <description>Device address on the I2C bus for Locality 1. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality1</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xAA</default>
        <description>Device address on the I2C bus for Locality 2. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality2</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA4</default>
        <description>Device address on the I2C bus for Locality 3. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality3</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA6</default>
        <description>Device address on the I2C bus for Locality 4. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality4</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x00</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the TPM slaves</description>
    <id>TPM_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Setting to require(0x1) or not require(0x0) a functional TPM to boot the system.</description>
    <id>TPM_REQUIRED</id>
    <persistency>non-volatile</persistency>
    <range>
      <max>1</max>
      <min>0</min>
    </range>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Attribute indicating the target's type</description>
    <hasStringConversion />
    <id>TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory VCS voltage domain ID. All memory buffers in the same VCS voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by MRW processing scripts.</description>
    <id>VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory VDD voltage domain ID. All memory buffers in the same VDD voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by MRW processing scripts.</description>
    <id>VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory VPP voltage domain ID. All memory buffers in the same VPP voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by MRW processing scripts.</description>
    <id>VPP_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System control to set the power limit for Workload Optimized Frequency (WOF) algorithms. This is used to select the proper VFRT tables. Producer: TMGT Consumers: FW that selects VFRT tables</description>
    <id>WOF_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>LID id used to load tables for Workload Optimized Frequency (WOF) algorithms. Producer: TMGT Consumers: FW that selects VFRT tables</description>
    <id>WOF_TABLE_LID_NUMBER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x81E00440</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Indicates which istep we should execute the CXX testcases after, if CONFIG_EARLY_TESTCASES is set. Format: 0xMMmm, where MM=major step, mm=minor step, e.g. 6.9=0x0609.</description>
    <id>EARLY_TESTCASES_ISTEP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0x0609</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of the memory controller channel. In synchronous mode, this is equivalent to ATTR_FREQ_PB_MHZ. This may be independently set per pair of memory channels if operating in asynchronous mode, but this configuration is not anticipated. This clock drives the MCU queues, and all the associated logic that drives the inputs to the DMI and reads its outputs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_MCA_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_MCA_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addessing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0/node-0/proc-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xC0</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>2</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Logical GPIO pin number used to open or close the physcial presence window</description>
        <name>windowOpenPin</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>1</default>
        <description>Logical GPIO pin number used to determine if physical presence was asserted</description>
        <name>physicalPresencePin</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address GPIO device that corresponds to the Physical Presence Detect circuit</description>
    <id>GPIO_INFO_PHYS_PRES</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Designates if this this IPL was due to a request to open the Physical Presence Window: 0 - This IPL was NOT due to a Request to Open Window 1 - This IPL was due to a Request to Open Window</description>
    <id>PHYS_PRES_REIPL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Indicates TPM Model (or family) for a TPM Target 0x00 = Undetermined (reserved if actively detected in the future) 0x01 = Nuvoton 65x (default) 0x02 = Nuvoton 75x</description>
    <id>TPM_MODEL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>LX keyword VPD data for HDAT module</description>
    <id>ASCII_VPD_LX_KEYWORD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Attribute indicating the target's chip version</description>
    <hasStringConversion />
    <id>CHIP_VER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>CHIP_VER</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's hw version</description>
    <hasStringConversion />
    <id>HW_VER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>HW_VER</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if Idle Power Save is enabled. This is independent of the OPEN_POWER_PM_MODE (DPS and IPS can be enabled at the same time). Valid Values: 0 = Disabled (default), 1 = Enabled. See IPS_ENTER / IPS_EXIT attributes for IPS configuration.</description>
    <id>IPS_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>When IPS is enabled, this defines the delay time in seconds (between 10 and 600) to enter Idle Power Save.</description>
    <id>IPS_ENTER_TIME_SECONDS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>240</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>When IPS is enabled, this defines the utilization threshold as a percent (between 0 and 100) to enter Idle Power Save. This value should be less than IPS_EXIT_UTILIZATION_PERCENT.</description>
    <id>IPS_ENTER_UTILIZATION_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>When IPS is enabled, this defines the delay time in seconds (between 10 and 600) to exit Idle Power Save.</description>
    <id>IPS_EXIT_TIME_SECONDS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>10</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>When IPS is enabled, this defines the utilization threshold as a percent (between 0 and 100) to exit Idle Power Save. This value should be greater than IPS_ENTER_UTILIZATION_PERCENT.</description>
    <id>IPS_EXIT_UTILIZATION_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>12</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Power management mode the system should use. Valid values: 1 = Nominal (default), 5 = Static Power Save (percentage below nominal whose value is defined in OPEN_POWER_PM_MODE_FREQ_PERCENT), 6 = Dynamic Power Save - Favor Energy (DPS-FE), 10 = Dynamic Power Save - Favor Performance (DPS-FP), 11 = Fixed Frequency Override - (percentage above nominal whose value is defined in OPEN_POWER_PM_MODE_FREQ_PERCENT)</description>
    <id>OPEN_POWER_PM_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Percentage from nominal that the processors should run at when OPEN_POWER_PM_MODE is set to Static Power Save or Fixed Frequency Override (ignored on all other modes). Unit is in tenths of a percent (150 = 15.0%). Static Power Save (5): percentage to decrease frequency, Fixed Frequency Override (11): percentage to increase frequency</description>
    <id>OPEN_POWER_PM_MODE_FREQ_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PHYP system type value for habanero and barreleye (0x3015 and 0x3016 respectively). The value is updated in the system xml.</description>
    <id>PHYP_SYSTEM_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Hardware topology for HDAT creator:MRW consumer:HDAT firmware notes: Hardware Topology 2 Bytes Byte 1: bit 0-3: Node Id bit 4-7: Socket id inside the node bit 8-11: Proc id inside socket bit 12-15:Hub Id inside proc</description>
    <id>PROC_HW_TOPOLOGY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's role</description>
    <hasStringConversion />
    <id>ROLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>ROLE</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's software version</description>
    <hasStringConversion />
    <id>SW_VER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>SW_VER</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Brand Name of OEM systems</description>
    <id>SYSTEM_BRAND_NAME</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>ADC Channel function id. 16 channels.</description>
    <id>ADC_CHANNEL_FUNC_IDS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ADC channel gain * 1000. 16 channels.</description>
    <id>ADC_CHANNEL_GAINS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ADC Channel ground. 16 channels.</description>
    <id>ADC_CHANNEL_GNDS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ADC channel offset * 1000. 16 channels</description>
    <id>ADC_CHANNEL_OFFSETS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ADC Channel IPMI sensor numbers. 16 channels.</description>
    <id>ADC_CHANNEL_SENSOR_NUMBERS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Flag used to allow sending informational call-home errors as ESELS to the BMC</description>
    <id>ALLOW_CALLHOME_ESELS_TO_BMC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>APSS GPIO PORT MODES</description>
    <id>APSS_GPIO_PORT_MODES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>APSS GPIO PORT PINS Port0 pin 0-7 Port1 pin 8-15</description>
    <id>APSS_GPIO_PORT_PINS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The type of hardware of the BMC</description>
    <id>BMC_HW_CHIP_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ast2500</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>The manufacturer of the BMC</description>
    <id>BMC_MANUFACTURER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ibm</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>max size of error log that can be sent to BMC</description>
    <id>BMC_MAX_ERROR_LOG_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>2048</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The software type of the BMC</description>
    <id>BMC_SW_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>openbmc</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addessing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Logical GPIO pin number used to enabled/disable VDDR</description>
        <name>vddrPin</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address GPIO device</description>
    <id>GPIO_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C address from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C bus frequency in Hz from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_BUS_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the string descriptions of the I2C devices from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_DEVICE_LABEL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C device purpose from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C device type from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_DEVICE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the number of elements that were found under this particular target, and how many devices are stored in the arrays.</description>
    <id>HDAT_I2C_ELEMENTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C Engine from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_ENGINE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C Master Port from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_MASTER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C slave port from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_SLAVE_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Holds the IPMI instance number for this entity.</description>
    <id>IPMI_INSTANCE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute to hold 16 pairs of sensor name, sensor number pairs. A sensor name consists of one byte of general sensor type and one byte of sub-type</description>
    <id>IPMI_SENSORS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16,2</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Specifies if the mpipl is supported on this platform 0 : No , 1 : Yes</description>
    <id>IS_MPIPL_SUPPORTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum theoretical Vdd current reading in 10mA units. Used when VDD_CURRENT_OVERFLOW_WORKAROUND_ENABLE is set.</description>
    <id>MAX_VDD_CURRENT_READING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0x0000</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Power used by components other than CPU, memory, or GPUs in Watts</description>
    <id>MISC_SYSTEM_COMPONENTS_MAX_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_chip</description>
    <id>MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>A constant power (in watts) that the OCC is to add onto Vdd and Vdn power to represent any processor part that is not measured(i.e.Vcs,Vio) This is used by the OCC to calculate a total processor socket power.</description>
    <id>NO_APSS_PROC_POWER_VCS_VIO_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Specifies the compatible model name for Opal to key off of. This is sourced from the MRW and should be of the format 'vendor,model', e.g. 'tyan,palmetto'.</description>
    <id>OPAL_MODEL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ibm,miscopenpower</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>DIMM temperature where an error will be generated in degrees C</description>
    <id>OPEN_POWER_DIMM_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DIMM read timeout in seconds</description>
    <id>OPEN_POWER_DIMM_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DIMM temperature threshold where throttling will occur in degrees C</description>
    <id>OPEN_POWER_DIMM_THROTTLE_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>GPU core temperature error threshold in degrees C</description>
    <id>OPEN_POWER_GPU_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>GPU memory temperature error threshold in degrees C</description>
    <id>OPEN_POWER_GPU_MEM_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>GPU memory temperature read timeout in seconds</description>
    <id>OPEN_POWER_GPU_MEM_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>GPU core temperature read timeout in seconds</description>
    <id>OPEN_POWER_GPU_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Weight factor (in 1/10ths) for each L3 DTS to calculate a core temperature.</description>
    <id>OPEN_POWER_L3_WEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory controller temperature where an error will occur in degrees C</description>
    <id>OPEN_POWER_MEMCTRL_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory controller read timeout in seconds</description>
    <id>OPEN_POWER_MEMCTRL_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory controller temperature threshold where throttling will occur in degrees C</description>
    <id>OPEN_POWER_MEMCTRL_THROTTLE_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum memory utilization percent (from 0-100) for power capping</description>
    <id>OPEN_POWER_MIN_MEM_UTILIZATION_POWER_CAP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum memory utilization percent (from 0-100) for memory throttling</description>
    <id>OPEN_POWER_MIN_MEM_UTILIZATION_THROTTLING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum hard power cap in Watts</description>
    <id>OPEN_POWER_MIN_POWER_CAP_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>N mode bulk power supply limit in Watts</description>
    <id>OPEN_POWER_N_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum power allocated to DIMMs in Watts</description>
    <id>OPEN_POWER_N_MAX_MEM_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>N+1 bulk power limit in Watts for systems running with redundant power supplies (default)</description>
    <id>OPEN_POWER_N_PLUS_ONE_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>N+1 bulk power limit in Watts for High Performance Computing systems running with a non-redundant power supply policy</description>
    <id>OPEN_POWER_N_PLUS_ONE_HPC_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>N+1 max memory power in Watts</description>
    <id>OPEN_POWER_N_PLUS_ONE_MAX_MEM_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor temperature where DVFS will occur in degrees C</description>
    <id>OPEN_POWER_PROC_DVFS_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor temperature error threshold in degrees C</description>
    <id>OPEN_POWER_PROC_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor read timeout in seconds</description>
    <id>OPEN_POWER_PROC_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Weight factor (in 1/10ths) for each core DTS to calculate a core temperature.</description>
    <id>OPEN_POWER_PROC_WEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Weight factor (in 1/10ths) for each quad (racetrack) DTS to calculate a core temperature.</description>
    <id>OPEN_POWER_QUAD_WEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Regulator efficiency factor</description>
    <id>OPEN_POWER_REGULATOR_EFFICIENCY_FACTOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum soft power cap in Watts</description>
    <id>OPEN_POWER_SOFT_MIN_PCAP_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>If this system supports Turbo frequency mode. 0x00 = no 0x01 = yes</description>
    <id>OPEN_POWER_TURBO_MODE_SUPPORTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>VRM read timeout in seconds (from 0-255) Use 0 to disable VRM OT monitoring</description>
    <id>OPEN_POWER_VRM_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VRM Vdd Temperature in degrees C to invoke DVFS (clip max Pstate)</description>
    <id>OPEN_POWER_VRM_VDD_DVFS_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VRM Vdd Temperature in degrees C that an overtemp error will be logged</description>
    <id>OPEN_POWER_VRM_VDD_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum time in seconds allowed without having a new VRM Vdd temperature before DVFS will occur</description>
    <id>OPEN_POWER_VRM_VDD_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Frequency (in MHz) for 1 Watt of processor power change. Used by the power capping algorithm to determine how much to change the frequency based on power available. This is used in populating CALCULATED_MAX_SYS_POWER_EXCLUDING_GPUS</description>
    <id>PROC_MHZ_PER_WATT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>28</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The maximum power a single procesor socket can support (in watts) This is used to populate CALCULATED_MAX_SYS_POWER_EXCLUDING_GPUS</description>
    <id>PROC_SOCKET_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>250</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if OCC should wait to report DVFS due to power/thermal until max frequency has been lowered below nominal. Default OCC will report DVFS when max frequency is lowered below turbo. DVFS is reported in poll response extended status bits and in OPAL shared memory throttle status byte. 1 = OCC report throttling only when max freq. lowered below nominal 0 = OCC report throttling when max freq. lowered below turbo</description>
    <id>REPORT_THROTTLE_BELOW_NOMINAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used to enable Vdd current overflow worakaround. To enable this attribute should be set to 1 and MAX_VDD_CURRENT_READING must be populated. Set to 0 to disable.</description>
    <id>VDD_CURRENT_OVERFLOW_WORKAROUND_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0x0000</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <enumerationType>
    <description>Indicates the response of the DPLL frequency upon DDS events if is not ON. NONE -&gt; DPLL Mode 2, JUMP_PROTECT -&gt; DPLL Mode 3, SLEW_MODE -&gt; DPLL Mode 4 Producer: MRWB</description>
    <enumerator>
      <name>NONE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>JUMP_PROTECT</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>SLEW_MODE</name>
      <value>0x02</value>
    </enumerator>
    <id>DDS_DPLL_SLEW_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables pstate parameter block code to use the static #W data Consumer: p10_pstate_parameter_build.C Platform default:OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>POUND_W_STATIC_DATA_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables pstate parameter block code to use the static #V data Consumer: p10_pstate_parameter_block.C Platform default:OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>POUND_V_STATIC_DATA_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables pstate parameter block code to use the static system vrt data Consumer: p10_pstate_parameter_build.C -&gt; PGPE Hcode Platform default:OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>VDN_STEP_OFF</name>
      <value>0x02</value>
    </enumerator>
    <id>SYS_VRT_STATIC_DATA_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Debug modes supported for QME Scan layout in HOMER.</description>
    <enumerator>
      <name>SCAN_RING_NO_DEBUG</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>SCAN_RING_TRACE_DEBUG</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>SCAN_RING_DEEP_DEBUG</name>
      <value>0x02</value>
    </enumerator>
    <id>SYSTEM_RING_DBG_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Switch to enable or disable Power Management Complex FFDC collection during the PM Complex Halt flow to HOMER to assist with failure analysis and recovery. Producer: HB must set or reset this based on the platform use-case and p10_pm_halt.C, p10_pm_callout.C</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x01</value>
    </enumerator>
    <id>PM_HALT_FFDC_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Disables RVRM enablement in the system Producer: Override Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_RVRM_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Disables Work Load Optimized Frequency (WOF) algorithms to modify frequency active core count and other inputs. OFF:Will enable WOF given all validity check pass. If validity checks fail, be disabled for the present IPL. ON: Will disable WOF OFF_SKIP_DD: as but skips any validity checking of the design level (lab use Producer: Override Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>OFF_SKIP_DD</name>
      <value>2</value>
    </enumerator>
    <id>SYSTEM_WOF_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Disables Workload Optimized Voltage (WOV) undervolting algorithms which voltage below the value calculated from VPD. OFF: Will enable WOV overvolting given all validity check pass. If validity WOV overvolting will be disabled for the present IPL. ON:Will disable overvolting Producer: Override Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_WOV_OVERV_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Disables Workload Optimized Voltage (WOV) undervolting algorithms which voltage below the value calculated from VPD. OFF:Will enable WOV undervolting given all validity check pass. If validity WOV undervolting will be disabled for the present IPL. ON: Will disable undervolting Producer: Override Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_WOV_UNDERV_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>If WOF Throttle Control Loop is enabled, then selects the mode to update throttle control values. BINARY: Will update the throttle control values by half the current value of throttle. DECINC: Will update throttle control value by one in each step. Producer: Override Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)</description>
    <enumerator>
      <name>BINARY</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>DECINC</name>
      <value>0x1</value>
    </enumerator>
    <id>WOF_THROTTLE_CONTROL_LOOP_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables the PGPE to clip Pstates based on the sibling Dual Chip Module (DCM) Pstate value to have the combination generally track. The DCM values are NOT interlocked as this is to aid in thermal management. Producer: p10_build_pstate_datablock Consumers: PGPE HCode</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>WOF_DCM_TRACKING_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Defines the mode of #V checking in relationship to system reaction FAIL - if not ATTR_SYSTEM_PSTATE_DISABLE, fails the IPL (product default). else act as OFF INFO - if not ATTR_SYSTEM_PSTATE_DISABLE, Info error log; Pstates are disabled; IPL continues. else act as OFF WARN - if not ATTR_SYSTEM_PSTATE_DISABLE, error messages to traces; no error logs, Pstates are disabled (as #V is bad), IPL continues. else act as OFF OFF - no checking performed; IPL continues. Pstates are follow ATTR_SYSTEM_PSTATE_DISABLE (user beware if not Disabled). Producer: Override Consumers: p10_pstate_parameter_build</description>
    <enumerator>
      <name>FAIL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>INFO</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>WARN</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>OFF</name>
      <value>3</value>
    </enumerator>
    <id>SYSTEM_PDV_VALIDATION_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Defines the mode of #W checking in relationship to system reaction FAIL - if not ATTR_SYSTEM_WOF_DISABLE or not ATTR_SYSTEM_DDS_DISABLE, fails the IPL (product default); else act as OFF. INFO - if not ATTR_SYSTEM_WOF_DISABLE or not ATTR_SYSTEM_DDS_DISABLE, error messages to traces; Info error log; WOF AND DDS are disabled; IPL continues. else if act as OFF WARN - if not ATTR_SYSTEM_WOF_DISABLE or not ATTR_SYSTEM_DDS_DISABLE, error messages to traces; no error logs, WOF and DDS are disabled, IPL continues. else if act as OFF OFF - no checking performed; IPL continues. WOF and DDS follow ATTR_SYSTEM_WOF_DISABLE and ATTR_SYSTEM_DDS_DISABLE (user beware if not Disabled).</description>
    <enumerator>
      <name>FAIL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>INFO</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>WARN</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>OFF</name>
      <value>3</value>
    </enumerator>
    <id>SYSTEM_PDW_VALIDATION_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Defines the mode of IQ checking in relationship to system reaction FAIL - if not ATTR_SYSTEM_WOF_DISABLE or not ATTR_SYSTEM_DDS_DISABLE, fails the IPL (product default); else act as OFF. INFO - if not ATTR_SYSTEM_WOF_DISABLE or not ATTR_SYSTEM_DDS_DISABLE, error messages to traces; Info error log; WOF AND DDS are disabled; IPL continues. else if act as OFF WARN - if not ATTR_SYSTEM_WOF_DISABLE or not ATTR_SYSTEM_DDS_DISABLE, error messages to traces; no error logs, WOF and DDS are disabled, IPL continues. else if act as OFF OFF - no checking performed; IPL continues. WOF and DDS follow ATTR_SYSTEM_WOF_DISABLE and ATTR_SYSTEM_DDS_DISABLE (user beware if not Disabled).</description>
    <enumerator>
      <name>FAIL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>INFO</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>WARN</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>OFF</name>
      <value>3</value>
    </enumerator>
    <id>SYSTEM_IQ_VALIDATION_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Defines which of the PSS chip selects (0 or 1) that the APSS is connected Producer: Machine Readable Workbook Consumer: p10_pm_pss_init</description>
    <enumerator>
      <name>NONE</name>
      <value>0xFF</value>
    </enumerator>
    <enumerator>
      <name>CS0</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>CS1</name>
      <value>0x01</value>
    </enumerator>
    <id>SPIPSS_SELECT</id>
  </enumerationType>
  <enumerationType>
    <description>Enables the platform mode where the most recent PMCR update will be the controlling value for Pstate changes. If disabled, the legacy "fastest one wins" algorithm is used. Producer: p10_build_pstate_datablock Consumers: p10_hcode_image_build -&gt; PGPE Header QME attribute</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>PMCR_MOST_RECENT_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Set to indicate clock-start/instruction execution in cache-contained or chip-contained mode will be managed by runn Provided by: platform (FW platforms init to OFF)</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>RUNN_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>OMI inband BAR enable. Set by platform.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>OMI_INBAND_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>True or false whether row repair is supported MRW attribute</description>
    <enumerator>
      <name>SUPPORTED</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>UNSUPPORTED</name>
      <value>0</value>
    </enumerator>
    <id>ROW_REPAIR_SUPPORTED_MRW</id>
  </enumerationType>
  <enumerationType>
    <description>Determines the stride covered by each granule in an interleaving group. The default stride -- 128B -- is the only value intended for production FW use. All other combinations are for experimental performance evaluation. Regardless of this attribute value, groups of size 1, 3, and 6 will be forced to 128B stride based on the logic capabilities.</description>
    <enumerator>
      <name>128_B</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>256_B</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>512_B</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>1_KB</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>2_KB</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>4_KB</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>8_KB</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>16_KB</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>32_KB</name>
      <value>0x08</value>
    </enumerator>
    <id>MSS_INTERLEAVE_GRANULARITY</id>
  </enumerationType>
  <enumerationType>
    <description>REQUIRED: HW mirroring is enabled, and all channels are required to be part of a mirrored group. REQUESTED: HW mirroring is enabled. Mirroring will be configured for groups which support it, but not all channels are required to be mirrored. OFF: HW mirroring is disabled. Provided by the MRW.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>REQUIRED</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>REQUESTED</name>
      <value>0x2</value>
    </enumerator>
    <id>MRW_HW_MIRRORING_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Processor fabric SL domain (proxime) configuration.</description>
    <enumerator>
      <name>HEMISPHERE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>CHIP</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_FABRIC_SL_DOMAIN</id>
  </enumerationType>
  <enumerationType>
    <description>Processor fabric broadcast scope configuration. Provided by the MRW.</description>
    <enumerator>
      <name>1HOP_CHIP_IS_GROUP</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>1HOP_CHIP_IS_NODE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>RESERVED</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>2HOP_CHIP_IS_NODE</name>
      <value>0x03</value>
    </enumerator>
    <id>PROC_FABRIC_BROADCAST_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Processor fabric topology mode, determines format of the topology ID. MODE0 = GGG_C (max 8x2) MODE1 = GG_CC (max 4x4) Provided by the MRW.</description>
    <enumerator>
      <name>MODE0</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>MODE1</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_FABRIC_TOPOLOGY_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Per-link optics configuration OPT0 = SMPA/SMPX/OCAPI/NV OPT1 = SMPA/SMPX OPT2 = SMPA/SMPX OPT3 = SMPA/SMPX/OCAPI/NV OPT4 = SMPA/SMPX/OCAPI/NV OPT5 = SMPA/SMPX/OCAPI/NV OPT6 = SMPA/SMPX/OCAPI/NV OPT7 = SMPA/SMPX/OCAPI/NV Provided by the MRW.</description>
    <enumerator>
      <name>SMPX</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>SMPA</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NV</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>OCAPI</name>
      <value>0x3</value>
    </enumerator>
    <id>IOHS_CONFIG_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Processor optics bus width per link. Provided by the MRW.</description>
    <enumerator>
      <name>1_BYTE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>2_BYTE</name>
      <value>0x02</value>
    </enumerator>
    <id>PROC_FABRIC_IOHS_BUS_WIDTH</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates if the link is used to connect between drawers. Should be considered valid only if ATTR_IOHS_CONFIG_MODE for the given link is configured as an SMPX or SMPA. Provided by the MRW.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IOHS_DRAWER_INTERCONNECT</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates the bitrate for the link.</description>
    <enumerator>
      <name>25G</name>
      <value>25</value>
    </enumerator>
    <enumerator>
      <name>32G</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>50G</name>
      <value>50</value>
    </enumerator>
    <id>LINK_SPEED</id>
  </enumerationType>
  <enumerationType>
    <description>The frequency of the OMI channel.</description>
    <enumerator>
      <name>19200</name>
      <value>19200</value>
    </enumerator>
    <enumerator>
      <name>21330</name>
      <value>21330</value>
    </enumerator>
    <enumerator>
      <name>23460</name>
      <value>23460</value>
    </enumerator>
    <enumerator>
      <name>25600</name>
      <value>25600</value>
    </enumerator>
    <id>FREQ_OMI_MHZ</id>
  </enumerationType>
  <enumerationType>
    <description>This attribute controls the latches required to configure the PEC as a x16, x8x8, or x8x4x4 based on what PHBs are active defined from the MRW. creator: platform consumer: p10_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. Attribute Name Definition Example Comments Targeted Register Latches ATTR_PROC_PCIE_PHB_ACTIVE (Stack0, Stack1, Stack2) (1, 0, 0) PHB0 enabled TC_PCI_LANE_CFG_DC_0H, TC_PCI_LANE_CFG_DC_1H PHB1 disabled PHB2 disabled Register Latch Definition: PCI0 / PCI1 Register Address Register Name Bit Signal Name Bit Description 8000009 / 9000009 TPPCI.PCI.CPLT_CONF1 0 TC_PCI_LANE_CFG_DC_0H MSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 1 TC_PCI_LANE_CFG_DC_1H LSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 2 TC_PCI_SWAP_DC_2H LANE SWAP control for Stack0 3 TC_PCI_SWAP_DC_3H LANE SWAP control for Stack0 4 TC_PCI_SWAP_DC_4H LANE SWAP control for Stack0 8 TC_PCI_IOVALID_DC_8H IOVALID control for Stack0 9 TC_PCI_IOVALID_DC_9H IOVALID control for Stack1 10 TC_PCI_IOVALID_DC_10H IOVALID control for Stack2</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_PCIE_PHB_ACTIVE</id>
  </enumerationType>
  <enumerationType>
    <description>This attribute controls the latches required to configure the PHBs to swap its lanes if wiring to the connector/device is straight or reverse. creator: platform consumer: p10_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. Attribute Name Definition Example Comments Targeted HWP Attributes ATTR_PROC_PCIE_LANE_REVERSAL (Stack0, Stack1, Stack2) (1, 0, 0) Reverse lanes on PHB0. TC_PCI_LANE_CFG_DC_2H Do not reverse lanes on PHB1. TC_PCI_LANE_CFG_DC_3H Do not reverse lanes on PHB2. TC_PCI_LANE_CFG_DC_4H Register Address Register Name Bit Signal Name Bit Description 8000009 / 9000009 TPPCI.PCI.CPLT_CONF1 0 TC_PCI_LANE_CFG_DC_0H MSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 1 TC_PCI_LANE_CFG_DC_1H LSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 2 TC_PCI_SWAP_DC_2H LANE SWAP control for Stack0 3 TC_PCI_SWAP_DC_3H LANE SWAP control for Stack0 4 TC_PCI_SWAP_DC_4H LANE SWAP control for Stack0 8 TC_PCI_IOVALID_DC_8H IOVALID control for Stack0 9 TC_PCI_IOVALID_DC_9H IOVALID control for Stack1 10 TC_PCI_IOVALID_DC_10H IOVALID control for Stack2</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_PCIE_LANE_REVERSAL</id>
  </enumerationType>
  <enumerationType>
    <description>PCIE MMIO BAR enable creator: platform consumer: p10_pcie_config firmware notes: Array index: BAR number (0:2) index 0~1 for MMIO BAR0/1 index 2 for PHB register space</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_PCIE_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>PCIE MMIO BAR size values creator: platform consumer: p10_pcie_config firmware notes: Array index: BAR number (0:2) NOTE: supported MMIO BAR0/1 sizes are from 64KB-32PB NOTE: only supported PHB register size is 16KB</description>
    <enumerator>
      <name>32_PB</name>
      <value>0x8000000000000000</value>
    </enumerator>
    <enumerator>
      <name>16_PB</name>
      <value>0xC000000000000000</value>
    </enumerator>
    <enumerator>
      <name>8_PB</name>
      <value>0xE000000000000000</value>
    </enumerator>
    <enumerator>
      <name>4_PB</name>
      <value>0xF000000000000000</value>
    </enumerator>
    <enumerator>
      <name>2_PB</name>
      <value>0xF800000000000000</value>
    </enumerator>
    <enumerator>
      <name>1_PB</name>
      <value>0xFC00000000000000</value>
    </enumerator>
    <enumerator>
      <name>512_TB</name>
      <value>0xFE00000000000000</value>
    </enumerator>
    <enumerator>
      <name>256_TB</name>
      <value>0xFF00000000000000</value>
    </enumerator>
    <enumerator>
      <name>128_TB</name>
      <value>0xFF80000000000000</value>
    </enumerator>
    <enumerator>
      <name>64_TB</name>
      <value>0xFFC0000000000000</value>
    </enumerator>
    <enumerator>
      <name>32_TB</name>
      <value>0xFFE0000000000000</value>
    </enumerator>
    <enumerator>
      <name>16_TB</name>
      <value>0xFFF0000000000000</value>
    </enumerator>
    <enumerator>
      <name>8_TB</name>
      <value>0xFFF8000000000000</value>
    </enumerator>
    <enumerator>
      <name>4_TB</name>
      <value>0xFFFC000000000000</value>
    </enumerator>
    <enumerator>
      <name>2_TB</name>
      <value>0xFFFE000000000000</value>
    </enumerator>
    <enumerator>
      <name>1_TB</name>
      <value>0xFFFF000000000000</value>
    </enumerator>
    <enumerator>
      <name>512_GB</name>
      <value>0xFFFF800000000000</value>
    </enumerator>
    <enumerator>
      <name>256_GB</name>
      <value>0xFFFFC00000000000</value>
    </enumerator>
    <enumerator>
      <name>128_GB</name>
      <value>0xFFFFE00000000000</value>
    </enumerator>
    <enumerator>
      <name>64_GB</name>
      <value>0xFFFFF00000000000</value>
    </enumerator>
    <enumerator>
      <name>32_GB</name>
      <value>0xFFFFF80000000000</value>
    </enumerator>
    <enumerator>
      <name>16_GB</name>
      <value>0xFFFFFC0000000000</value>
    </enumerator>
    <enumerator>
      <name>8_GB</name>
      <value>0xFFFFFE0000000000</value>
    </enumerator>
    <enumerator>
      <name>4_GB</name>
      <value>0xFFFFFF0000000000</value>
    </enumerator>
    <enumerator>
      <name>2_GB</name>
      <value>0xFFFFFF8000000000</value>
    </enumerator>
    <enumerator>
      <name>1_GB</name>
      <value>0xFFFFFFC000000000</value>
    </enumerator>
    <enumerator>
      <name>512_MB</name>
      <value>0xFFFFFFE000000000</value>
    </enumerator>
    <enumerator>
      <name>256_MB</name>
      <value>0xFFFFFFF000000000</value>
    </enumerator>
    <enumerator>
      <name>128_MB</name>
      <value>0xFFFFFFF800000000</value>
    </enumerator>
    <enumerator>
      <name>64_MB</name>
      <value>0xFFFFFFFC00000000</value>
    </enumerator>
    <enumerator>
      <name>32_MB</name>
      <value>0xFFFFFFFE00000000</value>
    </enumerator>
    <enumerator>
      <name>16_MB</name>
      <value>0xFFFFFFFF00000000</value>
    </enumerator>
    <enumerator>
      <name>8_MB</name>
      <value>0xFFFFFFFF80000000</value>
    </enumerator>
    <enumerator>
      <name>4_MB</name>
      <value>0xFFFFFFFFC0000000</value>
    </enumerator>
    <enumerator>
      <name>2_MB</name>
      <value>0xFFFFFFFFE0000000</value>
    </enumerator>
    <enumerator>
      <name>1_MB</name>
      <value>0xFFFFFFFFF0000000</value>
    </enumerator>
    <enumerator>
      <name>512_KB</name>
      <value>0xFFFFFFFFF8000000</value>
    </enumerator>
    <enumerator>
      <name>256_KB</name>
      <value>0xFFFFFFFFFC000000</value>
    </enumerator>
    <enumerator>
      <name>128_KB</name>
      <value>0xFFFFFFFFFE000000</value>
    </enumerator>
    <enumerator>
      <name>64_KB</name>
      <value>0xFFFFFFFFFF000000</value>
    </enumerator>
    <enumerator>
      <name>16_KB</name>
      <value>0xFFFFFFFFFFFFFFFF</value>
    </enumerator>
    <id>PROC_PCIE_BAR_SIZE</id>
  </enumerationType>
  <enumerationType>
    <description>Defines system specific value of SYS0 refclock receiver termination</description>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>FIFTY_OHM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ONE_HUNDRED_OHM</name>
      <value>0</value>
    </enumerator>
    <id>SYS0_REFCLOCK_RCVR_TERM</id>
  </enumerationType>
  <enumerationType>
    <description>Defines system specific value of SYS1 refclock receiver termination</description>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>FIFTY_OHM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ONE_HUNDRED_OHM</name>
      <value>0</value>
    </enumerator>
    <id>SYS1_REFCLOCK_RCVR_TERM</id>
  </enumerationType>
  <enumerationType>
    <description>Defines system specific value of PCI0 refclock receiver termination</description>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>FIFTY_OHM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ONE_HUNDRED_OHM</name>
      <value>0</value>
    </enumerator>
    <id>PCI0_REFCLOCK_RCVR_TERM</id>
  </enumerationType>
  <enumerationType>
    <description>Defines system specific value of PCI1 refclock receiver termination</description>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>FIFTY_OHM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ONE_HUNDRED_OHM</name>
      <value>0</value>
    </enumerator>
    <id>PCI1_REFCLOCK_RCVR_TERM</id>
  </enumerationType>
  <enumerationType>
    <description>RCS PLL input for TOD Filter PLL</description>
    <enumerator>
      <name>SYS_REFCLOCK0</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>RCS_ASYNC_OUT</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>RCS_SYNC_OUT</name>
      <value>0x1</value>
    </enumerator>
    <id>CLOCK_MUX0A_RCS_PLL_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>RCS PLL input for Nest Filter PLL</description>
    <enumerator>
      <name>SYS_REFCLOCK0</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>RCS_ASYNC_OUT</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>RCS_SYNC_OUT</name>
      <value>0x1</value>
    </enumerator>
    <id>CLOCK_MUX0B_RCS_PLL_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>RCS PLL input for IO Filter PLL</description>
    <enumerator>
      <name>SYS_REFCLOCK0</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>RCS_ASYNC_OUT</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>RCS_SYNC_OUT</name>
      <value>0x1</value>
    </enumerator>
    <id>CLOCK_MUX0C_RCS_PLL_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>RCS PLL input for IO Spread Spectrum Filter PLL</description>
    <enumerator>
      <name>SYS_REFCLOCK0</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>RCS_ASYNC_OUT</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>RCS_SYNC_OUT</name>
      <value>0x1</value>
    </enumerator>
    <id>CLOCK_MUX0D_RCS_PLL_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>MUX 1 input</description>
    <enumerator>
      <name>MUX10</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TCK</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX1_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>MUX 2a input</description>
    <enumerator>
      <name>PAU_DPLL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MUX1</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX2A_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>MUX 2b input</description>
    <enumerator>
      <name>PAU_DPLL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MUX1</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX2B_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>MUX 3 input</description>
    <enumerator>
      <name>NEST_DPLL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MUX2B</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX3_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>PAU DPLL input from Filter PLLs</description>
    <enumerator>
      <name>PLLIOSSFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLIOFLT</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX10_PAU_DPLL_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>NEST DPLL input from Filter PLLs</description>
    <enumerator>
      <name>PLLIOSSFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLIOFLT</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX11_NEST_DPLL_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>OMI LCPLL input</description>
    <enumerator>
      <name>PLLTODFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLNESTFLT</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>PLLIOFLT</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX12_OMI_LCPLL_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>Mux 13 input</description>
    <enumerator>
      <name>PLLTODFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLNESTFLT</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>PLLIOFLT</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX13_OPT_133_SOURCE_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>Mux 14 input</description>
    <enumerator>
      <name>PLLNESTFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLIOFLT</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX14_OPT_156_SOURCE_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>IOHS LCPLL input IOHS0: Mux15 IOHS1: Mux16 (no Mux13 input) IOHS2: Mux17 (no Mux13 input) IOHS3: Mux18 IOHS4: Mux19 IOHS5: Mux20 IOHS6: Mux21 IOHS7: Mux22</description>
    <enumerator>
      <name>PLLTODFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MUX14</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>MUX13</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX_IOHS_LCPLL_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>Mux 23 input from FPLL</description>
    <enumerator>
      <name>PLLTODFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLIOSSFLT</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>MUX0D</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX23_PCI_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>PCI LCPLL input mux control PCI0: Mux24 PCI1: Mux25</description>
    <enumerator>
      <name>MUX23</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PCI_REFCLOCK0</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>PCI_REFCLOCK1</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX_PCI_LCPLL_INPUT</id>
  </enumerationType>
  <enumerationType>
    <description>setup clock mux settings for TOD Refclock input 0b0 = 32 MHz LPC reference clock 0b1 = 16 MHz I/O Filter PLL Output</description>
    <enumerator>
      <name>LPC_REFCLOCK</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLTODFLT</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_PLL_MUX_TOD</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates if current IPL is memory-preserving</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IS_MPIPL</id>
  </enumerationType>
  <enumerationType>
    <description>Holds the state of Security Access Bit (SAB)</description>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <id>SECURITY_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Consumed by p10_sbe_select_ex. Dictates policy for selection of active cores and backing caches CRONUS_MAX_ACTIVE -- request maximum set of active cores possible (use case for Cronus istep 4 to establish run state on all functional cores), no backing caches HB_DEFAULT -- request minset of active cores (2 in fused core mode, 1 otherwise) and backing caches (2) HB_MAX_FOOTPRINT -- request the maximum set of backing caches possible (maintaining a power of 2 size, and guaranteeing minset of active cores) HB_MAX_THREADS -- request the maximum set of active cores possible, logically applied after processing HB_MAX_FOOTPRINT directive if set For memory preserving IPLs, the attribute will be honored in the calcuation of active cores, but no backing caches will be requested For cache-contained IPL types, the selection policy is fixed in code -- request maximum set of active cores possible, no backing caches For chip-contained IPL types, the selection policy is fixed in code -- request based on contents of ATTR_CHIP_CONTAINED_ACTIVE_CORES_VEC, ATTR_CHIP_CONTAINED_BACKING_CACHES_VEC</description>
    <enumerator>
      <name>HB_DEFAULT</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CRONUS_MAX_ACTIVE</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>HB_MAX_FOOTPRINT</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>HB_MAX_THREADS</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>HB_MAX_FOOTPRINT_MAX_THREADS</name>
      <value>0x6</value>
    </enumerator>
    <id>SBE_SELECT_EX_POLICY</id>
  </enumerationType>
  <enumerationType>
    <description>Summarizes the fused status of cores. This is same for all p10 chips in the system. If a core is in a fused state, attribute should read 1 else zero. It needs to be populated during ipl but before istep 15.</description>
    <enumerator>
      <name>CORE_UNFUSED</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CORE_FUSED</name>
      <value>0x1</value>
    </enumerator>
    <id>FUSED_CORE_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates if SBE on this chip is serving as hostboot drawer master</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_SBE_MASTER_CHIP</id>
  </enumerationType>
  <enumerationType>
    <description>enable the pulse mode</description>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <id>PULSE_MODE_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>To skip the locking sequence and check for lock of CP TOD Filter PLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>CP_PLLTODFLT_BYPASS</id>
  </enumerationType>
  <enumerationType>
    <description>To skip the locking sequence and check for lock of CP Nest Filter PLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>CP_PLLNESTFLT_BYPASS</id>
  </enumerationType>
  <enumerationType>
    <description>To skip the locking sequence and check for lock of CP IO Filter PLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>CP_PLLIOFLT_BYPASS</id>
  </enumerationType>
  <enumerationType>
    <description>To skip the locking sequence and check for lock of CP IO Spread Spectrum Filter PLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>CP_PLLIOSSFLT_BYPASS</id>
  </enumerationType>
  <enumerationType>
    <description>Skip locking sequence and check for lock of PAU DPLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>PAU_DPLL_BYPASS</id>
  </enumerationType>
  <enumerationType>
    <description>Skip locking sequence and check for lock of NEST DPLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>NEST_DPLL_BYPASS</id>
  </enumerationType>
  <enumerationType>
    <description>Skip locking sequence and check for lock of IO PLLs</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>IO_TANK_PLL_BYPASS</id>
  </enumerationType>
  <enumerationType>
    <description>Keep skew adjust logic between nest, cores and caches bypassed</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>SKEWADJ_BYPASS</id>
  </enumerationType>
  <enumerationType>
    <description>Keep core duty cycle adjust logic bypassed</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>DCADJ_BYPASS</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates if LPC console is enabled on system</description>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <id>LPC_CONSOLE_CNFG</id>
  </enumerationType>
  <enumerationType>
    <description>The frequency of the memory controller mesh clock, in MHz. This clock is asynchronous to the nest and drives the MCU queues, and all the associated logic that drives the inputs to the OMI. This can be set differently for each memory controller in the chip.</description>
    <enumerator>
      <name>1333</name>
      <value>1333</value>
    </enumerator>
    <enumerator>
      <name>1467</name>
      <value>1467</value>
    </enumerator>
    <enumerator>
      <name>1600</name>
      <value>1600</value>
    </enumerator>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <id>FREQ_MC_MHZ</id>
  </enumerationType>
  <enumerationType>
    <description>The frequency of a processor's IOHS mesh clocks, in MHz. This can be set differently on a by-link basis.</description>
    <enumerator>
      <name>1250</name>
      <value>1250</value>
    </enumerator>
    <enumerator>
      <name>1563</name>
      <value>1563</value>
    </enumerator>
    <enumerator>
      <name>1611</name>
      <value>1611</value>
    </enumerator>
    <enumerator>
      <name>1992</name>
      <value>1992</value>
    </enumerator>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <enumerator>
      <name>2067</name>
      <value>2067</value>
    </enumerator>
    <enumerator>
      <name>2070</name>
      <value>2070</value>
    </enumerator>
    <id>FREQ_IOHS_MHZ</id>
  </enumerationType>
  <enumerationType>
    <description>Specify the system policy to enforce synchronous mode between memory and nest. This drives the value of ATTR_MEM_IN_SYNCH_MODE. UNDETERMINED : Run synchronously if the dimm and nest freq matches ALWAYS : Require matching frequencies and deconfigure memory that does not match the nest NEVER : Do not run synchronously, even if the frequencies match</description>
    <enumerator>
      <name>UNDETERMINED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALWAYS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NEVER</name>
      <value>2</value>
    </enumerator>
    <id>REQUIRED_SYNCH_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Bit vector of dynamic init features which are applied when customizing the IPL image. Individual features are selected/deselected by setting/clearing the corresponding bit in this vector. Note: multiple features can be selected at once.</description>
    <enumerator>
      <name>CACHE_CONTAINED</name>
      <value>0x8000000000000000</value>
    </enumerator>
    <enumerator>
      <name>CHIP_CONTAINED</name>
      <value>0x4000000000000000</value>
    </enumerator>
    <enumerator>
      <name>COMMON_CONTAINED</name>
      <value>0x2000000000000000</value>
    </enumerator>
    <enumerator>
      <name>HOSTBOOT</name>
      <value>0x1000000000000000</value>
    </enumerator>
    <enumerator>
      <name>L2RC_HIGH_JITTER</name>
      <value>0x0800000000000000</value>
    </enumerator>
    <enumerator>
      <name>RUNN_SRESET_T0</name>
      <value>0x0400000000000000</value>
    </enumerator>
    <enumerator>
      <name>RUNN_SRESET_T1</name>
      <value>0x0200000000000000</value>
    </enumerator>
    <enumerator>
      <name>RUNN_SRESET_T2</name>
      <value>0x0100000000000000</value>
    </enumerator>
    <enumerator>
      <name>RUNN_SRESET_T3</name>
      <value>0x0080000000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_MC0_FAST</name>
      <value>0x0040000000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_MC1_FAST</name>
      <value>0x0020000000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_MC2_FAST</name>
      <value>0x0010000000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_MC3_FAST</name>
      <value>0x0008000000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2PA_NOMINAL</name>
      <value>0x0004000000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2PA_SAFE</name>
      <value>0x0002000000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_PA2RT_TURBO</name>
      <value>0x0001000000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_PA2RT_NOMINAL</name>
      <value>0x0000800000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_PA2RT_SAFE</name>
      <value>0x0000400000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC0_ULTRATURBO</name>
      <value>0x0000200000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC0_TURBO</name>
      <value>0x0000100000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC0_NOMINAL</name>
      <value>0x0000080000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC0_SAFE</name>
      <value>0x0000040000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC1_ULTRATURBO</name>
      <value>0x0000020000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC1_TURBO</name>
      <value>0x0000010000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC1_NOMINAL</name>
      <value>0x0000008000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC1_SAFE</name>
      <value>0x0000004000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC2_ULTRATURBO</name>
      <value>0x0000002000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC2_TURBO</name>
      <value>0x0000001000000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC2_NOMINAL</name>
      <value>0x0000000800000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC2_SAFE</name>
      <value>0x0000000400000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC3_ULTRATURBO</name>
      <value>0x0000000200000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC3_TURBO</name>
      <value>0x0000000100000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC3_NOMINAL</name>
      <value>0x0000000080000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_RT2MC3_SAFE</name>
      <value>0x0000000040000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT0_ULTRATURBO</name>
      <value>0x0000000020000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT0_TURBO</name>
      <value>0x0000000010000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT0_NOMINAL</name>
      <value>0x0000000008000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT0_SAFE</name>
      <value>0x0000000004000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT1_ULTRATURBO</name>
      <value>0x0000000002000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT1_TURBO</name>
      <value>0x0000000001000000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT1_NOMINAL</name>
      <value>0x0000000000800000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT1_SAFE</name>
      <value>0x0000000000400000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT2_ULTRATURBO</name>
      <value>0x0000000000200000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT2_TURBO</name>
      <value>0x0000000000100000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT2_NOMINAL</name>
      <value>0x0000000000080000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT2_SAFE</name>
      <value>0x0000000000040000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT3_ULTRATURBO</name>
      <value>0x0000000000020000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT3_TURBO</name>
      <value>0x0000000000010000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT3_NOMINAL</name>
      <value>0x0000000000008000</value>
    </enumerator>
    <enumerator>
      <name>FBC_ASYNC_MC2RT3_SAFE</name>
      <value>0x0000000000004000</value>
    </enumerator>
    <enumerator>
      <name>RUNN_USE_QME_TB_SRC</name>
      <value>0x0000000000002000</value>
    </enumerator>
    <enumerator>
      <name>HV_INITS</name>
      <value>0x0000000000001000</value>
    </enumerator>
    <enumerator>
      <name>MMA_STATIC_POWEROFF</name>
      <value>0x0000000000000800</value>
    </enumerator>
    <id>DYNAMIC_INIT_FEATURE_VEC</id>
  </enumerationType>
  <enumerationType>
    <description>Enable proc downstream transmit template 1. Should be enabled by default.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_ENABLE_DL_TMPL_1</id>
  </enumerationType>
  <enumerationType>
    <description>Enable proc downstream transmit template 4. Should be enabled by default.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_ENABLE_DL_TMPL_4</id>
  </enumerationType>
  <enumerationType>
    <description>Enable proc downstream transmit template 7. Should be disabled by default.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_ENABLE_DL_TMPL_7</id>
  </enumerationType>
  <enumerationType>
    <description>Enable proc downstream transmit template A. Should be disabled by default.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_ENABLE_DL_TMPL_A</id>
  </enumerationType>
  <enumerationType>
    <description>Controls the enabling and disabling of smf. Used by unit initfiles, p10_mss_eff_grouping.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>SMF_CONFIG</id>
  </enumerationType>
  <enumerationType>
    <description>Device type of I2C slave device</description>
    <enumerator>
      <name>ADS7138_ADC</name>
      <value />
    </enumerator>
    <enumerator>
      <name>PCA9554A_GPIO_EXPANDER</name>
      <value />
    </enumerator>
    <id>I2C_DEV_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>1 if the target is functional, else 0. Set by the platform.</description>
    <enumerator>
      <name>NON_FUNCTIONAL</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>FUNCTIONAL</name>
      <value>0x1</value>
    </enumerator>
    <id>FUNCTIONAL</id>
  </enumerationType>
  <enumerationType>
    <description>Which execution platform the HW Procedure is running on Some HWPs (e.g. special wakeup) use different registers for different platforms to avoid arbitration problems when multiple platforms do the same thing concurrently</description>
    <enumerator>
      <name>HOST</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>0x03</value>
    </enumerator>
    <id>EXECUTION_PLATFORM</id>
  </enumerationType>
  <enumerationType>
    <description>The manufacturing flags. These enums represent which bit/flag to set in numeric form, NOT binary form. These values/policies can no longer be bit wised together. These numeric values match the flags as found in the PDF document: 'Hypervisor Interface Data Specifications v10.5o-1.pdf', section 6.1.9 and should stay in sync with this document and updated when said document gets updated.</description>
    <enumerator>
      <name>MNFG_PHYP_VAPI</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MNFG_PHYP_FAPI</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>MNFG_PHYP_NO_THRESHOLD</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>MNFG_PHYP_TEST_RUN</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MNFG_PHYP_TERM</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>MNFG_PHYP_NO_RR</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>MNFG_PHYP_ANCHOR</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>MNFG_PHYP_IGNORE_SPCN_ERROR</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>MNFG_PHYP_NO_OS400_DUMP</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>MNFG_PHYP_RUN_COMPU_GARD</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>MNFG_PHYP_UNDEFINED_2</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>MNFG_PHYP_UNDEFINED_1</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MNFG_CORONA_FBIST</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>MNFG_VERIFY_DMA_DATA</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>MNFG_SVPD_USE_ONLY</name>
      <value>17</value>
    </enumerator>
    <enumerator>
      <name>MNFG_TERM_FSP_RR</name>
      <value>18</value>
    </enumerator>
    <enumerator>
      <name>MNFG_NO_RBOT</name>
      <value>19</value>
    </enumerator>
    <enumerator>
      <name>MNFG_NO_CAPTURE_VPD</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DO_NOT_PASS_TO_OS</name>
      <value>21</value>
    </enumerator>
    <enumerator>
      <name>MNFG_TEST_RBS</name>
      <value>22</value>
    </enumerator>
    <enumerator>
      <name>MNFG_NO_AP</name>
      <value>23</value>
    </enumerator>
    <enumerator>
      <name>MNFG_NO_SYS_DUMP</name>
      <value>24</value>
    </enumerator>
    <enumerator>
      <name>MNFG_TEST_ALL_SPARE_DRAM_ROWS</name>
      <value>25</value>
    </enumerator>
    <enumerator>
      <name>MNFG_SRC_TERM</name>
      <value>26</value>
    </enumerator>
    <enumerator>
      <name>MNFG_SPCN_USE_NVS_IP</name>
      <value>27</value>
    </enumerator>
    <enumerator>
      <name>MNFG_NO_RBS</name>
      <value>28</value>
    </enumerator>
    <enumerator>
      <name>MNFG_THRESHOLDS</name>
      <value>29</value>
    </enumerator>
    <enumerator>
      <name>MNFG_NO_GARD</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ABIST_VPD_DATA</name>
      <value>31</value>
    </enumerator>
    <enumerator>
      <name>MNFG_GORM_MODE</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>MNFG_FAST_RDT</name>
      <value>33</value>
    </enumerator>
    <enumerator>
      <name>MNFG_AVP_COMPLETE</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_MEM_FAST_IPL_SCRUB</name>
      <value>35</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_L3_FAST_IPL_SCRUB</name>
      <value>36</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_MEM_PATTERN</name>
      <value>37</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_L3_PATTERN</name>
      <value>38</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_WIRE_RDT</name>
      <value>39</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_WIRE_CST</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_ABIST</name>
      <value>41</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_LBIST</name>
      <value>42</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_CHKRING</name>
      <value>43</value>
    </enumerator>
    <enumerator>
      <name>MNFG_MSL_CHECK</name>
      <value>47</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_RWRAP</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENABLE_PRBS_CMDLINE</name>
      <value>49</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENABLE_DIMM_SCREEN</name>
      <value>50</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENABLE_TORRENT_PRBS</name>
      <value>51</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENABLE_TORRENT_ELCT</name>
      <value>52</value>
    </enumerator>
    <enumerator>
      <name>MNFG_MR_EXT_AB_WRAPTEST_TWO</name>
      <value>53</value>
    </enumerator>
    <enumerator>
      <name>MNFG_MORE_MEMORY_PATTERNS</name>
      <value>54</value>
    </enumerator>
    <enumerator>
      <name>MNFG_AVP_ENABLE</name>
      <value>55</value>
    </enumerator>
    <enumerator>
      <name>MNFG_FAST_BACKGROUND_SCRUB</name>
      <value>56</value>
    </enumerator>
    <enumerator>
      <name>MNFG_CLICK_TO_ACCEPT</name>
      <value>57</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_MEMORY_eREPAIR</name>
      <value>58</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_FABRIC_eREPAIR</name>
      <value>59</value>
    </enumerator>
    <enumerator>
      <name>MNFG_INFINIBAND_WRAP</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>MNFG_SMA_LINK</name>
      <value>61</value>
    </enumerator>
    <enumerator>
      <name>MNFG_SYS_DUMP_TERM</name>
      <value>62</value>
    </enumerator>
    <enumerator>
      <name>MNFG_PSI_DIAGNOSTIC</name>
      <value>63</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_30</name>
      <value>64</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_31</name>
      <value>65</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_32</name>
      <value>66</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_33</name>
      <value>67</value>
    </enumerator>
    <enumerator>
      <name>MNFG_CHKRING_ENABLE</name>
      <value>68</value>
    </enumerator>
    <enumerator>
      <name>MNFG_RUN_CUSTOMER_IPL</name>
      <value>69</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ABIST_VIASCREEN</name>
      <value>70</value>
    </enumerator>
    <enumerator>
      <name>MNFG_CLEAR_VPD_ARRAY_REPAIR_DATA</name>
      <value>71</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POWER_SAVE_CAPABLE</name>
      <value>72</value>
    </enumerator>
    <enumerator>
      <name>MNFG_PREVENT_REDUNDANCY_AUTO_ENABLE</name>
      <value>73</value>
    </enumerator>
    <enumerator>
      <name>MNFG_IB_FREQ_BIAS_HIGH</name>
      <value>74</value>
    </enumerator>
    <enumerator>
      <name>MNFG_IB_FREQ_BIAS_LOW</name>
      <value>75</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_34</name>
      <value>79</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_35</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_36</name>
      <value>81</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_37</name>
      <value>82</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_38</name>
      <value>83</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_39</name>
      <value>84</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENABLE_DMIGB</name>
      <value>85</value>
    </enumerator>
    <enumerator>
      <name>MNFG_FABRIC_DEPLOY_LANE_SPARES</name>
      <value>86</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DMI_DEPLOY_LANE_SPARES</name>
      <value>87</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENERGYSCALE_SPECIAL_POLICIES</name>
      <value>88</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_PHYBIST</name>
      <value>89</value>
    </enumerator>
    <enumerator>
      <name>MNFG_HDAT_AVP_COMPLETE</name>
      <value>90</value>
    </enumerator>
    <enumerator>
      <name>MNFG_HDAT_AVP_ENABLE</name>
      <value>91</value>
    </enumerator>
    <enumerator>
      <name>MNFG_IPL_MEMORY_CE_CHECKING</name>
      <value>92</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENABLE_MINIMUM_PATTERN_TEST</name>
      <value>93</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENABLE_STANDARD_PATTERN_TEST</name>
      <value>94</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENABLE_EXHAUSTIVE_PATTERN_TEST</name>
      <value>95</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_01</name>
      <value>96</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_02</name>
      <value>97</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_03</name>
      <value>98</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_04</name>
      <value>99</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_05</name>
      <value>100</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_06</name>
      <value>101</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_07</name>
      <value>102</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_08</name>
      <value>103</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_09</name>
      <value>104</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_10</name>
      <value>105</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_11</name>
      <value>106</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_12</name>
      <value>107</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_13</name>
      <value>111</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_14</name>
      <value>112</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_15</name>
      <value>113</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_16</name>
      <value>114</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_17</name>
      <value>115</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_18</name>
      <value>116</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_19</name>
      <value>117</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_20</name>
      <value>118</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_21</name>
      <value>119</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_22</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_23</name>
      <value>121</value>
    </enumerator>
    <enumerator>
      <name>MNFG_UPDATE_BOTH_SIDES_OF_SBE</name>
      <value>122</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_25</name>
      <value>123</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_26</name>
      <value>124</value>
    </enumerator>
    <enumerator>
      <name>MNFG_FSP_UPDATE_SBE_IMAGE</name>
      <value>125</value>
    </enumerator>
    <enumerator>
      <name>MNFG_SMP_WRAP_CONFIG</name>
      <value>126</value>
    </enumerator>
    <enumerator>
      <name>MNFG_POLICY_FLAG_AVAIL_29</name>
      <value>127</value>
    </enumerator>
    <id>MFG_FLAGS</id>
  </enumerationType>
  <enumerationType>
    <description>NOTE: This is being deprecated and being replaced by the attribute ATTR_MFG_FLAGS, found above. Please switch over to the new attribute, ATTR_MFG_FLAGS, ASAP. @TODO: RTC 252027: Remove this attribute when possible The manufacturing flags. This is a bitfield. Each bit is a flag and multiple flags can be set</description>
    <enumerator>
      <name>MNFG_NO_FLAG</name>
      <value>0x0000000000000000</value>
    </enumerator>
    <enumerator>
      <name>MNFG_THRESHOLDS</name>
      <value>0x0000000000000001</value>
    </enumerator>
    <enumerator>
      <name>MNFG_TEST_ALL_SPARE_DRAM_ROWS</name>
      <value>0x0000000000000040</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_DRAM_REPAIRS</name>
      <value>0x0000000000000080</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENABLE_STANDARD_PATTERN_TEST</name>
      <value>0x0000000000000200</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_FABRIC_eREPAIR</name>
      <value>0x0000000000000800</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_MEMORY_eREPAIR</name>
      <value>0x0000000000001000</value>
    </enumerator>
    <enumerator>
      <name>MNFG_FABRIC_DEPLOY_LANE_SPARES</name>
      <value>0x0000000000002000</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DMI_DEPLOY_LANE_SPARES</name>
      <value>0x0000000000004000</value>
    </enumerator>
    <id>MNFG_FLAGS</id>
  </enumerationType>
  <enumerationType>
    <description>Product name of a chip target. Provided by the MRW.</description>
    <enumerator>
      <name>NONE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>EXPLORER</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>GEMINI</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>P10</name>
      <value>0xA</value>
    </enumerator>
    <id>NAME</id>
  </enumerationType>
  <enumerationType>
    <description>EDPL (Error Detection Per Lane) is a feature in the DL that adds some additional checks to the traffic going across the OpenCAPI link in order to better track which lanes are having issues. Note: EDPL must be set the same on both sides of the link. This attribute affects both the proc/mc side and the OCMB side.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_OMI_EDPL_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>List of memory frequencies supported by the current system.</description>
    <enumerator>
      <name>MT1866</name>
      <value>1866</value>
    </enumerator>
    <enumerator>
      <name>MT2133</name>
      <value>2133</value>
    </enumerator>
    <enumerator>
      <name>MT2400</name>
      <value>2400</value>
    </enumerator>
    <enumerator>
      <name>MT2666</name>
      <value>2666</value>
    </enumerator>
    <enumerator>
      <name>MT2933</name>
      <value>2933</value>
    </enumerator>
    <enumerator>
      <name>MT3200</name>
      <value>3200</value>
    </enumerator>
    <id>MSS_MRW_SUPPORTED_FREQ</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates if the DIMM connected to this controller are in a planar configuration</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x01</value>
    </enumerator>
    <id>MEM_MRW_IS_PLANAR</id>
  </enumerationType>
  <enumerationType>
    <description>Machine Readable Workbook Refresh Rate Desired refresh interval used in refresh register 0, MBAREF0Q_CFG_REFRESH_INTERVAL 7.8 us (SINGLE) 3.9 us (DOUBLE) 7.02 us (SINGLE_10_PERCENT_FASTER) 3.51 us (DOUBLE_10_PERCENT_FASTER)</description>
    <enumerator>
      <name>DOUBLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SINGLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SINGLE_10_PERCENT_FASTER</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>DOUBLE_10_PERCENT_FASTER</name>
      <value>3</value>
    </enumerator>
    <id>MSS_MRW_REFRESH_RATE_REQUEST</id>
  </enumerationType>
  <enumerationType>
    <description>Machine Readable Workbook enablement of the HWP code to adjust the VMEM regulator power limit based on number of installed DIMMs.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to AVDD. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_AVDD_OFFSET_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to VDD. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VDD_OFFSET_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VCS_OFFSET_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VPP_OFFSET_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to VDDR. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VDDR_OFFSET_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Fine refresh mode. Sets DDR4 MRS3. ZZ uses normal mode. From JEDEC DDR4 Spec 1716.78C from 07-2016 Page 47 Table 4.9.1</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FIXED_2X</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FIXED_4X</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FLY_2X</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>FLY_4X</name>
      <value>6</value>
    </enumerator>
    <id>MSS_MRW_FINE_REFRESH_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Temperature refresh range. Sets DDR4 MRS4. Should be defaulted to extended range. NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less degrees C Used for calculating periodic refresh intervals JEDEC DDR4 spec 1716.78C from 07-2016 page 46 4.8.1</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>EXTEND</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_TEMP_REFRESH_RANGE</id>
  </enumerationType>
  <enumerationType>
    <description>For resetting the phy delay values at the beginning of calling mss_draminit_training. YES means the vaules will be reset.</description>
    <enumerator>
      <name>YES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NO</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
  </enumerationType>
  <enumerationType>
    <description>Allows user to manually turn on and off 2N Mode. AUTO indicates to use Signal Integrity generated setting (from VPD).</description>
    <enumerator>
      <name>AUTO</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCE_TO_1N_MODE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCE_TO_2N_MODE</name>
      <value>2</value>
    </enumerator>
    <id>MSS_MRW_DRAM_2N_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables DRAM Write CRC</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_DRAM_WRITE_CRC</id>
  </enumerationType>
  <enumerationType>
    <description>An override switch to shut off broadcast mode Enum values: YES: broadcast mode is forced off NO: broadcast mode uses the default value</description>
    <enumerator>
      <name>NO</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>YES</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_FORCE_BCMODE_OFF</id>
  </enumerationType>
  <enumerationType>
    <description>A bitmap containing the plug rules for NVDIMM. 1 if a DIMM supports an NVDIMM being plugged in, 0 if it does not DIMM slot 0 is the left most bit The index to the bitmap is the position of the DIMM target As such, a bitmap of 0b10010000, would allow NVDIMM plugged into DIMM0 and DIMM3 Note: this attribute is a 64 bit number to account for 16 DIMM per processor if there is ever a 4 processor system</description>
    <enumerator>
      <name>NO_NVDIMM</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NVDIMM_CAPABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_NVDIMM_PLUG_RULES</id>
  </enumerationType>
  <enumerationType>
    <description>Switch that allows unsupported raw card references by providing a default raw card setting.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_ALLOW_UNSUPPORTED_RCW</id>
  </enumerationType>
  <enumerationType>
    <description>Bitmap of DRAM widths supported by a system. A 1 indicates that the system supports a density. Enums below represent the the bit location in the attribute for a given DRAM width. Default value is 0xC -&gt; both x4/x8 supported</description>
    <enumerator>
      <name>X4</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>X8</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_SUPPORTED_DRAM_WIDTH</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates whether the OCMB is allowed to run in enterprise mode, commodity mode, or either. ALLOW_ENTERPRISE = Most permissive, uses whatever is installed in the way it is intended to be used. REQUIRE_ENTERPRISE = Throws an error for any commodity dimms that are installed. FORCE_NONENTERPRISE = Throws an error for any enterprise dimms that are installed.</description>
    <enumerator>
      <name>ALLOW_ENTERPRISE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>REQUIRE_ENTERPRISE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCE_NONENTERPRISE</name>
      <value>2</value>
    </enumerator>
    <id>MSS_OCMB_ENTERPRISE_POLICY</id>
  </enumerationType>
  <enumerationType>
    <description>The lane width of the OpenCapi channel</description>
    <enumerator>
      <name>LANE_8</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>LANE_4</name>
      <value>2</value>
    </enumerator>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>The frequency of the OpenCAPI</description>
    <enumerator>
      <name>SERDES_21_33GBPS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SERDES_23_46GBPS</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>SERDES_25_60GBPS</name>
      <value>3</value>
    </enumerator>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates whether to enable adaptation</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>The frequency of a processor's nest mesh clock, in MHz. This is the same for all chips in the system. Provided by the MRW.</description>
    <enumerator>
      <name>1600</name>
      <value>1600</value>
    </enumerator>
    <enumerator>
      <name>1866</name>
      <value>1866</value>
    </enumerator>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <enumerator>
      <name>2133</name>
      <value>2133</value>
    </enumerator>
    <enumerator>
      <name>2400</name>
      <value>2400</value>
    </enumerator>
    <id>FREQ_PB_MHZ</id>
  </enumerationType>
  <enumerationType>
    <description>Per-link optics configuration 0 = default = SMP 1 = CAPI 2.0 2 = NV 2.0 3 = OPENCAPI Provided by the MRW.</description>
    <enumerator>
      <name>SMP</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CAPI</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NV</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>OCAPI</name>
      <value>0x3</value>
    </enumerator>
    <id>OPTICS_CONFIG_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>The frequency of the memory controller channel. In synchronous mode, this is equivalent to ATTR_FREQ_PB_MHZ. This may be independently set per pair of memory channels if operating in asynchronous mode, but this configuration is not anticipated. This clock drives the MCU queues, and all the associated logic that drives the inputs to the DMI and reads its outputs.</description>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <enumerator>
      <name>2400</name>
      <value>2400</value>
    </enumerator>
    <id>FREQ_MCA_MHZ</id>
  </enumerationType>
  <enumerationType>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the L3 Trace array for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>CME_INSTRUCTION_TRACE_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables pstate parameter block code to use the static system vfrt data Consumer: p9_pstate_parameter_block.C -&gt; Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>VDN_STEP_OFF</name>
      <value>0x02</value>
    </enumerator>
    <id>SYS_VFRT_STATIC_DATA_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicate if manufacturing tests should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_X_MFG_CHK</id>
  </enumerationType>
  <enumerationType>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the CHTM for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>CME_CHTM_TRACE_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Disables the enablement of Voltage Droop Monitors (VDM) in the system. Producer: MRW Consumers: p9_pstate_parameter_block to clear flag for CME QuadManager Hcode reaction</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>SYSTEM_VDM_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Disables IVRM enablement in the system Producer: Override Consumers: p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE/OCC CME Quad Pstate Region (CQPR) for CM Quad Manager</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_IVRM_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>If wof_enabled, defines the Frequency Ratio calculation performed. (THIS IS NOT SUPPORTED IN P9 GA1!).</description>
    <enumerator>
      <name>FIXED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>STEPPED</name>
      <value>1</value>
    </enumerator>
    <id>WOF_ENABLE_FRATIO</id>
  </enumerationType>
  <enumerationType>
    <description>If wof_enabled, defines the Voltage Ratio calculation performed. THIS IS NOT SUPPORTED AT PRESENT. GA1 SUPPORT IS TBD).</description>
    <enumerator>
      <name>FIXED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CALCULATED</name>
      <value>1</value>
    </enumerator>
    <id>WOF_ENABLE_VRATIO</id>
  </enumerationType>
  <enumerationType>
    <description>If wof_enabled AND ATTR_WOF_ENABLE_VRATIO = CALCULATED, this attribute selects the Vratio calculation type. ACTIVE_CORES: Vratio is the number of active cores to the number of good cores FULL: Vratio is Vaverage to Vclip(Fclip) where Vclip(Fclip) is the normal interpolated regulator voltage (including load line uplife @ RDP current) derated with presently measured Idd current (from the AVSBus) and the loadline.</description>
    <enumerator>
      <name>ACTIVE_CORES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FULL</name>
      <value>1</value>
    </enumerator>
    <id>WOF_VRATIO_SELECT</id>
  </enumerationType>
  <enumerationType>
    <description>Indicate if manufcaturing tests should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_O_MFG_CHK</id>
  </enumerationType>
  <enumerationType>
    <description>Alternate settings for short Xbus channels bit 0 -- Disable RX LTE bit 1 -- Disable AC BOOST bit 2 -- Low Gain/Peaking Init Settings bit 3 -- Lower VGA Gain Target -10%</description>
    <enumerator>
      <name>DIS_RX_LTE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>DIS_TX_AC_BOOST</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>LOWER_GAIN_PEAK_INITS</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>LOWER_VGA_GAIN_TARGET</name>
      <value>0x08</value>
    </enumerator>
    <id>IO_XBUS_CHAN_EQ</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates if the Obus channel is a board or a cable</description>
    <enumerator>
      <name>BOARD</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_O_CHANNEL_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration of CDM_POLICIES flags</description>
    <enumerator>
      <description>MFG_Guard policy: Used in MFG only to prevent and disable the following: . Storing or creation of new Guard records from Diagno`stic or other faults through error logs. This is all domains, CEC processor/memory, VPD, FSP, etc. . Storing or creation of Manual Guard record from user. NOTE: this does not stop FCO. . Using an already stored System or Manual Guard record from deconfiguring resources. This is all domains, CEC processor/memory, VPD, FSP, etc.</description>
      <name>MANUFACTURING_DISABLED</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <description>Predictive_Guard policy: Used in Field or development to prevent and disable the following: . Storing or creation of new Guard records from diagnostics or other faults through error logs with the error_type of Predictive. . Using an already stored System Guard record with error_type of Predictive from deconfiguring resources.</description>
      <name>PREDICTIVE_DISABLED</name>
      <value>0x02</value>
    </enumerator>
    <id>CDM_POLICIES</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's class</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CARD</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENC</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>CHIP</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>UNIT</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>DEV</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>LOGICAL_CARD</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>BATTERY</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>LED</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>ASIC</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MAX</name>
      <value>12</value>
    </enumerator>
    <id>CLASS</id>
  </enumerationType>
  <enumerationType>
    <default>RAW</default>
    <description>Enumeration indicating a target's eeprom content type. RAW - eeprom has no specified layout ISDIMM - uses standard JEDEC layout for DDR memory IBM_FRUVPD - uses ipz converged vpd layout with records/keywords for generic FRUs IBM_MVPD - use ipz converged vpd layout with records/keywords for processor modules DDIMM - uses Differential DIMM layout SBE_BOOT_CODE - SBE code SBE_MEASUREMENT_CODE - Measurement code WOF_DATA - WOF data KEYSTORE - Keystore data</description>
    <enumerator>
      <name>RAW</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ISDIMM</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>IBM_FRUVPD</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>IBM_MVPD</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>DDIMM</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SBE_BOOT_CODE</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SBE_MEASUREMENT_CODE</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>WOF_DATA</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>KEYSTORE</name>
      <value>8</value>
    </enumerator>
    <id>EEPROM_CONTENT_TYPE</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's engine type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_IIC</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_SCOM</name>
      <value>2</value>
    </enumerator>
    <id>ENGINE_TYPE</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration defining special FAPI_POS values</description>
    <enumerator>
      <name>NA</name>
      <value>0xFFFFFFFF</value>
    </enumerator>
    <id>FAPI_POS</id>
  </enumerationType>
  <enumerationType>
    <description>Pulled from the MRW, this describes the device purpose to the HDAT. This is for I2C devices only.</description>
    <enumerator>
      <name>CABLE_CARD_PRES</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_PGOOD</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_CONTROL</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>MODULE_VPD</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>DIMM_SPD</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>PROC_MODULE_VPD</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>SBE_SEEPROM</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>PLANAR_VPD</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_TOPOLOGY_VERIFICATION</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_MICRO_RESET</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>I2C_ASSOC_WITH_NVLINK_CABLE</name>
      <value>0xC</value>
    </enumerator>
    <enumerator>
      <name>WINDOW_OPEN</name>
      <value>0xD</value>
    </enumerator>
    <enumerator>
      <name>PHYSICAL_PRESENCE</name>
      <value>0xE</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0xF</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
  </enumerationType>
  <enumerationType>
    <description>Pulled from the MRW, this describes the device type to the HDAT. This is for I2C devices only.</description>
    <enumerator>
      <name>9551</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>955X</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c128</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>NUVOTON_TPM</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>UCX90XX</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9552</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9553</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>9554</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>9555</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>SMP_or_OpenCAPI_Cable</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c256</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>THERMAL_SENSOR</name>
      <value>0x0C</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c04</name>
      <value>0x0D</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c412</name>
      <value>0x0E</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c32</name>
      <value>0x0F</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c64</name>
      <value>0x10</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c16</name>
      <value>0x11</value>
    </enumerator>
    <enumerator>
      <name>NVDIA_GPU</name>
      <value>0x12</value>
    </enumerator>
    <enumerator>
      <name>NXP_LPC_Microcontroller_LPC11U35</name>
      <value>0x13</value>
    </enumerator>
    <enumerator>
      <name>9550</name>
      <value>0x14</value>
    </enumerator>
    <enumerator>
      <name>TCG_I2C_TPM</name>
      <value>0x15</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the services that are concerned with target changes (ie, via HCDB change). The values can be combined using a bitwise 'OR'.</description>
    <enumerator>
      <name>GARD</name>
      <value>0x00000001</value>
    </enumerator>
    <enumerator>
      <name>MEMDIAG</name>
      <value>0x00000002</value>
    </enumerator>
    <enumerator>
      <name>PSIDIAG</name>
      <value>0x00000004</value>
    </enumerator>
    <enumerator>
      <name>DIAG_MASK</name>
      <value>0x00000006</value>
    </enumerator>
    <enumerator>
      <name>HOSTSVC_HBEL</name>
      <value>0x00000008</value>
    </enumerator>
    <enumerator>
      <name>RESRC_RECOV</name>
      <value>0x00000010</value>
    </enumerator>
    <enumerator>
      <name>GARD_APPLIED</name>
      <value>0x00000020</value>
    </enumerator>
    <id>HWAS_CHANGED_BIT</id>
  </enumerationType>
  <enumerationType>
    <description>Enum indicating the different possible Key Clear Request values NOTE: See "Host FW key clear requests" in HDAT spec</description>
    <enumerator>
      <description>(Default) Key Clear not requested</description>
      <name>NONE</name>
      <value>0x0000</value>
    </enumerator>
    <enumerator>
      <description>"Clear All" : Clear/reset all sensitive data controlled by platform firmware from the system</description>
      <name>ALL</name>
      <value>0x8000</value>
    </enumerator>
    <enumerator>
      <description>"Clear OS Keys" : This indicates OPAL to clear the OS secureboot keys</description>
      <name>OS_KEYS</name>
      <value>0x4000</value>
    </enumerator>
    <enumerator>
      <description>"Clear PEF SSO" : This indicates to OPAL/PEF to clear the System Security Office certificate</description>
      <name>PEF_SSO</name>
      <value>0x2000</value>
    </enumerator>
    <enumerator>
      <description>"Clear PowerVM System Key" : This indicates to PowerVM to clear the system key to the default state</description>
      <name>POWERVM_SYSKEY</name>
      <value>0x1000</value>
    </enumerator>
    <enumerator>
      <description>Reserved bits</description>
      <name>RESERVED_1</name>
      <value>0x0E00</value>
    </enumerator>
    <enumerator>
      <description>MFG mode and imprint driver only : Clear all sensitive data and leave storage empty</description>
      <name>MFG</name>
      <value>0x0100</value>
    </enumerator>
    <enumerator>
      <description>Reserved bits</description>
      <name>RESERVED_2</name>
      <value>0x00FF</value>
    </enumerator>
    <id>KEY_CLEAR_REQUEST</id>
  </enumerationType>
  <enumerationType>
    <description>Enum for MFG_WRAP_TEST_ABUS_LINKS_SET</description>
    <enumerator>
      <name>SET_NONE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>SET_1</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>SET_2</name>
      <value>0x2</value>
    </enumerator>
    <id>MFG_WRAP_TEST_ABUS_LINKS_SET</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the mnfg flags that are set by the user. The values can be combined using a bitwise 'OR'. The values will need to be kept in sync with the FAPI enumerator values. Also the enumeration type is used by the ATTR_MNFG_FLAGS attribute. Should note that the MNFG_FLAG values are of type uint32_t</description>
    <enumerator>
      <name>THRESHOLDS</name>
      <value>0x00000001</value>
    </enumerator>
    <enumerator>
      <name>AVP_ENABLE</name>
      <value>0x00000002</value>
    </enumerator>
    <enumerator>
      <name>HDAT_AVP_ENABLE</name>
      <value>0x00000004</value>
    </enumerator>
    <enumerator>
      <name>SRC_TERM</name>
      <value>0x00000008</value>
    </enumerator>
    <enumerator>
      <name>IPL_MEMORY_CE_CHECKING</name>
      <value>0x00000010</value>
    </enumerator>
    <enumerator>
      <name>FAST_BACKGROUND_SCRUB</name>
      <value>0x00000020</value>
    </enumerator>
    <enumerator>
      <name>TEST_DRAM_REPAIRS</name>
      <value>0x00000040</value>
    </enumerator>
    <enumerator>
      <name>DISABLE_DRAM_REPAIRS</name>
      <value>0x00000080</value>
    </enumerator>
    <enumerator>
      <name>ENABLE_EXHAUSTIVE_PATTERN_TEST</name>
      <value>0x00000100</value>
    </enumerator>
    <enumerator>
      <name>ENABLE_STANDARD_PATTERN_TEST</name>
      <value>0x00000200</value>
    </enumerator>
    <enumerator>
      <name>ENABLE_MINIMUM_PATTERN_TEST</name>
      <value>0x00000400</value>
    </enumerator>
    <enumerator>
      <name>DISABLE_FABRIC_eREPAIR</name>
      <value>0x00000800</value>
    </enumerator>
    <enumerator>
      <name>DISABLE_MEMORY_eREPAIR</name>
      <value>0x00001000</value>
    </enumerator>
    <enumerator>
      <name>FABRIC_DEPLOY_LANE_SPARES</name>
      <value>0x00002000</value>
    </enumerator>
    <enumerator>
      <name>DMI_DEPLOY_LANE_SPARES</name>
      <value>0x00004000</value>
    </enumerator>
    <enumerator>
      <name>PSI_DIAGNOSTIC</name>
      <value>0x00008000</value>
    </enumerator>
    <enumerator>
      <name>BRAZOS_WRAP_CONFIG</name>
      <value>0x00010000</value>
    </enumerator>
    <enumerator>
      <name>FSP_UPDATE_SBE_IMAGE</name>
      <value>0x00020000</value>
    </enumerator>
    <enumerator>
      <name>UPDATE_BOTH_SIDES_OF_SBE</name>
      <value>0x00040000</value>
    </enumerator>
    <enumerator>
      <name>IMMEDIATE_HALT</name>
      <value>0x00080000</value>
    </enumerator>
    <id>MNFG_FLAG</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's model</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>RESERVED</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>VENICE</name>
    </enumerator>
    <enumerator>
      <name>MURANO</name>
    </enumerator>
    <enumerator>
      <name>NAPLES</name>
    </enumerator>
    <enumerator>
      <name>NIMBUS</name>
    </enumerator>
    <enumerator>
      <name>CUMULUS</name>
    </enumerator>
    <enumerator>
      <name>AXONE</name>
    </enumerator>
    <enumerator>
      <name>CENTAUR</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OCMB</name>
    </enumerator>
    <enumerator>
      <name>JEDEC</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>CDIMM</name>
    </enumerator>
    <enumerator>
      <name>POWER8</name>
      <value>112</value>
    </enumerator>
    <enumerator>
      <name>POWER9</name>
      <value>144</value>
    </enumerator>
    <enumerator>
      <name>POWER10</name>
      <value>145</value>
    </enumerator>
    <enumerator>
      <name>CECTPM</name>
    </enumerator>
    <enumerator>
      <name>BMC</name>
    </enumerator>
    <enumerator>
      <name>AST2500</name>
    </enumerator>
    <enumerator>
      <name>AST2600</name>
    </enumerator>
    <enumerator>
      <name>PCA9847</name>
    </enumerator>
    <enumerator>
      <name>UCD9090</name>
    </enumerator>
    <enumerator>
      <name>UCD90120A</name>
    </enumerator>
    <enumerator>
      <name>UCD90320</name>
    </enumerator>
    <id>MODEL</id>
  </enumerationType>
  <enumerationType>
    <default>NONE</default>
    <description>Memory power control settings for IDLE powersave mode Used by OCC when entering idle power-save mode</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR_CLK_STOP</name>
      <value>0x03</value>
    </enumerator>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
  </enumerationType>
  <enumerationType>
    <default>OFF</default>
    <description>Memory power control settings programmed during IPL Used by OCC when exiting idle power-save mode</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR_CLK_STOP</name>
      <value>0x03</value>
    </enumerator>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
  </enumerationType>
  <enumerationType>
    <description>Used in MR4 A3 Temperature refresh mode Should be defaulted to disable</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the multi scome buffer size. The values can be combined using a bitwise 'OR'. The values will need to be kept in sync with the FAPI enumerator values. Also the enumeration type is used by the ATTR_MULTI_SCOM_BUFFER_MAX_SIZE. Should note that the MULTI_SCOM_BUFFER_MAX_SIZE values are of type uint32_t</description>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1KB</name>
      <value>0x00000400</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_2KB</name>
      <value>0x00000800</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_4KB</name>
      <value>0x00001000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_8KB</name>
      <value>0x00002000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_16KB</name>
      <value>0x00004000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_32KB</name>
      <value>0x00008000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_64KB</name>
      <value>0x00010000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_128KB</name>
      <value>0x00020000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_256KB</name>
      <value>0x00040000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_512KB</name>
      <value>0x00080000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1MB</name>
      <value>0x00100000</value>
    </enumerator>
    <id>MULTI_SCOM_BUFFER_MAX_SIZE_BIT</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the BAR size used with ATTR_PROC_NPU_MMIO_BAR_SIZE</description>
    <enumerator>
      <name>2_MB</name>
      <value>0x0000000000200000</value>
    </enumerator>
    <enumerator>
      <name>1_MB</name>
      <value>0x0000000000100000</value>
    </enumerator>
    <enumerator>
      <name>512_KB</name>
      <value>0x0000000000080000</value>
    </enumerator>
    <enumerator>
      <name>256_KB</name>
      <value>0x0000000000040000</value>
    </enumerator>
    <enumerator>
      <name>128_KB</name>
      <value>0x0000000000020000</value>
    </enumerator>
    <enumerator>
      <name>64_KB</name>
      <value>0x0000000000010000</value>
    </enumerator>
    <id>NPU_MMIO_BAR_SIZE</id>
  </enumerationType>
  <enumerationType>
    <default>DEFAULT_ALL</default>
    <description>Enumeration for the various OCMB Firmware update behaviors</description>
    <enumerator>
      <name>CHECK_VERSIONS</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCE_UPDATE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>PREVENT_UPDATE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>CHECK_BUT_NO_UPDATE</name>
      <value>3</value>
    </enumerator>
    <id>OCMB_FW_UPDATE_BEHAVIOR</id>
  </enumerationType>
  <enumerationType>
    <default>UNKNOWN</default>
    <description>Enumeration indicating what kind of payload is to be started</description>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PHYP</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SAPPHIRE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <id>PAYLOAD_KIND</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the OFF setting for the core and cache chiplet VCS PFET controllers</description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VCS_VOFF_SEL</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the OFF setting for the core and cache chiplet DD PFET controllers</description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VDD_VOFF_SEL</id>
  </enumerationType>
  <enumerationType>
    <default>ALLOW_COMPATIBILITY</default>
    <description>Enumeration specifying the compatibility setting for Processor ECs ALLOW_COMPATIBILITY = set RISK_LEVEL to best allowed FORCED_COMPATIBILITY = set RISK_LEVEL to a compatible level FORCED_NATIVE = set RISK_LEVEL to ECs native setting</description>
    <enumerator>
      <name>ALLOW_COMPATIBILITY</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCED_COMPATIBILITY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCED_NATIVE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_COMPATIBILITY_REQ</id>
  </enumerationType>
  <enumerationType>
    <description>Processor epsilon table type. Used to calculate the processor nest epsilon register values. Provided by the MRW.</description>
    <enumerator>
      <name>EPS_TYPE_LE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>EPS_TYPE_MR</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>EPS_TYPE_HE</name>
      <value>0x03</value>
    </enumerator>
    <id>PROC_EPS_TABLE_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the PROC_FABRIC_A_BUS_WIDTH</description>
    <enumerator>
      <name>2_BYTE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_FABRIC_A_BUS_WIDTH</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the PROC_FABRIC_CAPI_MODE</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_CAPI_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Processor SMP Fabric broadcast scope configuration. CHIP_IS_NODE = MODE1 = default CHIP_IS_GROUP = MODE2 Provided by the MRW.</description>
    <enumerator>
      <name>CHIP_IS_NODE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>CHIP_IS_GROUP</name>
      <value>0x02</value>
    </enumerator>
    <id>PROC_FABRIC_PUMP_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the PROC_FABRIC_SMP_OPTICS_MODE</description>
    <enumerator>
      <name>OPTICS_IS_X_BUS</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>OPTICS_IS_A_BUS</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_SMP_OPTICS_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the PROC_FABRIC_X_BUS_WIDTH</description>
    <enumerator>
      <name>2_BYTE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_FABRIC_X_BUS_WIDTH</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration for processor module type that come from HDAT spec 0x50 = DCM 0x51 = SCM</description>
    <enumerator>
      <name>GODEL</name>
      <value>0x50</value>
    </enumerator>
    <enumerator>
      <name>BLAISE</name>
      <value>0x51</value>
    </enumerator>
    <id>PROC_MODULE_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating which _PBIEX_ASYNC_SEL should be use</description>
    <enumerator>
      <name>SEL0</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SEL1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SEL2</name>
      <value>2</value>
    </enumerator>
    <id>PROC_PBIEX_ASYNC_SEL</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating which chip should be used as the PROC_SELECT_BOOT_MASTER</description>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_BOOT_MASTER</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indication which Hot Plug Controllers are supported by the current system.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MAX5961</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PCA9551</name>
      <value>0x02</value>
    </enumerator>
    <id>SUPPORTED_HOT_PLUG</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>PROC</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>EX</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>L2</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>L3</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>L4</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>MCS</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MBA</name>
      <value>13</value>
    </enumerator>
    <enumerator>
      <name>XBUS</name>
      <value>14</value>
    </enumerator>
    <enumerator>
      <name>ABUS</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>PCI</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>DPSS</name>
      <value>17</value>
    </enumerator>
    <enumerator>
      <name>APSS</name>
      <value>18</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>19</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>21</value>
    </enumerator>
    <enumerator>
      <name>PNOR</name>
      <value>22</value>
    </enumerator>
    <enumerator>
      <name>OSC</name>
      <value>23</value>
    </enumerator>
    <enumerator>
      <name>TODCLK</name>
      <value>24</value>
    </enumerator>
    <enumerator>
      <name>CONTROL_NODE</name>
      <value>25</value>
    </enumerator>
    <enumerator>
      <name>OSCREFCLK</name>
      <value>26</value>
    </enumerator>
    <enumerator>
      <name>OSCPCICLK</name>
      <value>27</value>
    </enumerator>
    <enumerator>
      <name>REFCLKENDPT</name>
      <value>28</value>
    </enumerator>
    <enumerator>
      <name>PCICLKENDPT</name>
      <value>29</value>
    </enumerator>
    <enumerator>
      <name>NX</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>PORE</name>
      <value>31</value>
    </enumerator>
    <enumerator>
      <name>PCIESWITCH</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>CAPP</name>
      <value>33</value>
    </enumerator>
    <enumerator>
      <name>FSI</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>EQ</name>
      <value>35</value>
    </enumerator>
    <enumerator>
      <name>MCA</name>
      <value>36</value>
    </enumerator>
    <enumerator>
      <name>MCBIST</name>
      <value>37</value>
    </enumerator>
    <enumerator>
      <name>MI</name>
      <value>38</value>
    </enumerator>
    <enumerator>
      <name>DMI</name>
      <value>39</value>
    </enumerator>
    <enumerator>
      <name>OBUS</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>SBE</name>
      <value>42</value>
    </enumerator>
    <enumerator>
      <name>PPE</name>
      <value>43</value>
    </enumerator>
    <enumerator>
      <name>PERV</name>
      <value>44</value>
    </enumerator>
    <enumerator>
      <name>PEC</name>
      <value>45</value>
    </enumerator>
    <enumerator>
      <name>PHB</name>
      <value>46</value>
    </enumerator>
    <enumerator>
      <name>SYSREFCLKENDPT</name>
      <value>47</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLKENDPT</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>49</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>50</value>
    </enumerator>
    <enumerator>
      <name>UART</name>
      <value>51</value>
    </enumerator>
    <enumerator>
      <name>PS</name>
      <value>52</value>
    </enumerator>
    <enumerator>
      <name>FAN</name>
      <value>53</value>
    </enumerator>
    <enumerator>
      <name>VRM</name>
      <value>54</value>
    </enumerator>
    <enumerator>
      <name>USB</name>
      <value>55</value>
    </enumerator>
    <enumerator>
      <name>ETH</name>
      <value>56</value>
    </enumerator>
    <enumerator>
      <name>PANEL</name>
      <value>57</value>
    </enumerator>
    <enumerator>
      <name>BMC</name>
      <value>58</value>
    </enumerator>
    <enumerator>
      <name>FLASH</name>
      <value>59</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>TMP</name>
      <value>61</value>
    </enumerator>
    <enumerator>
      <name>GPIO_EXPANDER</name>
      <value>62</value>
    </enumerator>
    <enumerator>
      <name>POWER_SEQUENCER</name>
      <value>63</value>
    </enumerator>
    <enumerator>
      <name>RTC</name>
      <value>64</value>
    </enumerator>
    <enumerator>
      <name>FANCTLR</name>
      <value>65</value>
    </enumerator>
    <enumerator>
      <name>OBUS_BRICK</name>
      <value>66</value>
    </enumerator>
    <enumerator>
      <name>NPU</name>
      <value>67</value>
    </enumerator>
    <enumerator>
      <name>MC</name>
      <value>68</value>
    </enumerator>
    <enumerator>
      <name>TEST_FAIL</name>
      <value>69</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLK</name>
      <value>70</value>
    </enumerator>
    <enumerator>
      <name>SMPGROUP</name>
      <value>71</value>
    </enumerator>
    <enumerator>
      <name>OMI</name>
      <value>72</value>
    </enumerator>
    <enumerator>
      <name>MCC</name>
      <value>73</value>
    </enumerator>
    <enumerator>
      <name>OMIC</name>
      <value>74</value>
    </enumerator>
    <enumerator>
      <name>OCMB_CHIP</name>
      <value>75</value>
    </enumerator>
    <enumerator>
      <name>MEM_PORT</name>
      <value>76</value>
    </enumerator>
    <enumerator>
      <name>I2C_MUX</name>
      <value>77</value>
    </enumerator>
    <enumerator>
      <name>PMIC</name>
      <value>78</value>
    </enumerator>
    <enumerator>
      <name>NMMU</name>
      <value>79</value>
    </enumerator>
    <enumerator>
      <name>PAU</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>IOHS</name>
      <value>81</value>
    </enumerator>
    <enumerator>
      <name>PAUC</name>
      <value>82</value>
    </enumerator>
    <enumerator>
      <name>FC</name>
      <value>83</value>
    </enumerator>
    <enumerator>
      <name>LPCREFCLKENDPT</name>
      <value>84</value>
    </enumerator>
    <enumerator>
      <name>LAST_IN_RANGE</name>
      <value>85</value>
    </enumerator>
    <id>TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration for Voltage Drop Monitor enable</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>VDM_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration to select WOF Power Limit</description>
    <enumerator>
      <name>NOMINAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TURBO</name>
      <value>1</value>
    </enumerator>
    <id>WOF_POWER_LIMIT</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration defining the offsets into the IPMI_SENSORS array.</description>
    <enumerator>
      <name>NAME_OFFSET</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>NUMBER_OFFSET</name>
      <value>0x01</value>
    </enumerator>
    <id>IPMI_SENSOR_ARRAY</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration used in OR expression to indicate why to update SBE.</description>
    <enumerator>
      <description>Just clears the value</description>
      <name>CLEAR</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <description>See targetservicestart for details, if processor is swapped need to update SBE.</description>
      <name>BAR_MISMATCH</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <description>See call_mss_freq for details, if new and old frequency changes need to update SBE.</description>
      <name>MSS_FREQ_CHANGE</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <description>See call_mss_attr_update for details, if topology changes need to update SBE.</description>
      <name>TOPOLOGY_CHECKS</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <description>See call_mss_attr_update for details, if HRMOR outside configured range need to update SBE.</description>
      <name>HRMOR_OUTSIDE_CONFIGURED_MEM</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <description>See call_mss_attr_update for details, if fabric topology changes need to update SBE.</description>
      <name>FABRIC_EFF_TOPOLOGY</name>
      <value>0x10</value>
    </enumerator>
    <id>SBE_UPDATE_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the IPMI sensor name, which will be used by hostboot when determining the sensor number to return. The sensor name consists of one byte of sensor type plus one byte of sub-type, to differentiate similar sensors under the same target. Our implementaion uses the IPMI defined entity ID as the sub-type.</description>
    <enumerator>
      <name>PROC_TEMP</name>
      <value>0x0103</value>
    </enumerator>
    <enumerator>
      <name>DIMM_TEMP</name>
      <value>0x0120</value>
    </enumerator>
    <enumerator>
      <name>CORE_TEMP</name>
      <value>0x01D0</value>
    </enumerator>
    <enumerator>
      <name>STATE</name>
      <value>0x0500</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF_TEMP</name>
      <value>0x01D1</value>
    </enumerator>
    <enumerator>
      <name>GPU_TEMP</name>
      <value>0x01D8</value>
    </enumerator>
    <enumerator>
      <name>GPU_MEM_TEMP</name>
      <value>0x01D9</value>
    </enumerator>
    <enumerator>
      <name>VRM_VDD_TEMP</name>
      <value>0x01DA</value>
    </enumerator>
    <enumerator>
      <name>GPU_STATE</name>
      <value>0x17D8</value>
    </enumerator>
    <enumerator>
      <name>PROC_STATE</name>
      <value>0x0703</value>
    </enumerator>
    <enumerator>
      <name>CORE_STATE</name>
      <value>0x07D0</value>
    </enumerator>
    <enumerator>
      <name>HOST_AUTO_REBOOT_CONTROL</name>
      <value>0x0921</value>
    </enumerator>
    <enumerator>
      <name>DIMM_STATE</name>
      <value>0x0C20</value>
    </enumerator>
    <enumerator>
      <name>HB_VOLATILE</name>
      <value>0x0C21</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF_STATE</name>
      <value>0x0CD1</value>
    </enumerator>
    <enumerator>
      <name>FW_BOOT_PROGRESS</name>
      <value>0x0F22</value>
    </enumerator>
    <enumerator>
      <name>SYSTEM_EVENT</name>
      <value>0x1201</value>
    </enumerator>
    <enumerator>
      <name>OS_BOOT</name>
      <value>0x1F23</value>
    </enumerator>
    <enumerator>
      <name>HOST_STATUS</name>
      <value>0x2223</value>
    </enumerator>
    <enumerator>
      <name>OCC_ACTIVE</name>
      <value>0x07D2</value>
    </enumerator>
    <enumerator>
      <name>CORE_FREQ</name>
      <value>0xC1D0</value>
    </enumerator>
    <enumerator>
      <name>APSS_CHANNEL</name>
      <value>0xC2D7</value>
    </enumerator>
    <enumerator>
      <name>PCI_ACTIVE</name>
      <value>0xC423</value>
    </enumerator>
    <enumerator>
      <name>REBOOT_COUNT</name>
      <value>0xC322</value>
    </enumerator>
    <enumerator>
      <name>FAULT</name>
      <value>0xC700</value>
    </enumerator>
    <enumerator>
      <name>BACKPLANE_FAULT</name>
      <value>0xC707</value>
    </enumerator>
    <enumerator>
      <name>REF_CLOCK_FAULT</name>
      <value>0xC7D4</value>
    </enumerator>
    <enumerator>
      <name>PCI_CLOCK_FAULT</name>
      <value>0xC7D5</value>
    </enumerator>
    <enumerator>
      <name>TOD_CLOCK_FAULT</name>
      <value>0xC7D6</value>
    </enumerator>
    <enumerator>
      <name>APSS_FAULT</name>
      <value>0xC7D7</value>
    </enumerator>
    <enumerator>
      <name>VRM_VDD_FAULT</name>
      <value>0xC707</value>
    </enumerator>
    <enumerator>
      <name>DERATING_FACTOR</name>
      <value>0xC815</value>
    </enumerator>
    <enumerator>
      <name>REDUNDANT_PS_POLICY</name>
      <value>0xCA22</value>
    </enumerator>
    <enumerator>
      <name>TURBO_ALLOWED</name>
      <value>0xCB03</value>
    </enumerator>
    <enumerator>
      <name>TPM_REQUIRED</name>
      <value>0xCC03</value>
    </enumerator>
    <enumerator>
      <name>PCI_BIFURCATED</name>
      <value>0xCD03</value>
    </enumerator>
    <enumerator>
      <name>KEY_CLEAR_REQUEST</name>
      <value>0xCDD0</value>
    </enumerator>
    <id>SENSOR_NAME</id>
  </enumerationType>
  <enumerationType>
    <default>DD10</default>
    <description>Enumeration indicating the chip version</description>
    <enumerator>
      <name>DD10</name>
      <value>0x10</value>
    </enumerator>
    <enumerator>
      <name>DD11</name>
      <value>0x11</value>
    </enumerator>
    <enumerator>
      <name>DD20</name>
      <value>0x20</value>
    </enumerator>
    <enumerator>
      <name>DD21</name>
      <value>0x21</value>
    </enumerator>
    <id>CHIP_VER</id>
  </enumerationType>
  <enumerationType>
    <default>BMC_HW_VER</default>
    <description>Enumeration indicating the chip HW version</description>
    <enumerator>
      <name>FSP_HW_VER</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>BMC_HW_VER</name>
      <value>0x3</value>
    </enumerator>
    <id>HW_VER</id>
  </enumerationType>
  <enumerationType>
    <default>PRIMARY</default>
    <description>Enumeration indicating the master's FSI type</description>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>BACKUP</name>
      <value>0</value>
    </enumerator>
    <id>ROLE</id>
  </enumerationType>
  <enumerationType>
    <default>BMC_SW_VER</default>
    <description>Enumeration indicating the SW version</description>
    <enumerator>
      <name>FSP_SW_VER</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>BMC_SW_VER</name>
      <value>0x2</value>
    </enumerator>
    <id>SW_VER</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the IPMI entity ID, these values are defined in the IPMI specification. These values will be used in place of target type when events are sent to the BMC.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OTHER</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PROCESSOR</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>SYSTEM_BOARD</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>POWER_MGMT</name>
      <value>0x15</value>
    </enumerator>
    <enumerator>
      <name>CHASSIS</name>
      <value>0x17</value>
    </enumerator>
    <enumerator>
      <name>MEMORY_DEVICE</name>
      <value>0x20</value>
    </enumerator>
    <enumerator>
      <name>SYS_MGMT_SOFTWARE</name>
      <value>0x21</value>
    </enumerator>
    <enumerator>
      <name>BIOS</name>
      <value>0x22</value>
    </enumerator>
    <enumerator>
      <name>OS</name>
      <value>0x23</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>0xD0</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF</name>
      <value>0xD1</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>0xD2</value>
    </enumerator>
    <enumerator>
      <name>REF_CLOCK</name>
      <value>0xD4</value>
    </enumerator>
    <enumerator>
      <name>PCI_CLOCK</name>
      <value>0xD5</value>
    </enumerator>
    <enumerator>
      <name>TOD_CLOCK</name>
      <value>0xD6</value>
    </enumerator>
    <enumerator>
      <name>APSS</name>
      <value>0xD7</value>
    </enumerator>
    <enumerator>
      <name>GPU_CORE</name>
      <value>0xD8</value>
    </enumerator>
    <enumerator>
      <name>GPU_MEMORY</name>
      <value>0xD9</value>
    </enumerator>
    <id>ENTITY_ID</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration defining the offsets into the GPU_SENSORS array.</description>
    <enumerator>
      <name>FUNC_OFFSET</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>FUNC_ID_OFFSET</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>TEMP_OFFSET</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>TEMP_ID_OFFSET</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>MEM_TEMP_OFFSET</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>MEM_TEMP_ID_OFFSET</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>OBUS_CFG_OFFSET</name>
      <value>0x06</value>
    </enumerator>
    <id>GPU_SENSOR_ARRAY</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the IPMI sensor type, these values are defined in the IPMI specification. These values will be used when sending sensor reading events to the BMC.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TEMPERATURE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PROCESSOR</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>POWER_UNIT</name>
      <value>0x09</value>
    </enumerator>
    <enumerator>
      <name>MEMORY</name>
      <value>0x0c</value>
    </enumerator>
    <enumerator>
      <name>SYS_FW_PROGRESS</name>
      <value>0x0F</value>
    </enumerator>
    <enumerator>
      <name>SYS_EVENT</name>
      <value>0x12</value>
    </enumerator>
    <enumerator>
      <name>ADDIN_CARD</name>
      <value>0x17</value>
    </enumerator>
    <enumerator>
      <name>OS_BOOT</name>
      <value>0x1F</value>
    </enumerator>
    <enumerator>
      <name>APCI_POWER_STATE</name>
      <value>0x22</value>
    </enumerator>
    <enumerator>
      <name>FREQ</name>
      <value>0xC1</value>
    </enumerator>
    <enumerator>
      <name>POWER</name>
      <value>0xC2</value>
    </enumerator>
    <enumerator>
      <name>BOOT_COUNT</name>
      <value>0xC3</value>
    </enumerator>
    <enumerator>
      <name>PCI_LINK_PRES</name>
      <value>0xC4</value>
    </enumerator>
    <enumerator>
      <name>PWR_LIMIT_ACTIVE</name>
      <value>0xC4</value>
    </enumerator>
    <enumerator>
      <name>FAULT</name>
      <value>0xC7</value>
    </enumerator>
    <id>SENSOR_TYPE</id>
  </enumerationType>
</attributes>
