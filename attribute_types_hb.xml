<attributes>
  <attribute>
    <description>
          DRAM Device Type.
          Decodes SPD byte 2.
          Generation of memory: DDR3, DDR4.
          creator: mss_eff_config
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_GEN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_GEN</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Base Module Type.
          Decodes SPD Byte 3 (bits 3~0).
          Type of DIMM: RDIMM, UDIMM, LRDIMM as specified by the JEDEC standard.
          creator: mss_eff_config
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DIMM_TYPE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Hybrid Media.
          Decodes SPD Byte 3 (bits 6~4)
          creator: mss_eff_config
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_HYBRID_MEMORY_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_HYBRID_MEMORY_TYPE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Hybrid.
          Decodes SPD Byte 3 (bit 7)
          creator: mss_eff_config
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_HYBRID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_HYBRID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            DRAM Density.
            Decodes SPD Byte 4 (bits 3~0).
            Total SDRAM capacity per die.
            For multi-die stacks (DDP, QDP, or 3DS), this represents
            the capacity of each DRAM die in the stack.
            creator: mss_eff_config
            consumer: various
            firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_DENSITY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_DENSITY</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Number of DRAM bank address bits.
            Actual number of banks is 2^N, where
            N is the number of bank address bits.
            Decodes SPD Byte 4 (bits 5~4).
            creator: spd_decoder
            consumer: various
            firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_BANK_BITS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_BANK_BITS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Bank Groups Bits.
            Decoded SPD Byte 4 (bits 7~6).
            Actual number of bank groups is 2^N,
            where N is the number of bank address bits.
            This value represents the number of bank groups
            into which the memory array is divided.
            creator: mss_eff_config
            consumer: various
            firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_BANK_GROUP_BITS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_BANK_GROUP_BITS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Column Address Bits.
            Decoded SPD Byte 5 (bits 2~0).
            Actual number of DRAM columns is 2^N,
            where N is the number of column address bits
            creator: mss_eff_config
            consumer: various
            firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_COLUMN_BITS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_COLUMN_BITS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Row Address Bits.
            Decodes Byte 5 (bits 5~3).
            Number of DRAM column address bits.
            Actual number of DRAM rows is 2^N,
            where N is the number of row address bits
            creator: mss_eff_config
            consumer: various
            firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_ROW_BITS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_ROW_BITS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Primary SDRAM Package Type.
            Decodes Byte 6.
            This byte defines the primary set of SDRAMs.
            Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
            creator: mss_eff_config
            consumer: various
            firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_PRIM_STACK_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_PRIM_STACK_TYPE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
            creator: mss_eff_cnfg
            consumer: various
            firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_PPR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_PPR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Soft Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
            creator: mss_eff_cnfg
            consumer: various
            firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_SOFT_PPR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_SOFT_PPR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Minimum RAS to CAS Delay Time
          in nck (number of clock cyles).
          Decodes SPD byte 25 (7~0) and byte 112 (7~0).
          Each memory channel will have a value.
          creator: eff_config
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRCD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_TRCD</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          SDRAM Row Precharge Delay Time
          in nck (number of clock cycles).
          Decodes SPD byte 26 (bits 7~0) and byte 121 (bits 7~0).
          Each memory channel will have a value.
          creator: eff_config
          consumer: various
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_TRP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Minimum Active to Precharge Delay Time
          in nck (number of clock cycles).
          Decodes SPD byte 27 (bits 3~0) and byte 28 (7~0).
          Each memory channel will have a value.
          creator: mss_eff_cnfg_timing
          consumer: various
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRAS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_TRAS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Minimum Active to Active/Refresh Delay
          in nck (number of clock cyles).
          Decodes SPD byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120.
          Each memory channel will have a value.
          creator: eff_confg
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_TRC</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        DDR4 Spec defined as Refresh Cycle Time (tRFC).
        SPD Spec refers it to the Minimum Refresh Recovery Delay Time.
        In nck (number of clock cyles).
        Decodes SPD byte 31 (bits 15~8) and byte 30 (bits 7~0) for tRFC1.
        Decodes SPD byte 33 (bits 15~8) and byte 32 (bits 7~0) for tRFC2.
        Decodes SPD byte 35 (bits 15~8) and byte 34 (bits 7~0) for tRFC4.
        Selected tRFC value depends on MRW attribute that selects refresh mode.
        For 3DS, The tRFC time to the same logical rank is defined as tRFC_slr and is
        specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
        creator: eff_config
        consumer: various
        firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRFC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_TRFC</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Minimum Four Activate Window Delay Time
          in nck (number of clock cycles).
          Decodes SPD byte 36 (bits 3~0) and byte 37 (bits 7~0).
          For 3DS, tFAW time to the same logical rank is defined as
          tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices only) and
          specificed as the value as for a monolithic DDR4 SDRAM
          equivalent density.
          Each memory channel will have a value.
          creator: eff_cnfg
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TFAW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_TFAW</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Minimum Activate to Activate Delay Time, different bank group
          in nck (number of clock cycles).
          Decodes SPD byte 38 (bits 7~0).
          For 3DS, The tRRD_S time to a different bank group in the
          same logical rank is defined as tRRD_slr and is
          specificed as the value as for a monolithic
          DDR4 SDRAM of equivalent density.
          Each memory channel will have a value.
          creator: eff_confg
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRRD_S</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_TRRD_S</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Minimum Activate to Activate Delay Time, same bank group
          in nck (number of clock cycles).
          Decodes SPD byte 39 (bits 7~0).
          For 3DS, The tRRD_L time to the same bank group in the
          same logical rank is defined as tRRD_L_slr and is
          specificed as the value as for a monolithic
          DDR4 SDRAM of equivalent density.
          Each memory channel will have a value.
          creator: eff_confg
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRRD_L</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_TRRD_L</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Minimum CAS to CAS Delay Time, same bank group
          in nck (number of clock cycles).
          Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0).
          This is for DDR4 MRS6.
          Each memory channel will have a value.
          Creator: eff_config
          Consumer:various
          Firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TCCD_L</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_TCCD_L</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Minimum Write Recovery Time.
            Decodes SPD byte 41 (bits 3~0) and byte 42 (bits 7~0).
            Each memory channel will have a value.
            creator: mss_eff_cnfg_timing
            consumer: various
            firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TWR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_TWR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Minimum Write to Read Time, different bank group
          in nck (number of clock cycles).
          Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0).
          Each memory channel will have a value.
          creator: eff_config
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TWTR_S</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_TWTR_S</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Minimum Write to Read Time, same bank group
          in nck (number of clock cycles).
          Decodes byte 43 (7~4) and byte 45 (bits 7~0).
          Each memory channel will have a value.
          creator: eff_config
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TWTR_L</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_TWTR_L</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Maximum Activate Window
          in nck (number of clock cycles).
          Decodes SPD byte 7 (bits 5~4).
          Depends on tREFI multiplier.
          Each memory channel will have a value.
          creator: mss_eff_cnfg
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TMAW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_TMAW</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          SDRAM Device Width
          Decodes SPD Byte 12 (bits 2~0).
          Options: X4 (4 bits), X8 (8 bits), X16 (16 bits), X32 (32 bits).
          creator: mss_eff_cnfg
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_WIDTH</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          DRAM Device Rank Mix
          Decodes SPD Byte 12 (bits 5~3).
          creator: mss_eff_cnfg
          consumer: various
          firmware notes: none
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_RANK_MIX</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_RANK_MIX</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Total number of ranks in each DIMM.
        For monolithic and multi-load stack modules (SDP/DDP) this is the same as
        the number of package ranks per DIMM (SPD Byte 12 bits 5~3).

        For single load stack (3DS) modules this value represents the number
        of logical ranks per DIMM.
        Logical rank refers the individually addressable die in a 3DS stack
        and has no meaning for monolithic or multi-load stacked SDRAMs.
        creator: mss_eff_cnfg
        consumer: various
        firmware notes: none
      </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_NUM_RANKS_PER_DIMM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_NUM_RANKS_PER_DIMM</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Register Type
            Decodes SPD Byte 131
            creator: mss_eff_cnfg
            consumer: eff_dimm
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_REGISTER_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_REGISTER_TYPE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            DRAM Manufacturer ID Code
            Decodes SPD Byte 350 and 351
            creator: mss_eff_cnfg
            consumer: power_thermal::decoder
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_MFG_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DRAM_MFG_ID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Register Manufacturer ID Code
            Decodes SPD Byte 133 and 134
            creator: mss_eff_cnfg
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_RCD_MFG_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_RCD_MFG_ID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint16_t>
        <default>0x00</default>
      </uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Register Revision Number
            Decodes SPD Byte 135
            creator: mss_eff_cnfg
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_REGISTER_REV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_REGISTER_REV</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Package Rank Map
          Decodes SPD Byte 60 - 77 (Bits 7~6)
          creator: mss_eff_cnfg
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_PACKAGE_RANK_MAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_PACKAGE_RANK_MAP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2,18</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Nibble Map
          Decodes SPD Byte 60 - 77 (Bits 5~0)
          creator: mss_eff_cnfg
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_NIBBLE_MAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_NIBBLE_MAP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2,18</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          True or false whether row repair is supported
          MRW attribute
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_ROW_REPAIR_SUPPORTED_MRW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>ROW_REPAIR_SUPPORTED_MRW</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>UNSUPPORTED</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The frequency of the processor refclock in KHz.
    Provided by the Machine Readable Workbook.
    This can be overridden to adjust the refclock frequency.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CP_REFCLOCK_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_CP_REFCLOCK_KHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>100000</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The frequency of the IO refclock in KHz.
    Provided by the Machine Readable Workbook.
    This can be overridden to adjust the refclock frequency.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_IO_REFCLOCK_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_IO_REFCLOCK_KHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>100000</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The system-wide minimum frequency of the core mesh clock, in MHz.
    This is the lowest floor frequency across all chips in the system.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_SYSTEM_CORE_FLOOR_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Maximum frequency (in MHz) that this system can run the DIMMs at.
    There are 5 possible values determined by the dimm configuration.
    For configurations which have mixed rank configurations, the lowest
    frequency based on ranks of either DIMM is chosen. For example if
    there was a 1R and a 2R DIMM installed, and 1R dual drop was a lower
    max freq than 2R dual drop, then the 1R max freq would be the max allowed.
    [0]=One rank, single drop
    [1]=Two rank, single drop
    [2]=Four rank, single drop
    [3]=One rank, dual drop
    [4]=Two rank, dual drop
    A value of zero would indicate an unsupported configuration. Note: Do not
    use this attribute to limit configurations, it is not checked during plug rules.
    If you have an unsupported configuration, use the value 0 as the maximum freq.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MAX_ALLOWED_DIMM_FREQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MAX_ALLOWED_DIMM_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>5</array>
      <uint32_t>
        <default>2400,2400,2400,2400,2400</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The system-wide maximum frequency of the core mesh clock, in MHz.
    This is the highest ceiling frequency across all chips in the system.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_SYSTEM_CORE_CEILING_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_SYSTEM_CORE_CEILING_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Core boot frequency at 1:1 from Nest DPLL
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_BOOT_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_CORE_BOOT_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Core boot frequency multiplier
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_BOOT_MULT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_CORE_BOOT_MULT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The frequency of the memory controller mesh clock, in MHz.
    This clock is asynchronous to the nest and drives the MCU queues, and all the
    associated logic that drives the inputs to the OMI.
    This can be set differently for each memory controller in the chip.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_MC_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_MC_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The frequency of a processor's IOHS mesh clocks, in MHz.
    This can be set differently on a by-link basis.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_IOHS_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_IOHS_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The frequency of a processor's PAU mesh clocks, in MHz.
    Determines pau and ppe frequency for a given processor.
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PAU_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PAU_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PAU frequency multiplier</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PAU_MULT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PAU_MULT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The frequency of a processor's PCIe bus in MHz.
    This is the same for all PCIe buses in the system.
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PCIE_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PCIE_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Ref clock I2C bus divider consumed by code running out of OTPROM
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_I2C_BUS_DIV_REF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>I2C_BUS_DIV_REF</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0x0003</default>
      </uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Specify the system policy to enforce synchronous mode between memory and
    nest. This drives the value of ATTR_MEM_IN_SYNCH_MODE.
    UNDETERMINED : Run synchronously if the dimm and nest freq matches
    ALWAYS : Require matching frequencies and deconfigure memory that
    does not match the nest
    NEVER : Do not run synchronously, even if the frequencies match
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_REQUIRED_SYNCH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>REQUIRED_SYNCH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Holds data and mask to be programmed into Memory BAR/configuration registers.
    These values are calculated by p10_mss_eff_grouping HWP.

    Array arrangements: 4 MIs x 9 registers x 2 entries (data/mask)
      [0][0][0] = [MI0][MCFGP0][data] .... [MI0][9][1] = [MI0][MCMODE0][mask]
      [1][0][0] = [MI1][MCFGP0][data] .... [MI1][9][1] = [MI1][MCMODE0][mask]
      [2][0][0] = [MI2][MCFGP0][data] .... [MI2][9][1] = [MI2][MCMODE0][mask]
      [3][0][0] = [MI3][MCFGP0][data] .... [MI3][9][1] = [MI3][MCMODE0][mask]

    The BARs will be written by p10_sbe_exit_cache_contained HWP when
    called by Hostboot.

    The mask value specifies which bits of the data should be written to the
    underlying HW register.

    Set by p10_mss_eff_grouping.
    Consumers: HB (p10_exit_cache_contaiend)
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEMORY_BAR_REGS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEMORY_BAR_REGS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>4,9,2</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The address where each memory group starts in the non-mirrored
    memory groups stack. This address is determined by the memory
    grouping process based on the sizes of the memory groups formed
    in each processor.
    Set by p10_mss_eff_grouping.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_BASES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_MEM_BASES</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The memory size of each non-mirrored memory group in the
    non-mirrored memory groups stack. This size is determined by
    the memory grouping process based on the amount of memory
    behind the ports that are grouped together.
    Set by p10_mss_eff_grouping.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_SIZES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_MEM_SIZES</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The address where each memory group starts in the mirrored
    memory groups stack. This address is determined by
    the memory grouping process based on the sizes of the memory
    groups formed in each processor.
    Set by p10_mss_eff_grouping.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_MIRROR_BASES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_MIRROR_BASES</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The memory size of each memory group in the mirrored memory
    groups stack. This size is determined by the memory grouping
    process based on the amount of memory behind the ports that are
    grouped together.
    Set by p10_mss_eff_grouping.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_MIRROR_SIZES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_MIRROR_SIZES</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The actual non-mirrored base addresses of the groups formed
    by the memory grouping process. These values correspond to
    the BAR programming and would be acknowleged on the fabric.
    Set by p10_mss_eff_grouping.
    Used by p10_setup_bars.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_BASES_ACK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_MEM_BASES_ACK</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The actual non-mirrored memory sizes of the groups formed
    by the memory grouping process. These values correspond to
    the BAR programming.
    Set by p10_mss_eff_grouping.
    Used by p10_setup_bars.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_SIZES_ACK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_MEM_SIZES_ACK</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The actual mirrored base addresses of the groups formed
    by the memory grouping process. These values correspond to
    the BAR programming and would be acknowleged on the fabric.
    Set by p10_mss_eff_grouping.
    Used by p10_setup_bars.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_MIRROR_BASES_ACK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_MIRROR_BASES_ACK</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    creator: p10_mss_eff_grouping
    consumer: mss_setup_bars
    Data Structure from eff grouping to setup bars to help determine
    different groups. Measured in GB.
    Non-Mirroring array[0-7][0.20]:
            0-- Port size;
            1-- No of ports in group;
            2-- Total group size of non-mirroring;
            3-- Base address;
         4-11-- PortID number in group;
           12-- Alt Memory valid(0);
           13-- Alt Memory valid (1);
           14-- Alt Group size (0);
           15-- Alt Group size(1);
           16-- Alt Base address (0);
           17-- Alt Base address (1);
           18-- SMF Memory Valid
           19-- SMF Group Size (size[22:35] in lower bits)
           20-- SMF Base Address (addr[22:35] in lower bits)
    Mirroring array[8-15][0:20]:
           Same index description as above for mirror groups.
   </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MCC_GROUP_32</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MCC_GROUP_32</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>16,21</array>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The number of HTM queues to be reserved for each port in order
    to improve HTM trace performance.
    This number is calculated in memory grouping process when the
    HTM trace spaces are determined.
    Set by p10_mss_eff_grouping.
    Used by p10_htm_setup.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_HTM_QUEUES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>HTM_QUEUES</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The actual mirrored memory sizes of the groups formed
    by the memory grouping process. These values correspond to
    the BAR programming.
    Set by p10_mss_eff_grouping.
    Used by p10_setup_bars.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_MIRROR_SIZES_ACK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_MIRROR_SIZES_ACK</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    An 8 bit vector that would be a designation of which MC are involved
    in the group. Set by p10_mss_eff_grouping.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MEM_MC_IN_GROUP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MEM_MC_IN_GROUP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Define placement policy/scheme for non-mirrored/mirrored memory layout
    NORMAL = non-mirrored start: 0, mirrored start: 1024TB
    FLIPPED = mirrored start: 0, non-mirrored start: 512TB
    Set by platform.
    Used by p10_mss_eff_grouping.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_MIRROR_PLACEMENT_POLICY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_MIRROR_PLACEMENT_POLICY</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The physical capacity of each msel region is 16_TB.
    This attribute defines the maximum addressable space to be used within each msel,
    which may be lower than the physical capacity.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MAX_INTERLEAVE_GROUP_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MAX_INTERLEAVE_GROUP_SIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Used in the setting of groups. It is a bit vector.
    If the value BITWISE_AND 0x01 = 0x01 then groups of 1 are enabled,
    if the value BITWISE_AND 0x02 = 0x02, then groups of 2 are possible,
    if the value BITWISE_AND 0x04 = 0x04, then groups of 3 are possible,
    if the value BITWISE_AND 0x08 = 0x08, then groups of 4 are possible,
    if the value BITWISE_AND 0x20 = 0x20, then groups of 6 are possible,
    if the value BITWISE_AND 0x80 = 0x80, then groups of 8 are possible.
    If no groups can formed according to this input, then an error will
    be thrown.
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_INTERLEAVE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_INTERLEAVE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0xAF</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Determines the stride covered by each granule in an interleaving
    group. The default stride -- 128B -- is the only value intended for
    production FW use. All other combinations are for experimental
    performance evaluation.

    Regardless of this attribute value, groups of size 1, 3, and 6
    will be forced to 128B stride based on the logic capabilities.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_INTERLEAVE_GRANULARITY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_INTERLEAVE_GRANULARITY</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    A numerical number indicating if the memory procedures are complete.
    written when the bars are now functional in the processor.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MEM_IPL_COMPLETE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MEM_IPL_COMPLETE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    REQUIRED:
      HW mirroring is enabled, and all channels are required
      to be part of a mirrored group.
    REQUESTED:
      HW mirroring is enabled. Mirroring will be configured for
      groups which support it, but not all channels are required
      to be mirrored.
    OFF:
      HW mirroring is disabled.
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_HW_MIRRORING_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MRW_HW_MIRRORING_ENABLE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Processor fabric topology id table. Index is the value of RA[15:19] and the
    value stored is the 4-bit topology id of the owning chip (of that space).
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_TOPOLOGY_ID_TABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_TOPOLOGY_ID_TABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>32</array>
      <uint8_t>
        <default>
    INVALID,INVALID,INVALID,INVALID,INVALID,INVALID,INVALID,INVALID,
    INVALID,INVALID,INVALID,INVALID,INVALID,INVALID,INVALID,INVALID,
    INVALID,INVALID,INVALID,INVALID,INVALID,INVALID,INVALID,INVALID,
    INVALID,INVALID,INVALID,INVALID,INVALID,INVALID,INVALID,INVALID
  </default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Processor fabric SL domain (proxime) configuration.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_SL_DOMAIN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_SL_DOMAIN</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Processor fabric broadcast scope configuration.
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_BROADCAST_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_BROADCAST_MODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Processor fabric topology mode, determines format of the topology ID.
    MODE0 = GGG_C (max 8x2)
    MODE1 = GG_CC (max 4x4)
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_TOPOLOGY_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_TOPOLOGY_MODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Processor fabric topology ID associated with this chip. This is a 4-bit
    field in the format specified by ATTR_PROC_FABRIC_TOPOLOGY_MODE.
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_TOPOLOGY_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_TOPOLOGY_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Processor fabric topology ID based on memory availability. If the
    master chip has memory then EFF_TOPOLOGY_ID = TOPOLOGY_ID, if not
    then the first socket with memory behind it will swap topology
    IDs with the master chip to form EFF_TOPOLOGY_ID. All else remains
    the same. This is a 4-bit field in the format specified by
    ATTR_PROC_FABRIC_TOPOLOGY_MODE..
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_EFF_TOPOLOGY_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_EFF_TOPOLOGY_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicates if the given chip should serve as the fabric system master.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_SYSTEM_MASTER_CHIP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_SYSTEM_MASTER_CHIP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicates if the given chip should serve as the fabric group master.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_GROUP_MASTER_CHIP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_GROUP_MASTER_CHIP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Per-link optics configuration
    OPT0 = SMPA/SMPX/OCAPI/NV
    OPT1 = SMPA/SMPX
    OPT2 = SMPA/SMPX
    OPT3 = SMPA/SMPX/OCAPI/NV
    OPT4 = SMPA/SMPX/OCAPI/NV
    OPT5 = SMPA/SMPX/OCAPI/NV
    OPT6 = SMPA/SMPX/OCAPI/NV
    OPT7 = SMPA/SMPX/OCAPI/NV
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_CONFIG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IOHS_CONFIG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Processor optics bus width per link.
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_BUS_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IOHS_BUS_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Indicates if the link is used to connect between drawers.
    Should be considered valid only if ATTR_IOHS_CONFIG_MODE for the given
    link is configured as an SMPX or SMPA.
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_DRAWER_INTERCONNECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IOHS_DRAWER_INTERCONNECT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Indicates if the endpoint target is actively being used as a fabric link
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_LINK_ACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_LINK_ACTIVE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicates which sublinks should be initialized/trained. This bus-scoped
    attribute is used to shadow info into the chip-scoped attribute
    ATTR_PROC_FABRIC_[XA]_ATTACHED_CHIP_CNFG respectively.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_LINK_TRAIN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IOHS_LINK_TRAIN</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    For each fabric X link on this chip, specifies whether or not the chip at the
    receiving end of the link is present and configured
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_X_ATTACHED_CHIP_CNFG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Contains the total number of active X links on this chip
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_X_LINKS_CNFG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_X_LINKS_CNFG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    For each fabric A link on this chip, specifies whether or not the chip at the
    receiving end of the link is present and configured
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_A_ATTACHED_CHIP_CNFG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Contains the total number of active A links on this chip
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_A_LINKS_CNFG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_A_LINKS_CNFG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    For each fabric X link on this chip, specifies the fabric topology ID chip
    bits of the chip at the receiving end of the link. Should be considered valid
    only if corresponding ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG index is true.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_X_ATTACHED_CHIP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_X_ATTACHED_CHIP_ID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    For each fabric X link on this chip, specifies the link ID of the chip at the
    receiving end of the link. Should be considered valid only if corresponding
    ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG index is true.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_X_ATTACHED_LINK_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_X_ATTACHED_LINK_ID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    For each fabric A link on this chip, specifies the fabric topology ID chip
    bits of the chip at the receiving end of the link. Should be considered valid
    only if corresponding ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG index is true.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_A_ATTACHED_CHIP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_A_ATTACHED_CHIP_ID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    For each fabric A link on this chip, specifies the link ID of the chip at the
    receiving end of the link. Should be considered valid only if corresponding
    ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG index is true.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_A_ATTACHED_LINK_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_A_ATTACHED_LINK_ID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicates if X links on this chip should be configured in aggregate mode.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_X_AGGREGATE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_X_AGGREGATE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicates if link should be used to carry data only (in aggregate configurations).
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG
    index is true.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_X_ADDR_DIS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_X_ADDR_DIS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Average of local/remote end link delay counter values.
    Used to designate coherent link in aggregate configurations.
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG
    index is true.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_X_LINK_DELAY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_X_LINK_DELAY</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicates if A links on this chip should be configured in aggregate mode.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_A_AGGREGATE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_A_AGGREGATE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicates if link should be used to carry data only (in aggregate configurations).
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG
    index is true.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_A_ADDR_DIS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_A_ADDR_DIS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Average of local/remote end link delay counter values.
    Used to designate coherent link in aggregate configurations.
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG
    index is true.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_A_LINK_DELAY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_A_LINK_DELAY</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Fabric topology ID table configuration.
    Used to indicate whether the topology ID table entry is valid.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_TID_TABLE_ENTRY_VALID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_TID_TABLE_ENTRY_VALID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>32</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Fabric topology ID table configuration.
    Used to represent the corresponding ID for each topology ID table entry.
    Each topology ID table entry is programmed with the A/X link ID that
    routes this chip to the target chip identified by the topology ID table index.
    Should be considered valid only if corresponding
    ATTR_PROC_FABRIC_TID_TABLE_ENTRY_VALID index is true.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_TID_TABLE_ENTRY_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_TID_TABLE_ENTRY_ID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>32</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Configuration for fabric asynchronous boundary crossings that exist
    between the fabric and the MC/PAU/IOHS units.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_ASYNC_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_ASYNC_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Processor core floor/ceiling frequency ratio used for epsilon calculations.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CORE_FREQ_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_CORE_FREQ_RATIO</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Guardband percentage to apply to baseline epsilon calculations.
    A positive value can be provided to add additional guardband, or a
    negative value can be provided to reduce the guardband.

    Note that base epsilon table values have a 20% guardband by default,
    therefore, setting this attribute to -16 (for -16% guardband) will
    provide epsilon values with approximately 0% guardband.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_GB_PERCENTAGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_EPS_GB_PERCENTAGE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <int8_t></int8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Processor epsilon table type.
    Used to calculate the processor nest epsilon register values.
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_TABLE_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_EPS_TABLE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Calculated read tier0 epsilon protection count.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_READ_CYCLES_T0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_EPS_READ_CYCLES_T0</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Calculated read tier1 epsilon protection count.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_READ_CYCLES_T1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_EPS_READ_CYCLES_T1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Calculated read tier2 epsilon protection count.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_READ_CYCLES_T2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_EPS_READ_CYCLES_T2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Calculated write tier1 epsilon protection count.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_WRITE_CYCLES_T1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_EPS_WRITE_CYCLES_T1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Calculated write tier2 epsilon protection count.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_WRITE_CYCLES_T2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_EPS_WRITE_CYCLES_T2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Stores the state of registers affected by p10_sbe_mcs_setup
    To be restored in p10_revert_sbe_mcs_setup.
    Set by p10_sbe_mcs_setup.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_SBE_MCS_SETUP_REG_STATES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_SBE_MCS_SETUP_REG_STATES</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>9</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Store unit position of MC written to by p10_sbe_mcs_setup.
    To be used in p10_revert_sbe_setup.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_SBE_MCS_SETUP_SELECTED_MC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_SBE_MCS_SETUP_SELECTED_MC</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The frequency of the OMI channel.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_OMI_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_OMI_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Chiplet partial good information, direct from module VPD PG keyword
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PG_MVPD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PG_MVPD</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Indicates if SBE on this chip is serving as hostboot drawer master
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_SBE_MASTER_CHIP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_SBE_MASTER_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Sector buffer strength</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SECTOR_BUFFER_STRENGTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SECTOR_BUFFER_STRENGTH</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>enable the pulse mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PULSE_MODE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PULSE_MODE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>DISABLE</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>value for pulse mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PULSE_MODE_VALUE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PULSE_MODE_VALUE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Control NDL training:meshctrl setup</description>
    <hwpfToHbAttrMap>
      <id>ATTR_NDL_MESHCTRL_SETUP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NDL_MESHCTRL_SETUP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>IOHS pll bucket selection</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_PLL_BUCKET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IOHS_PLL_BUCKET</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    To skip the locking sequence and check for lock of CP TOD Filter PLL
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_PLLTODFLT_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CP_PLLTODFLT_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    To skip the locking sequence and check for lock of CP Nest Filter PLL
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_PLLNESTFLT_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CP_PLLNESTFLT_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    To skip the locking sequence and check for lock of CP IO Filter PLL
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_PLLIOFLT_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CP_PLLIOFLT_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    To skip the locking sequence and check for lock of CP IO Spread Spectrum Filter PLL
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_PLLIOSSFLT_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CP_PLLIOSSFLT_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Skip locking sequence and check for lock of PAU DPLL
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PAU_DPLL_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PAU_DPLL_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Skip locking sequence and check for lock of NEST DPLL
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_DPLL_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NEST_DPLL_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Skip locking sequence and check for lock of IO PLLs
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_TANK_PLL_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_TANK_PLL_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Capturing Cores Gard Value
    Each bit position corresponds to a core starting at core 0 being bit 0
    Each nibble is representative of an EQ chiplets Cores
    The EQ is always functional, so this field only tracks core state
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CORE_GARD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CORE_GARD</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
  Indicates the master boot core selected by p10_sbe_select_ex.
  Ranges from 0 to 31.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MASTER_CORE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MASTER_CORE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Bit vector indicating the active boot cores selected by
  p10_sbe_select_ex.  Bit 0 = Core 0, Bit 1 = Core 1, ..., Bit 31 = Core 31.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_ACTIVE_CORES_VEC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>ACTIVE_CORES_VEC</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Bit vector indicating the caches used as backing caches selected
  by p10_sbe_select_ex.  Bit 0 = Cache 0, Bit 1 = Cache 1, ..., Bit 31 = Cache 31.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_BACKING_CACHES_VEC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BACKING_CACHES_VEC</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Number of necessary active boot cores required. Must be set by
  the platform before calling p10_sbe_select_ex.  If ATTR_ACTIVE_CORES_VEC is
  overridden, this attribute value must be greater than or equal to the number
  of bits on in ATTR_ACTIVE_CORES_VEC.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_ACTIVE_CORES_NUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>ACTIVE_CORES_NUM</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Number of necessary backing caches required. Must be set by
  the platform before calling p10_sbe_select_ex.  If ATTR_BACKING_CACHES_VEC is
  overridden, this attribute value must be greater than or equal to the number
  of bits on in ATTR_BACKING_CACHES_VEC.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_BACKING_CACHES_NUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BACKING_CACHES_NUM</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Populated by HWP called during IPL.
  PROC, MEMBUF: Bits 0 to 63 of the ECID in array entry 0 and bits 64 to 127 in ECID array entry 1
  OCMB: Explorer: Data Inserted HIGH:LOW, ex. ATTR_ECID[0] = [PE_DATA_3:PE_DATA_2:PE_DATA_1:PE_DATA_0]
  OCMB: Gemini: 64-bit ECID inserted in ATTR_ECID[0]
  TK/FIXME/TODO: This needs to be made larger to support the entire Explorer ECID.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_ECID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>ECID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The 32b vector of all good, functional cores on the chip. This is used
        to initialize the LCO targets used when an L3 masters an LCO in a
        PROC_FABRIC_SL_DOMAIN=CHIP configuration.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_CHIP_LCO_TARGETS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_CHIP_LCO_TARGETS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The product of the DPLL internal prescalar divide (CD_DIV124_DC) and the
        divider(CD_DPLLOUT124_DC). This estalishes the step size of the DPLL in
        of this number divided into the processor reference clock.

    if 0, consuming procedures will assume a default of 8.

    Provided to override default value
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_DPLL_DIVIDER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_DPLL_DIVIDER</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Set by proc_hcode_image build with the offset value from the HOMER base
        the XGPE Boot Copier interrupt vectors reside. This value must be 512B
        The HOMER base address will be pre-establish in PBABAR0 so the address
        to be off the form 0x8XXXXX00. The XGPE will be Sreset after this value
        established.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_XGPE_BOOT_COPIER_IVPR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>XGPE_BOOT_COPIER_IVPR_OFFSET</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Set by proc_hcode_image build with the offset value from the HOMER base
        the PGPE Boot Copier interrupt vectors reside. This value must be 512B
        The HOMER base address will be pre-establish in PBABAR0 so the address
        to be off the form 0x8XXXXX00. The PGPE will be Sreset after this value
        established
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PGPE_BOOT_COPIER_IVPR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PGPE_BOOT_COPIER_IVPR_OFFSET</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Set by proc_hcode_image build with the offset value from the HOMER base
        the QME Boot Copier interrupt vectors reside. This value must be 512B
        The HOMER base address will be pre-establish in PBABAR0 so the address
        to be off the form 0x8XXXXX00. The QME will be Sreset after this value
        established
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_QME_BOOT_COPIER_IVPR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>QME_BOOT_COPIER_IVPR_OFFSET</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Flag storage to have the Special Wakeup procedure ignore a checkstop condition.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_SPWUP_IGNORE_XSTOP_FLAG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_SPWUP_IGNORE_XSTOP_FLAG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The attribute stores the Local FIR value of OCC taken during the halt phase.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_OCC_LFIR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OCC_LFIR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The attribute stores the Local FIR value of PBA taken during the halt phase.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PBA_LFIR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PBA_LFIR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The attribute stores the Local FIR value of QME taken during the halt phase.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_QME_LFIR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>QME_LFIR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    0 = OCC has never been loaded and FIR Masks have never been initialized,
    1 = FIR masks have been initialized and the hardware should reflect correct
    2 = FIR masks have been initialized but the current hardware state is the
        value
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_FIRINIT_DONE_ONCE_FLAG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_FIRINIT_DONE_ONCE_FLAG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicates the L3 region has clocks running and scommable
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_L3_HASCLOCKS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>L3_HASCLOCKS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicates the execution units in core 0 have clocks running and scommable
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CORE_HASCLOCKS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CORE_HASCLOCKS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicates L3 has power and has valid latch state that could be scanned
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_L3_HASPOWER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>L3_HASPOWER</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicates core 0 has power and has valid latch state that could be scanned
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CORE_HASPOWER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CORE_HASPOWER</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicator that all relevant attributes and required data for Pstates to be
        is present and valid

    Producer: proc_build_pstate_datablock

    Consumers: proc_pm_pstate_gpe_init
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PSTATES_ENABLED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PSTATES_ENABLED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicator that all relevant attributes and required data for Resonant
        to be enabled is present and valid

    Producer: proc_build_pstate_datablock

    Consumers: p10_hcode_image_build -&gt;
    PGPE Header CME Header
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_RESCLK_ENABLED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>RESCLK_ENABLED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicator that all relevant attributes and required data for Digital Droop
        (DDS) to be enabled is present and valid

    Producer: proc_build_pstate_datablock

    Consumers: p10_hcode_image_build -&gt;
    PGPE Header QME Header
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_ENABLED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_ENABLED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicator that all relevant attributes and required data for Retention
        Regulator Macros (RVRMs) to be enabled is present and valid

    Producer: proc_build_pstate_datablock

    Consumers: p10_hcode_image_build -&gt;
    PGPE Header QME Header
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_RVRM_ENABLED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>RVRM_ENABLED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicator that all relevent attributes and required data for WOF to be
        is present and valid

    Producer: proc_build_pstate_datablock

    Consumers: p10_hcode_image_build -&gt;
    PGPE Header CME Header
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_ENABLED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_ENABLED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Enable debug halt function upon XGPE Phantom interrupts

    Consumers: p10_hcode_image_build -&gt;
    XGPE Header
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_XGPE_PHANTOM_HALT_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>XGPE_PHANTOM_HALT_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Enable debug halt function upon PGPE Phantom interrupts

    Consumers: p10_hcode_image_build -&gt;
    PGPE Header
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PGPE_PHANTOM_HALT_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PGPE_PHANTOM_HALT_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Enable debug halt function upon QME Stop Phantom stop interrupts

    Consumers: p10_hcode_image_build -&gt;
    QME Header
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_QME_STOP_PHANTOM_HALT_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>QME_STOP_PHANTOM_HALT_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicates that a special wakeup is in progress for a core.

    Producer: proc_cpu_special_wakeup_core.C

    Consumers: proc_cpu_special_wakeup_core.C
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CORE_INSIDE_SPECIAL_WAKEUP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CORE_INSIDE_SPECIAL_WAKEUP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Attribute is set at the start of PM halt and cleared at the end. It act as a
        for FFDC collection utility to behave differently during PM restart
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_INITIATED_PM_HALT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>INITIATED_PM_HALT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Attribute to indicate the progress in the PM Complex Restart flow.

    Producer: proc_pm_reset.C Consumers: proc_pm_reset.C proc_pm_recovery_ffdc_*.C
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_RESTART_PHASE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_RESTART_PHASE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Attribute is set in PM Reset and cleared in the immediate subsequent PM
        when handling a PM Malfunction related PM Complex restart cycle.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_MALF_CYCLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_MALF_CYCLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Voltage (binary in 1mV units) used to boot the chip.  Value
    chosen is system dependent and is a combination of the part's Vital Product
    Data (VPD) (the PowerSave values for VDD and VCS uplifted by
    ATTR_BOOT_VOLTAGE_BIAS_0P5PCT) and the minimum allowed for correct operation
    of the fabric bus.

    Index 0: VDD
    Index 1: VCS
    Index 2: VDN
    Index 3: VIO

    Producer: p10_setup_evid (first pass)

    Consumer: p10_setup_evid (second pass)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_BOOT_VOLTAGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BOOT_VOLTAGE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Enable trap function upon broadside scan

    Consumers: p10_hcd_core/cache_*_initf 
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_QME_BROADSIDE_SCAN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>QME_BROADSIDE_SCAN</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Time between invocations of auxiliary function on GPE1. The time (in is
    as 2^ATTR_AUX_FUNC_INVOCATION_TIME_MS with 0 indicating the
    is OFF.

    Consumer: p10_hcode_image_build.c -&gt; XGPE Header field

    Provided by the Machine Readable Workbook to tune the collection.

    Platform default:1
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_AUX_FUNC_INVOCATION_TIME_MS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>AUX_FUNC_INVOCATION_TIME_MS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x01</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Frequency Bias - % of bias (signed twos complement in 0.5 percent steps) in
    the frequency associated with a Pstate. Applies to all #V points,

    Producer:Attribute Overrides by Lab/Mfg Characterization Team

    Consumer: p10_pstate_parameter_block
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_BIAS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_BIAS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <int8_t></int8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Voltage Bias - % of bias (signed twos complement in 0.5
    that is applied to the respective rail's (VDD, VCS) #V VPD point used in
    voltage values associated with Pstates..

    Array[Rail][Point]

    [Rail]-&gt;2 entries-:
        0: VDD;
        1: VCS

    [Point] -&gt;9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    Producer:Attribute Overrides by Lab/Mfg Characterization Team

    Consumer: p10_pstate_parameter_block
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_VOLTAGE_EXT_BIAS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VOLTAGE_EXT_BIAS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,8</array>
      <int8_t></int8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    VDN Voltage Bias - % of bias (signed twos complement in 0.5 percent steps)
    applied to the VDN value stored in the VPD for setting the VDN rail.

    Producer: Attribute Overrides by Lab/Mfg Characterization Team

    Consumer: p10_pstate_parameter_block

    Platform default:0
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_VOLTAGE_EXT_VDN_BIAS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VOLTAGE_EXT_VDN_BIAS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <int8_t></int8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Digital Droop Sensors (DDS) Extreme Threshold Select Value per VPD point.
    a negative value below the DDS setting that will trigger droop event.  This
    attibute overrides the

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid.

    Producer: Override
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_DROOP_EXTREME_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_DROOP_EXTREME_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>9</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Digital Droop Sensors (DDS) Large Threshold Select Value per VPD point.
    a negative value below the DDS setting that will trigger droop event.

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid.

    Producer: Override
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_DROOP_LARGE_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_DROOP_LARGE_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>9</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Digital Droop Sensors (DDS) Small Select Value per VPD point. Indicates a
    value below the DDS setting that will trigger droop event.

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid.

    Producer: Override
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_DROOP_SMALL_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_DROOP_SMALL_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>9</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Controls the enablement of Digital Droop Sensors (DDS) to throttle the core
    extreme droop event.

    Producer:Machine Readable Workbook

    Consumers: QME attribute?
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_EXTREME_THOTTLE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_EXTREME_THOTTLE_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    DPLL response override of the respective #W VPD content for returning from a
    Droop value to the Small value. Values are in 1/32ths with values being
    N being less than or equal to 8.

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid.

    Producer: Override
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_FREQ_RETURN_L_S_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_FREQ_RETURN_L_S_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>9</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Attribute in place to allow override for boot mode voltage
    Consumer: p9_setup_evid.C
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SAVE_MODE_NODDS_UPLIFT_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SAVE_MODE_NODDS_UPLIFT_MV</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    DPLL response override of the respective #W VPD content for returning from a
    Droop value to the Normal value. Values are in 1/32ths with values being
    N being less than or equal to 8.

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid.

    Producer: Override
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_FREQ_RETURN_S_N_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_FREQ_RETURN_S_N_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>9</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    DPLL response override of the respective #W VPD content for a Voltage Droop
    Large Frequency Drop (eg Normal to Large). Values are in 1/32ths legal
    being of N being less than or equal to 8.

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid.

    Producer: Override
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_LARGE_FREQ_DROP_N_L_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_LARGE_FREQ_DROP_N_L_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>9</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Digital Droop Sensor (DDS) OverVoltage Threshold Select Value per VPD. The
    a positive value above the VDM setting that will an overvolt condition.

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid.

    Producer: Override
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_OVERVOLT_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_OVERVOLT_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>9</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    DPLL response override of the respective #W VPD content for a Digital Droop
    (DDS) Small Frequency Drop (eg Normal to Small). Values are in 1/32ths
    being of N being less than or equal to 8.

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid

    Producer: Override
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_SMALL_FREQ_DROP_N_S_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_SMALL_FREQ_DROP_N_S_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>9</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    DDS Voltage Compare Bias - % of bias (signed twos complement in 0.5 percent
    is applied to the #W DDS VID Compare before placement in the Pstate
    Blocks that will be consumed by Hcode.

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax

    Producer: Override
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_VID_COMPARE_BIAS_0P5PCT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_VID_COMPARE_BIAS_0P5PCT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <int8_t></int8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Voltage Droop Monitor (VDM) Voltage Compare Voltage to expect when no droop
    (binary in mV). A default value of 0 indicates no override

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid

    Producer: Override
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_VID_COMPARE_OVERRIDE_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_VID_COMPARE_OVERRIDE_MV</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>9</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Indicates the response of the DPLL frequency upon DDS events if is not ON.

    NONE -&gt; DPLL Mode 2 DROOP_PROTECT -&gt; DPLL Mode 3 DROOP_PROTECT_OVERVOLT -&gt;
    3.5 DYNAMIC -&gt; DPLL Mode 4 DYNAMIC_PROTECT -&gt; DPLL Mode 5

    Producer: MRWB
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DPLL_DDS_RESPONSE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DPLL_DDS_RESPONSE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    if set to 1, p10_dump_stop_info output will be written to error logs
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DUMP_STOP_INFO_ENABLE_ERRORLOG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    if set to 1, FAPI_ERR records are suppressed from being produced by
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Enables the PGPE Hcode to physically perform frequency and voltage based on
    parameters (eg #V VPD, system parameters, biases, VFRTs. etc). If OFF,
    PGPE provides an immedicate good response to Pstate/WOF IPC operations
    the OCC for firmware integration testing

    Consumer: p10_hcode_image_build.c -&gt; PGPE Header field

    Platform default: ON
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PGPE_HCODE_FUNCTION_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PGPE_HCODE_FUNCTION_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Enables the XGPE Hcode to support the MPIPL function that coordinates the 
    suspension of the Power Management subsystem. If ON (DISABLED), XGPE provides 
    and immediate good response to allow for general integration testing

    Consumer: p10_hcode_image_build.c -&gt; XGPE Header field

    Platform default: OFF
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_XGPE_PM_SUSPEND_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>XGPE_PM_SUSPEND_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>ON</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Enable Global FIR tracing through PM Complex Reset/Initialization
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_GLOBAL_FIR_TRACE_EN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_GLOBAL_FIR_TRACE_EN</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Enables pstate parameter block code to use the static #W data

    Consumer: p10_pstate_parameter_block.C

    Platform default:OFF
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_POUND_W_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>POUND_W_STATIC_DATA_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Attribute in place to allow override of which POUNDV bucket to use to set
    data.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_POUNDV_BUCKET_NUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>POUNDV_BUCKET_NUM</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    1 if override of poundv bucket num is available. 0 if override is unavailable.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_POUNDV_BUCKET_NUM_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>POUNDV_BUCKET_NUM_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The PM_RESET hwp calls special wakeup enable on all EX targets, then will
    wakeup bit on the core if special wakeup is done. In some hostboot does
    want these steps of the PM_RESET. This attribute gives platform the
    to decide if they want to enable special wakeup and autowakeup on the
    during PM_RESET.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SKIP_WAKEUP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SKIP_WAKEUP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Enables pstate parameter block code to use the static system vrt data

    Consumer: p10_pstate_parameter_block.C -&gt; PGPE Hcode

    Platform default:OFF
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS_VRT_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYS_VRT_STATIC_DATA_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Disables the validity checking of #V VPD content from causing IPL failures.

    OFF:Will enable PStates given all validity checks pass. If validity checks
    a failure is log and error reaction will occur (eg IPL failure) ON: Will
    #V validity checking of #V from causing IPL to halt. check failures will
    error logs and Pstates (including other functions) will be disabled.

    Producer: Override

    Consumers: p10_pstate_parameter_block
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_POUNDV_VALIDITY_HALT_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_POUNDV_VALIDITY_HALT_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Debug modes supported for QME Scan layout in HOMER.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_RING_DBG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_RING_DBG_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Switch to enable or disable Power Management Malfunction Alert Handling on
    platform support. e.g. True for PHYP based systems and False for based
    depending on support available.

    Producer: Initialized by Hostboot firmware based on platform support Read by
    p10_pm_stop_gpe_init.C
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_MALF_ALERT_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_MALF_ALERT_ENABLE</id>
    <no_export></no_export>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Switch to enable or disable Power Management Complex FFDC collection during
    the PM Complex Halt flow to HOMER to assist with failure analysis and recovery.

    Producer: HB must set or reset this based on the platform use-case and
    p10_pm_halt.C, p10_pm_callout.C
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_HALT_FFDC_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_HALT_FFDC_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Disables the enablement of Digital Droop Sensors (DDS) in the system.

    Producer:MRW

    Consumers:p10_pstate_parameter_block -&gt;
    QME Pstate parameter block ????
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_DDS_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_DDS_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    
    Producer:Override

    Consumers:p10_pstate_parameter_block -&gt;
    QME Pstate parameter block ????
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_DDS_FREQ_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_DDS_FREQ_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Controls the mode of Pstate Protocol for testing. ON: Boots the PGPE in &quot;OCC
    Mode&quot; but does NOT start the Pstate protocol OFF: Does NOT boot the PGPE
    Boots the PGPE and automatically starts the Pstate protocol. PMCR
    to move Pstates are honored.

    Producer:Override

    Consumers: p10_pstate_parameter_block and p10_pm_pstate_gpe_init
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_PSTATES_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_PSTATES_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Disables the enablement of resonant clocking in the system.

    Producer: Override Consumers: p10_pstate_parameter_block to clear the flag
    CME QuadManager
    reaction
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_RESCLK_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_RESCLK_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Disables RVRM enablement in the system

    Producer: Override

    Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_RVRM_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_RVRM_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Disables Work Load Optimized Frequency (WOF) algorithms to modify frequency
    active core count and other inputs.

    OFF:Will enable WOF given all validity check pass. If validity checks fail,
    be disabled for the present IPL.

    ON: Will disable WOF OFF_SKIP_DD: as but skips any validity checking of the
    design level (lab use

    Producer: Override

    Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_WOF_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_WOF_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Disables Workload Optimized Voltage (WOV) undervolting algorithms which
    voltage below the value calculated from VPD.

    OFF: Will enable WOV overvolting given all validity check pass. If validity
    WOV overvolting will be disabled for the present IPL.

    ON:Will disable overvolting

    Producer: Override

    Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_WOV_OVERV_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_WOV_OVERV_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Disables Workload Optimized Voltage (WOV) undervolting algorithms which
    voltage below the value calculated from VPD.

    OFF:Will enable WOV undervolting given all validity check pass. If validity
    WOV undervolting will be disabled for the present IPL.

    ON: Will disable undervolting

    Producer: Override

    Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_WOV_UNDERV_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_WOV_UNDERV_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Disables Over Current Sensor functions

    OFF:Will enable Over Current Sensor (OCS) given all validity check pass. If
    checks fail,
    WOV undervolting will be disabled for the present IPL.

    ON: Will disable OCS and WOF (TBD on the this phase in of validity)

    Producer: Override

    Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_OCS_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_OCS_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Receive PBAX Broadcast Group. Vector that is indexed when decoded PMISC with
    decoded PMISC pbax_chipid value. If the bit in this vector at decoded
    location is a 1, then this receive engine will participate the broadcast

    Override attribute. Platform value of 0 indiates the OCC firmware will this
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PBAX_BRDCST_ID_VECTOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PBAX_BRDCST_ID_VECTOR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Receive PBAX Chipid. Value that indicates this PBA's PBAX Chipid within the
    Is matched to pbax_chipid of the Address phase if

    Provided by the Machine Readable Workbook.

    Platform default:Nimbus systems - set so value in ATTR_FABRIC_GROUP_ID
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PBAX_CHIPID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PBAX_CHIPID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Receive PBAX Groupid. Value that indicates this PBA's PBAX Group affinity.
    matched to pbax_groupid of the PMISC Address phase.

    Provided by the Machine Readable Workbook.

    Platform default:Nimbus systems = 0
    </description>
    <global></global>
    <hwpfToHbAttrMap>
      <id>ATTR_PBAX_GROUPID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PBAX_GROUPID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    SPIPSS Clock Frequency (binary in KHz)

    Valid range: 500KHz to 2500KHz

    Consumer: p10_pss_init

    Overridden by the Machine Readable Workbook.

    If default of 0 is read, HWP will set SPIPSS frequency to 10MHz.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SPIPSS_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SPIPSS_FREQUENCY</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Defines which of the PSS chip selects (0 or 1) that the APSS is connected

    Producer:  Machine Readable Workbook
    Consumer: p10_pm_pss_init
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SPIPSS_SELECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SPIPSS_SELECT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Impedance (binary in microOhms) of the distribution loss sense point to the
    value is applied to each processor instance.

    [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO

    Producer: Machine Readable Workbook (per the power subsystem design)

    Consumers: p10_pstate_parameter_block
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_DISTLOSS_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_DISTLOSS_UOHM</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Impedance (binary microOhms) of the load line from a processor VRM to the
    pins. This value is applied to each processor instance.

    [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO

    Note:no loadline may be present in the system; thus, a value of 0 is legal.

    Producer: Machine Readable Workbook (per the power subsystem design)

    Consumers: p10_pstate_parameter_block
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_LOADLINE_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_LOADLINE_UOHM</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Offset voltage (binary in microvolts) to apply to the VDD VRM distribution
    processor module. This value is applied to each processor instance.

    [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO

    Producer: Machine Readable Workbook (per the power subsystem design)

    Consumers: p10_pstate_parameter_block
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_VRM_VOFFSET_UV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_VRM_VOFFSET_UV</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The number of XGPE Fixed Timer Interrupts (see Hcode documentation for to
    a core throttle when OCC Flag 3[Core Throttle Continuous Enable] is set.

    A value of 0 when Continuous Change Enable is set will deassert throttle.

    Producer:Override/Lab

    Consumers:p10_hcode_image_build.c -&gt; XGPE Header field
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CORE_THROTTLE_ASSERT_COUNT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CORE_THROTTLE_ASSERT_COUNT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The number of XGPE Fixed Timer Interrupts (see Hcode documentation for
    durations) to deassert core throttle when OCC Flag 3[Core Continuous
    Enable] is set.

    A value of 0 when Continuous Change Enable is set and is non-0, throttling
    always on.

    Producer:Override/Lab

    Consumers:p10_hcode_image_build.c -&gt; PGPE Header field
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CORE_THROTTLE_DEASSERT_COUNT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CORE_THROTTLE_DEASSERT_COUNT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Defines the AVSBus (0, 1 or 2) which has the indicated rail VRM

    [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO

    Producer:Machine Readable Workbook

    Consumers: p10_set_evid; p10_set_voltage (tool) -&gt;
    Global Pstate Parameter Block (GPPB) for PGPE;  OCC Pstate Parameter Block
    OCC

    *MOST* systems use Bus 0 for VDD, Bus 1 for VCS, Bus 2 for VIO and VDN. If
    is not the case, the value must be appropriately set by the platform (eg MRW
    or equivalent)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_AVSBUS_BUSNUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>AVSBUS_BUSNUM</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    AVSBus Clock Frequency (binary in KHz)

    Consumer: p10_ocb_init.C

    Overridden by the Machine Readable Workbook.

    If default of 0 is read, HWP will set AVSBus frequency to 1MHz.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_AVSBUS_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>AVSBUS_FREQUENCY</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Defines the AVSBus rail selector number (0 - 15) for the VRM on the bus
    by ATTR_AVSBUS_BUSNUM[x].

    [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO

    Producer:Machine Readable Workbook

    Consumers: p10_set_evid; p10_set_voltage (tool) -&gt;
    Global Pstate Parameter Block (GPPB) for PGPE OCC Pstate Parameter Block
    OCC

    *MOST* systems use Bus 0 for VDD, Bus 1 for VCS, Bus 2 for VIO and VDN. If
    is not the case, the value must be appropriately set by the platform (eg
    or equivalent)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_AVSBUS_RAIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>AVSBUS_RAIL</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Step size (binary in microvolts) to take upon external VRM voltage. This
    provide a limit of the external VRMs steps.

    Consumer: p10_pstate_parameter_block -&gt; p10_setup_evid Pstate Parameter
    (PSPB) for PGPE

    Provided by the Machine Readable Workbook after system characterization.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_STEPSIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_STEPSIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Transition rate (binary in microVolts per microsecond) of the VRM for an
    transition.This is used as part of the overall voltage time calculation
    provides a default value of 10000 uV/us (eg if this attribute is zero.
    the fastest possible rate is limited to

    Consumer: p10_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE

    Provided by the Machine Readable Workbook after system characterization.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Transition rate (binary in microVolts per microsecond) of the VRM for an
    transition.This is used as part of the overall voltage time calculation
    provides a default value of 10000 uV/us (eg if this attribute is zero.
    the fastest possible rate is limited to

    Consumer: p10_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE

    Provided by the Machine Readable Workbook after system characterization.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Time (binary in nanoseconds) to allow the voltage rail to stabilize before
    transition to be fully complete. This value is used for both and
    transitions as part of the overall voltage transition calculation.
    provides a default value of 5000ns (5us) if this is zero. Note: the
    delay is limited to 1ns.

    Consumer: p10_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE

    Provided by the Machine Readable Workbook after system characterization.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Delay (binary in nanoseconds) from the time the VRM receives the write
    until the voltage actually moves.This value is used for both and
    transitions as part of the overall voltage transition calculation.
    provides a default value of 8000ns (eg 8us)) if attribute is zero. Note:
    smallest possible delay is limited to 1ns.

    Consumer: p10_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE

    Provided by the Machine Readable Workbook after system characterization.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_START_NS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_START_NS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    If WOV undervolting and/or WOF overvolting is enabled, then this is used to
    a check for maximum frequency loss. If frequency in tenths of is below
    value, then an error is logged and WOV is disabled.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOV_MAX_DROOP_10THPCT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOV_MAX_DROOP_10THPCT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    If WOV overvolting is enabled, then this specifies the maximum amount of
    The value is specified in tenths of percentage(0.1%).

    If, 0, then default value of 10(1%) is used.

    Value can range from 1(0.1%) to 100(10%). Values greater than 100 are to
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOV_OVERV_MAX_10THPCT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOV_OVERV_MAX_10THPCT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    If WOV overvolting is enabled, then this specifies the amount by which to
    of overvolt amount. The value is specified in tenths of

    If 0, then default value of 0.5%(5) is used.

    Value can range from 1(0.1%) to 20(2%). Values greater than 20 are clipped
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOV_OVERV_STEP_DECR_10THPCT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOV_OVERV_STEP_DECR_10THPCT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    If WOV overvolting is enabled, then this specifies the amount by which to
    of overvolt amount. The value is specified in tenths of

    If 0, then default value of 0.5%(5) is used.

    Value can range from 1(0.1%) to 20(2%). Values greater than 20 are clipped
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOV_OVERV_STEP_INCR_10THPCT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOV_OVERV_STEP_INCR_10THPCT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Maximum regulator voltage allowed without exceeding the technology Vmax at
    pins.

    If, 0, then default value of 1150(1.15V)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOV_OVERV_VMAX_SETPOINT_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOV_OVERV_VMAX_SETPOINT_MV</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    If WOV undervolting and/or WOF overvolting is enabled, then this determines
    which the undervolting and/or overvolting is run. For P9, the minimum is
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOV_SAMPLE_125US</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOV_SAMPLE_125US</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    If WOV undervolting is enabled, then this specifies the maximum amount of
    The value is specified in tenths of percentage(0.1%).

    If, 0, then default value of 6%(60) is used.

    Value can range from 10(1%) to 255(25.5%). For values between 1(0.1%) and
    of 10(1%) will be used.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOV_UNDERV_MAX_10THPCT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOV_UNDERV_MAX_10THPCT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    If WOV undervolting is enabled, then this specifies the maximum amount of
    at which undervolting increments are stopped(and may be reduced). value
    specified in tenths of percentage(0.1%).

    If, 0, then default value of 0.5%(5) is used.

    Value can range from 1(0.1%) to 20(2%). All other values will be clipped to
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOV_UNDERV_PERF_LOSS_THRESH_10THPCT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOV_UNDERV_PERF_LOSS_THRESH_10THPCT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    If WOV undervolting is enabled, then this specifies the amount by which to
    of overvolt amount. The value is specified in tenths of

    If 0, then default value of 0.5%(5) is used.

    Value can range from 1(0.1%) to 20(2%). Values greater than 20 are clipped
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOV_UNDERV_STEP_DECR_10THPCT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOV_UNDERV_STEP_DECR_10THPCT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    If WOV undervolting is enabled, then this specifies the amount by which to
    of overvolt amount. The value is specified in tenths of

    If 0, then default value of 0.5%(5) is used.

    Value can range from 1(0.1%) to 20(2%). Values greater than 20 are clipped
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOV_UNDERV_STEP_INCR_10THPCT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOV_UNDERV_STEP_INCR_10THPCT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Maximum regulator voltage allowed without exceeding the technology Vmax at
    pins.

    If, 0, then default value of 1150(1.15V)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOV_UNDERV_VMIN_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOV_UNDERV_VMIN_MV</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    ?????

    Producer: Override
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_FMAX_OVERRIDE_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_FMAX_OVERRIDE_KHZ</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>5</array>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    ?????

    Producer: Override
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_FMIN_OVERRIDE_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DDS_FMIN_OVERRIDE_KHZ</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>5</array>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The powerbus frequency that should be used to locate a valid #V bucket in
    Module VPD if the actual ATTR_FREQ_PB_MHZ value isn't present.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PB_MHZ_POUNDV_FALLBACK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PB_MHZ_POUNDV_FALLBACK</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>NO_FALLBACK</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Safe mode frequency in MHZ. This attribute is used within the hwp to update
    DPLL frequency register.

    Consumer: p10_setup_evid.C

    Modified by p10_pstate_parameter_block
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SAFE_MODE_FREQUENCY_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SAFE_MODE_FREQUENCY_MHZ</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Safe mode voltages for VDD and VCS in mV.  If not overridden,  computed
    from #V PowerSave voltages uplifted by ATTR_BOOT_VOLTAGE_BIAS_0P5PCT.

    [index] -&gt;0: VDD; 1: VCS;

    Consumer: p10_setup_evid.C

    Modified in p10_pstate_parameter_block
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SAFE_MODE_VOLTAGE_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SAFE_MODE_VOLTAGE_MV</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <int32_t></int32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Enables the platform mode where the most recent PMCR update
    will be the controlling value for Pstate changes. If disabled,
    the legacy &quot;fastest one wins&quot; algorithm is used.

    Producer: p10_build_pstate_datablock

    Consumers: p10_hcode_image_build -&gt;
    PGPE Header
    QME attribute
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PMCR_MOST_RECENT_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PMCR_MOST_RECENT_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Address is allocated by hostboot and HBRT and is populated
    by p10_hcode_image_build with sc2 instruction. It enables CME to invoke
    a transition from HV to UV during STOP entry on an SMF enabled system.
    Address value should be aligned with 2MB boundary.

    Producer: Initialized by Hostboot firmware based on platform support
    Consumers: Read by p10_hcode_image_build.C
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_UNSECURE_HOMER_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>UNSECURE_HOMER_ADDRESS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Size of memory which hostboot must copy from a temp buffer to
    an unsecure region of main store memory. Once HOMER is built, hostboot reads
    the attribute and copies the amount of memory specified in this attribute from
    a temp buffer to an unsecure region of main memory specifed in an attribute
    ATTR_UNSECURE_HOMER_ADDRESS

    Producer: Initialized by hostboot firmware based on platform support

    Consumers: Read by p10_hcode_image_build.C
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_UNSECURE_HOMER_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>UNSECURE_HOMER_SIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Disables the MMA power-off function within the QME.

    OFF: Enables the QME MMA power-off funtion as further controlled by

    ON: Disables the dynamic MMA power-off function within the QME The MMA will
    be on if the core is powered on.

    Producer: Override

    Consumers: QME Hcode
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_MMA_POWEROFF_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_MMA_POWEROFF_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Disables the MMA power-on function within the QME. This can be use for
    that will NEVER have MMA based applications running so as to save the MMA

    OFF: Enables the QME MMA power-on funtion. This will have the MMA powered on
    istep 16 and then controlled by ATTR_SYSTEM_MMA_POWEROFF_DISABLE and
    thereafter.

    ON: Disables the MMA power-on function and leaves the MMA permenantly off.
    core will hang on MMA instruction that are dispatched.

    Producer: Override

    Consumers: QME Hcode
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_MMA_POWERON_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_MMA_POWERON_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Time to delay before powering off the MMA due to the lack of MMA instructions.

    Time = 1ms * 2**ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS.

    Valid values of  0x00 - 0x17 to yield times from 1ms to 2.3 hours -:
        0x00 - 1ms
        ...
        0x01 - 1 second (default)
        ...
        0x17 - 1 day
        0x18 - 0xFD - Reserved (maps as 0x17)
        0xFE - every QME FIT timer interrupt (~250us)
        0xFF - no power off of MMA (QME Hcode still runs; different behavior
    ATTR_SYSTEM_MMA_POWEROFF_DISABLE)

    Producer:  Machine Readable Workbook

    Consumer: QME Hcode
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0xA</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Retention Voltage ID to be applied to STOP 5 cores.

    Valid values (8mV granularity) -:
        0x00 - 000mV
        ...
        0x38 - 448mV (minimum circuit value)
        0x39 - 456mV
        ...
        0x4B - 600mV (default)
        ...
        0x6A - 848mV (maximum circuit value)
        ...
        0x7F - 1016mV
        All others reserved and flagged as errors.

    The Retention Voltage circuit has usable range of 448mV to 848mV. Values
    below 448mv (0x38) will be clipped to 448mV and values above 848mV (0x6A)
    will be clipped to 848mV.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_RVRM_VID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>RVRM_VID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x4B</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Defines the STOP levels supported by the Hcode in the present driver.

    Represented as bit vector where bit 0 = STOP0; bit 1 = STOP 1, ...,
    bit 15 = STOP15.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP_LEVELS_SUPPORTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP_LEVELS_SUPPORTED</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0xA410</default>
      </uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Disables STOP Level operat?ions in the Power Management complex by mapping
    the respective level to the next lower supported level in a additive
    manner.

    Represented as bit vector where bit 0 = STOP0; bit 1 = STOP 1, ...,
    bit 15 = STOP15.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP_LEVELS_DISABLED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP_LEVELS_DISABLED</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Boot bias applied to uplift the PowerSave #V VDD and VCS Voltages to boot the
    chip - % of bias (signed twos complement in 0.5 percent).

    Producer: Override

    Consumer: p10_setup_evid (first pass)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_BOOT_VOLTAGE_BIAS_0P5PCT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BOOT_VOLTAGE_BIAS_0P5PCT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>12</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Core Frequency at or above which the OMI buses are forced to full width 
    independent of what link reduction may attempt.  When the core frequency is 
    below this value.

    Producer:  Override/Lab
    Consumers: p10_build_pstate_datablock
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_OMI_FORCE_FREQ_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_OMI_FORCE_FREQ_MHZ</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    This attribute helps to indicate PGPE to turn off write assist even at high voltage
    when it is not used.
    Producer:  Override/Lab
    Consumers: p10_build_pstate_datablock
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SRAM_WRITE_ASSIST_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SRAM_WRITE_ASSIST_MV</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Specifies extra mini-EC versions beyond the standard Major.Minor DD
        level, e.g. 1.02 would have ATTR_EC=0x10, ATTR_MINI_EC=2
        Set by HWP as needed depending on how it is determined.
        Note: This should not be used directly for checks in HWPs, instead
          explicit attributes should be created for each workaround/change.
          This is here for FW to consume in non-HWP code (e.g. PHYP) and/or
          for display in FFDC or inventory lists.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MINI_EC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MINI_EC</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Logical position of target within a system. This is derived from the SMP location
      of each processor and each target's relationship to a proc.
      - PROC = based on SMP groupid+chipid
      - MEMBUF = PROC:FAPI_POS * [max membuf per proc]
      - 1st level child unit = [parent chip]:FAPI_POS * [max children of this type per chip]
      - 2nd+ level child unit = [immediate parent unit]:FAPI_POS * [max units below parent]
      Note: This should not be used algorithmically by HWPs directly.
      Note: Value ignores physical drawer boundaries, the value is unique across the entire
            system.
      This data is derived from the MRW.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FAPI_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FAPI_POS</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Scratch uint8_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT8_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT8_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint8_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT8_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT8_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint16_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT16_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT16_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint16_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT16_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT16_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint32_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT32_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT32_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint32_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT32_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT32_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint64_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT64_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT64_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint64_t attribute
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT64_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT64_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint8_t[32] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT8_ARRAY_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT8_ARRAY_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>32</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint8_t[2][3][4] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT8_ARRAY_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT8_ARRAY_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,3,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint16_t[16] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT16_ARRAY_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT16_ARRAY_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>16</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint16_t[2][3][2] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT16_ARRAY_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT16_ARRAY_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,3,2</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint32_t[8] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT32_ARRAY_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT32_ARRAY_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint32_t[2][3] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT32_ARRAY_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT32_ARRAY_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,3</array>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint64_t[4] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT64_ARRAY_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT64_ARRAY_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch uint64_t[2][2] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT64_ARRAY_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_UINT64_ARRAY_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int8_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT8_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT8_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <int8_t></int8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int8_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT8_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT8_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <int8_t></int8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int16_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT16_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT16_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <int16_t></int16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int16_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT16_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT16_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <int16_t></int16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int32_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT32_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT32_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <int32_t></int32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int32_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT32_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT32_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <int32_t></int32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int64_t attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT64_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT64_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <int64_t></int64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int64_t attribute
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT64_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT64_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <int64_t></int64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int8_t[32] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT8_ARRAY_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT8_ARRAY_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>32</array>
      <int8_t></int8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int8_t[2][3][4] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT8_ARRAY_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT8_ARRAY_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,3,4</array>
      <int8_t></int8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int16_t[16] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT16_ARRAY_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT16_ARRAY_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>16</array>
      <int16_t></int16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int16_t[2][3][2] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT16_ARRAY_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT16_ARRAY_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,3,2</array>
      <int16_t></int16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int32_t[8] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT32_ARRAY_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT32_ARRAY_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <int32_t></int32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int32_t[2][3] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT32_ARRAY_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT32_ARRAY_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,3</array>
      <int32_t></int32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int64_t[4] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT64_ARRAY_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT64_ARRAY_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <int64_t></int64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Scratch int64_t[2][2] attribute.
        Can be used by HWPs for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_INT64_ARRAY_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SCRATCH_INT64_ARRAY_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <int64_t></int64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>env: 1 = Awan/HWSimulator. 0 = Simics/RealHW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IS_SIMULATION</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IS_SIMULATION</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Which execution platform the HW Procedure is running on
        Some HWPs (e.g. special wakeup) use different registers for different
          platforms to avoid arbitration problems when multiple platforms do
          the same thing concurrently
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXECUTION_PLATFORM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXECUTION_PLATFORM</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        The manufacturing flags.
        This is a bitfield. Each bit is a flag and multiple flags can be set
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MNFG_FLAGS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MNFG_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0x0000000000000000</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Used to inidicate if a reconfigure loop is needed
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_RECONFIGURE_LOOP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>RECONFIGURE_LOOP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      CAS Write Latency.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DRAM_CWL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DRAM_CWL</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Delay due to the presence of a buffer, in number of clocks
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_RDIMM_BUFFER_DELAY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_RDIMM_BUFFER_DELAY</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Contains the settings for write/read reorder queue
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_REORDER_QUEUE_SETTING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_REORDER_QUEUE_SETTING</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Default value for 2N Mode from Signal Integrity.
      0x0 = Invalid Mode, 0x01 = 1N Mode , 0x02 = 2N Mode
      If value is set to 0x0 this indicate value was never
      initialized correctly.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_2N_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_2N_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[Dimm DQ PIN]
      The map from the Dual Inline Memory Module
      (DIMM) Data (DQ) Pin to the Module Package Data (DQ) Pinout
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_VPD_DQ_MAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_VPD_DQ_MAP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>72</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      F0RC0F - Command Latency Adder Control Word;
      Default value - 04. Values Range from 00 to 04.
      No need to calculate; User can override with desired experimental value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_DDR4_F0RC0F</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_DDR4_F0RC0F</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      CS to CMD/ADDR Latency.
      This is for DDR4 MRS4.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_CS_CMD_LATENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_CS_CMD_LATENCY</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      C/A Parity Latency Mode. This is for DDR4 MRS5.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_CA_PARITY_LATENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_CA_PARITY_LATENCY</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      F0RC02: Timing and IBT Control Word; Default value - 0x00.
      Values Range from 0-8. No need to calculate;
      User can override with desired experimental value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_DDR4_F0RC02</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_DDR4_F0RC02</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      F0RC03 - CA and CS Signals Driver Characteristics Control Word;
      Default value - 0x05 (Moderate Drive). Values Range from 00 to 0F.
      Has to be picked up from SPD byte 137, 1st Nibble for CS and CA.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_DDR4_F0RC03</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_DDR4_F0RC03</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      F0RC04 - ODT and CKE Signals Driver Characteristics Control Word;
      Default value - 0x05 (Moderate Drive).
      Values Range from 00 to 0F. Has to be picked up from SPD byte 137, 2nd Nibble for ODT and CKE.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_DDR4_F0RC04</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_DDR4_F0RC04</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      F0RC05 - Clock Driver Characteristics Control Word;
      Default value - 0x05 (Moderate Drive).
      Values Range from 00 to 0F. Has to be picked up from SPD byte 138, 2nd Nibble for CK.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_DDR4_F0RC05</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_DDR4_F0RC05</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Operating Voltage VDD and VrefCA Source Control Word;
      Read from ATTR_MSS_VOLT_VDDR. Default value - 14. Values Range from 00 to 15 decimal.
      No need to calculate; User can override with desired experimental value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_DDR4_F0RC0B</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_DDR4_F0RC0B</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      F0RC1x - Internal VrefCA Control Word;
      Default value - 00. Values Range from 00 to 3F.
      No need to calculate; User can override with desired experimental value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_DDR4_F0RC1X</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_DDR4_F0RC1X</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      F0RC7x: IBT Control Word;
      Default value - 00. Values Range from 00 to FF.No need to calculate.
      User can override with desired experimental value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_DDR4_F0RC7X</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_DDR4_F0RC7X</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      F1RC00: Data Buffer Interface Driver Characteristics Control Word;
      Default value - 00. Values Range from 00 to 0F. No need to calculate.
      User can override with desired experimental value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_DDR4_F1RC00</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_DDR4_F1RC00</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      F1RC00: Data Buffer Interface Driver Characteristics Control Word;
      Default value - 00. Values Range from 00 to 0F. No need to calculate;
      User can override with desired experimental value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_DDR4_F1RC02</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_DDR4_F1RC02</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      F1RC00: Data Buffer Interface Driver Characteristics Control Word.
      Default value - 00. Values Range from 00 to 0F. No need to calculate.
      User can override with desired experimental value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_DDR4_F1RC03</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_DDR4_F1RC03</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      F1RC00: Data Buffer Interface Driver Characteristics Control Word;
      Default value - 00. Values Range from 00 to 0F. No need to calculate.
      User can override with desired experimental value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_DDR4_F1RC04</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_DDR4_F1RC04</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      F1RC00: Data Buffer Interface Driver Characteristics Control Word.
      Default value - 00. Values Range from 00 to 0F. No need to calculate.
      User can override with desired experimental value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_DDR4_F1RC05</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_DDR4_F1RC05</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      To get the FAPI_POS to the equivilent of ATTR_POS, we need to normalize the fapi_pos value
      to the processor (stride across which ever processor we're on) and then add in the delta
      per processor as ATTR_POS isn't processor relative (delta is the total dimm on a processor)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_POS_METADATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_POS_METADATA</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DRAM Device Type.
      Decodes SPD byte 2.
      Created for use by attributes that need this data
      earlier than eff_config, such as c_str and the hypervisor.
      Not meant for direct HWP use. This is just an abstraction
      of any chip specific EFF_DRAM_GEN attribute.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DRAM_GEN_METADATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DRAM_GEN_METADATA</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Base Module Type.
      Decodes SPD Byte 3 (bits 3~0).
      Created for use by attributes that need this data
      earlier than eff_config, such as c_str and the hypervisor.
      Not meant for direct HWP use. This is just an abstraction
      of any chip specific EFF_DIMM_TYPE attribute.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_DIMM_TYPE_METADATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_DIMM_TYPE_METADATA</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      EDPL (Error Detection Per Lane) is a feature in the DL that adds some additional checks to
      the traffic going across the OpenCAPI link in order to better track which lanes are having issues.
      Note: EDPL must be set the same on both sides of the link. This attribute affects both the proc/mc
      side and the OCMB side.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OMI_EDPL_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OMI_EDPL_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      DRAM Device Type.
      Decodes SPD byte 2.
      Generation of memory: DDR3, DDR4.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_GEN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_GEN</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Base Module Type.
      Decodes SPD Byte 3 (bits 3~0).
      Type of DIMM: RDIMM, UDIMM, LRDIMM as specified by the JEDEC standard.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DIMM_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DIMM_TYPE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Hybrid Media.
      Decodes SPD Byte 3 (bits 6~4)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_HYBRID_MEMORY_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_HYBRID_MEMORY_TYPE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Hybrid.
      Decodes SPD Byte 3 (bit 7)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_HYBRID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_HYBRID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      OMI to DDR frequency ratio
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_HOST_TO_DDR_SPEED_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_HOST_TO_DDR_SPEED_RATIO</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      DRAM Density.
      Decodes SPD Byte 4 (bits 3~0).
      Total SDRAM capacity per die.
      For multi-die stacks (DDP, QDP, or 3DS), this represents
      the capacity of each DRAM die in the stack.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_DENSITY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_DENSITY</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Number of DRAM bank address bits.
      Actual number of banks is 2^N, where
      N is the number of bank address bits.
      Decodes SPD Byte 4 (bits 5~4).
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_BANK_BITS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_BANK_BITS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Bank Groups Bits.
      Decoded SPD Byte 4 (bits 7~6).
      Actual number of bank groups is 2^N,
      where N is the number of bank address bits.
      This value represents the number of bank groups
      into which the memory array is divided.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_BANK_GROUP_BITS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_BANK_GROUP_BITS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Column Address Bits.
      Decoded SPD Byte 5 (bits 2~0).
      Actual number of DRAM columns is 2^N,
      where N is the number of column address bits
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_COLUMN_BITS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_COLUMN_BITS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Row Address Bits.
      Decodes Byte 5 (bits 5~3).
      Number of DRAM column address bits.
      Actual number of DRAM rows is 2^N,
      where N is the number of row address bits
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_ROW_BITS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_ROW_BITS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Primary SDRAM Die Count.
      Decodes Byte 6 (bits 6~4).
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_PRIM_DIE_COUNT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_PRIM_DIE_COUNT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Primary SDRAM Package Type (bits 1~0).
      Decodes Byte 6.
      This byte defines the primary set of SDRAMs.
      Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_PRIM_STACK_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_PRIM_STACK_TYPE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Primary bus with (bits 1~0).
      Decodes Byte 13.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_PRIM_BUS_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_PRIM_BUS_WIDTH</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_PPR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_PPR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Soft Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_SOFT_PPR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_SOFT_PPR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Minimum RAS to CAS Delay Time
      in nck (number of clock cyles).
      Decodes SPD byte 25 (7~0) and byte 112 (7~0).
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TRCD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TRCD</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      SDRAM Row Precharge Delay Time
      in nck (number of clock cycles).
      Decodes SPD byte 26 (bits 7~0) and byte 121 (bits 7~0).
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TRP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TRP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Minimum Active to Precharge Delay Time
      in nck (number of clock cycles).
      Decodes SPD byte 27 (bits 3~0) and byte 28 (7~0).
      Each memory channel will have a value.
      creator: mss_eff_cnfg_timing
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TRAS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TRAS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Minimum Active to Active/Refresh Delay
      in nck (number of clock cyles).
      Decodes SPD byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120.
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TRC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TRC</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DDR4 Spec defined as Refresh Cycle Time (tRFC).
      SPD Spec refers it to the Minimum Refresh Recovery Delay Time.
      In nck (number of clock cyles).
      Decodes SPD byte 31 (bits 15~8) and byte 30 (bits 7~0) for tRFC1.
      Decodes SPD byte 33 (bits 15~8) and byte 32 (bits 7~0) for tRFC2.
      Decodes SPD byte 35 (bits 15~8) and byte 34 (bits 7~0) for tRFC4.
      Selected tRFC value depends on MRW attribute that selects refresh mode.
      For 3DS, The tRFC time to the same logical rank is defined as tRFC_slr and is
      specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TRFC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TRFC</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Minimum Four Activate Window Delay Time
      in nck (number of clock cycles).
      Decodes SPD byte 36 (bits 3~0) and byte 37 (bits 7~0).
      For 3DS, tFAW time to the same logical rank is defined as
      tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices only) and
      specificed as the value as for a monolithic DDR4 SDRAM
      equivalent density.
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TFAW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TFAW</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Minimum Activate to Activate Delay Time, different bank group
      in nck (number of clock cycles).
      Decodes SPD byte 38 (bits 7~0).
      For 3DS, The tRRD_S time to a different bank group in the
      same logical rank is defined as tRRD_slr and is
      specificed as the value as for a monolithic
      DDR4 SDRAM of equivalent density.
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TRRD_S</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TRRD_S</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Minimum Activate to Activate Delay Time, same bank group
      in nck (number of clock cycles).
      Decodes SPD byte 39 (bits 7~0).
      For 3DS, The tRRD_L time to the same bank group in the
      same logical rank is defined as tRRD_L_slr and is
      specificed as the value as for a monolithic
      DDR4 SDRAM of equivalent density.
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TRRD_L</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TRRD_L</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Minimum Activate to Activate Delay Time (different logical ranks)
      in nck (number of clock cycles).
      For 3DS, The tRRD_S time to a different logical rank is defined as tRRD_dlr.
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TRRD_DLR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TRRD_DLR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Minimum CAS to CAS Delay Time, same bank group
      in nck (number of clock cycles).
      Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0).
      This is for DDR4 MRS6.
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TCCD_L</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TCCD_L</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Minimum Write Recovery Time.
      Decodes SPD byte 41 (bits 3~0) and byte 42 (bits 7~0).
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TWR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TWR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Minimum Write to Read Time, different bank group
      in nck (number of clock cycles).
      Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0).
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TWTR_S</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TWTR_S</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Minimum Write to Read Time, same bank group
      in nck (number of clock cycles).
      Decodes byte 43 (7~4) and byte 45 (bits 7~0).
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TWTR_L</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TWTR_L</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Maximum Activate Window
      in nck (number of clock cycles).
      Decodes SPD byte 7 (bits 5~4).
      Depends on tREFI multiplier.
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TMAW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TMAW</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      SDRAM Device Width
      Decodes SPD Byte 12 (bits 2~0).
      Options: X4 (4 bits), X8 (8 bits), X16 (16 bits), X32 (32 bits).
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_WIDTH</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Total number of ranks in each DIMM.
      For monolithic and multi-load stack modules (SDP/DDP) this is the same as
      the number of package ranks per DIMM (SPD Byte 12 bits 5~3).

      For single load stack (3DS) modules this value represents the number
      of logical ranks per DIMM.
      Logical rank refers the individually addressable die in a 3DS stack
      and has no meaning for monolithic or multi-load stacked SDRAMs.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_LOGICAL_RANKS_PER_DIMM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_LOGICAL_RANKS_PER_DIMM</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Register Type
      Decodes SPD Byte 131
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_REGISTER_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_REGISTER_TYPE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      DRAM Manufacturer ID Code
      Decodes SPD Byte 350 and 351
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_MFG_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_MFG_ID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      DRAM Modlue Height
      Decodes SPD Byte 193
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_MODULE_HEIGHT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_MODULE_HEIGHT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Register Manufacturer ID Code
      Decodes SPD Byte 133 and 134
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_RCD_MFG_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_RCD_MFG_ID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Register Revision Number
      Decodes SPD Byte 135
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_REGISTER_REV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_REGISTER_REV</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM][DQ_NIBBLES]
      Package Rank Map
      Decodes SPD Byte 60 - 77 (Bits 7~6)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_PACKAGE_RANK_MAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_PACKAGE_RANK_MAP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,20</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM][DQ_NIBBLES]
      Nibble Map
      Decodes SPD Byte 60 - 77 (Bits 5~0) for DDR4
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_NIBBLE_MAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_NIBBLE_MAP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,20</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      DIMM Size, in GB Used in various locations
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DIMM_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DIMM_SIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Spare DRAM availability. Used in various locations and is computed in mss_eff_cnfg.
      Array indexes are [DIMM][RANK]
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DIMM_SPARE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DIMM_SPARE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      CAS Latency.
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_CL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_CL</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Controls if the given target has an MDS (managed DRAM solution)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_MDS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_MDS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      ARRAY[DIMM]
      Specifies the number of master ranks per DIMM.
      Represents the number of physical ranks on a DIMM.
      From SPD spec JEDEC Standard No. 21-C: Page 4.1.2.L-4.
      Byte 12 (Bits 5~3) Number of package ranks per DIMM.
      Package ranks per DIMM refers to the collections of devices
      on the module sharing common chip select signals.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_NUM_MASTER_RANKS_PER_DIMM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_NUM_MASTER_RANKS_PER_DIMM</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Bit wise representation of master ranks in each DIMM that are used for reads and writes.
      Used by PRD.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DIMM_RANKS_CONFIGED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DIMM_RANKS_CONFIGED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Average Refresh Interval (tREFI)
      in nck (number of clock cycles).
      This depends on MRW attribute that selects fine refresh mode (x1, x2, x4).
      From DDR4 spec (79-4A).

      For 3DS, the tREFI time to the same logical rank is defined as
      tRFC_slr1, tRFC_slr2, or tRFC_slr4.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TREFI</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TREFI</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Internal Read to Precharge Delay.
      From the DDR4 spec (79-4A).
      Each memory channel will have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TRTP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TRTP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Minimum Refresh Recovery Delay Time (different logical ranks)
      in nck (number of clock cyles).
      Selected tRFC value (tRFC_dlr1, tRFC_dlr2, or tRFC_dlr4)
      depends on MRW attribute that selects fine refresh mode (x1, x2, x4).
      For 3DS, The tRFC time to different logical ranks are defined as tRFC_dlr
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DRAM_TRFC_DLR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DRAM_TRFC_DLR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Frequency of this memory channel in MT/s (Mega Transfers per second)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_FREQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_FREQ</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_VOLT_VDDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_VOLT_VDDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DRAM VPP Voltage, each voltage rail would need to have a value.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_VOLT_VPP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_VOLT_VPP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      List of memory frequencies supported by the current system.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SUPPORTED_FREQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_SUPPORTED_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>1866,2133,2400,2667</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
          Indicates if the DIMM connected to this controller
          are in a planar configuration
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_MRW_IS_PLANAR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_MRW_IS_PLANAR</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>FALSE</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_port
        Set to below optimum value/ rate.
        On a per port basis
        Also used for emergency mode throttle FARB4Q_EMERGENCY_N
        Used to thermally protect the system in all supported environmental conditions when OCC is not functional
        Consumer: thermal_init, initfile
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>32</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Machine Readable Workbook Thermal Memory Power Limit
        Used to calculate throttles to be at or under the power limit
        Per DIMM basis
        KEY (0-19): In order
        DIMM_SIZE = bits 0-3,
        DIMM_GEN = 4-5,
        DIMM_TYPE = 6-7,
        DIMM_WIDTH = 8-10,
        DIMM_DENSITY = 11-13,
        DIMM_STACK_TYPE = 14-15,
        DRAM_MFGID = 16-18,
        DIMMS_PER_PORT = 19-20,
        Bits 21-32: Not used
        VALUE (bits 32-63) in cW:
        VMEM+VPP thermal power limit per DIMM = 32-63
        Consumers: eff_config_thermal and bulk_pwr_throttles
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>10</array>
      <uint64_t>
        <default>0xffffe000000006a4,0,0,0,0,0,0,0,0,0</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Machine Readable Workbook Power Curve Intercept for DIMM
        Used to get the VDDR and VDDR+VPP power curve for each DIMM
        Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT
        Key Value pair
        KEY (0-19): In order
        DIMM_SIZE = bits 0-3,
        DIMM_GEN = 4-5,
        DIMM_TYPE = 6-7,
        DIMM_WIDTH = 8-10,
        DIMM_DENSITY = 11-13,
        DIMM_STACK_TYPE = 14-15,
        DRAM_MFGID = 16-18,
        DIMMS_PER_PORT = 19-20,
        Bits 21-32: Not used
        VALUE (bits 32-63) in cW:
        VMEM power curve = 32-47
        VMEM+VPP power curve = 48-63
        Consumers: eff_config_thermal
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PWR_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PWR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>100</array>
      <uint64_t>
        <default>0xffffe00002CC03AE,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Machine Readable Workbook Power Curve Slope for DIMM
        Used to get the VDDR and VDDR+VPP power curve for each DIMM
        Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT
        Key Value pair
        KEY (0-19): In order
        DIMM_SIZE = bits 0-3,
        DIMM_GEN = 4-5,
        DIMM_TYPE = 6-7,
        DIMM_WIDTH = 8-10,
        DIMM_DENSITY = 11-13,
        DIMM_STACK_TYPE = 14-15,
        DRAM_MFGID = 16-18,
        DIMMS_PER_PORT = 19-20,
        Bits 21-32: Not used
        VALUE (bits 32-63) in cW:
        VMEM power curve = 32-47
        VMEM+VPP power curve = 48-63
        Consumers: eff_config_thermal
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PWR_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PWR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>100</array>
      <uint64_t>
        <default>0xffffe00003FD0546,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Machine Readable Workbook Refresh Rate
        Desired refresh interval used in refresh register 0, MBAREF0Q_CFG_REFRESH_INTERVAL
        7.8 us (SINGLE)
        3.9 us (DOUBLE)
        7.02 us (SINGLE_10_PERCENT_FASTER)
        3.51 us (DOUBLE_10_PERCENT_FASTER)
   </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_REFRESH_RATE_REQUEST</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_REFRESH_RATE_REQUEST</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Machine Readable Workbook DIMM power curve percent uplift
      for this system at max utilization.
      Value should be 0 for ISDIMMs
   </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Machine Readable Workbook DIMM power curve percent uplift
      for this system at idle utilization.
      Value should be 0 for ISDIMMs
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Machine Readable Workbook for the number of M DRAM clocks.
      One approach to curbing DRAM power usage is by throttling
      traffic through a programmable N commands over M window.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MEM_M_DRAM_CLOCKS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x00000200</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Machine Readable Workbook value for maximum dram data bus utilization in centi percent (c%).
      Used to determine memory throttle values.
      Max databus utilization on a per port basis
      Default to 90%
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MAX_DRAM_DATABUS_UTIL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x00002328</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Memory power control settings programmed during IPL
        Used by OCC when exiting idle power-save mode
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_POWER_CONTROL_REQUESTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Memory power control settings for IDLE powersave mode
        Used by OCC when entering idle power-save mode
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Machine Readable Workbook enablement of the HWP code to adjust the
      VMEM regulator power limit based on number of installed DIMMs.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Machine Readable Workbook VMEM regulator power limit per CDIMM assuming a full configuration. Units in cW
        Used for Cumulus
        Consumed in mss_eff_config_thermal
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Machine Readable Workbook VMEM regulator power limit per DIMM assuming a full configuration. Units in cW
        Consumed in mss_eff_config_thermal
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x000006A4</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Machine Readable Workbook value for the maximum possible number
      of dimms that can be installed under any of the VMEM regulators.
      Consumed in eff_config_thermal to calculate mem_watt_target
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Used for to determine whether to apply an offset to AVDD. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_AVDD_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_AVDD_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Used for to determine whether to apply an offset to VDD. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VDD_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VDD_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VCS_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VCS_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VPP_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VPP_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Used for to determine whether to apply an offset to VDDR. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VDDR_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VDDR_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Fine refresh mode.
      Sets DDR4 MRS3.
      ZZ uses normal mode.
      From JEDEC DDR4 Spec 1716.78C from 07-2016
      Page 47 Table 4.9.1
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_FINE_REFRESH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_FINE_REFRESH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>NORMAL</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Temperature refresh range.
      Sets DDR4 MRS4.
      Should be defaulted to extended range.
      NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less degrees C
      Used for calculating periodic refresh intervals
      JEDEC DDR4 spec 1716.78C from 07-2016
      page 46 4.8.1
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_TEMP_REFRESH_RANGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_TEMP_REFRESH_RANGE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>For resetting the phy delay values at the beginning of calling mss_draminit_training. YES means the vaules will be reset.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>YES</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Describes the settings for periodic calibration for all ports:
      Reading left to right. (DEFAULT: 0xD90C -&gt; Byte 0(11011001), Byte 1(00001100))
      For each bit: OFF = 0, ON = 1. Setting to 0 indicates to disable periodic memcal.
      Byte 0:
      0: ZCAL
      1: SYSCK_ALIGN
      2: RDCENTERING
      3: RDLCK_ALIGN
      4: DQS_ALIGN
      5: RDCLK_UPDATE
      6: PER_DUTYCYCLE
      7: PERCAL_PWR_DIS

      Byte 1:
      0: PERCAL_REPEAT
      1: PERCAL_REPEAT
      2: PERCAL_REPEAT
      3: SINGLE_BIT_MPR
      4: MBA_CFG_0
      5: MBA_CFG_1
      6: SPARE
      7: SPARE
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0xD90C</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Describes the settings for periodic ZQ calibration for all ports:
      Reading left to right. For each bit: OFF = 0, ON = 1.
      Setting to 0 indicates to disable periodic zqcal.
      Byte 0:
      0: ZQCAL
      All others reserved for future use
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0x8000</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Allows user to manually turn on and off 2N Mode.
      AUTO indicates to use Signal Integrity generated setting (from VPD).
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DRAM_2N_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DRAM_2N_MODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>AUTO</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description> Enables DRAM Write CRC</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DRAM_WRITE_CRC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DRAM_WRITE_CRC</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Used in MR4 A3
        Temperature refresh mode
        Should be defaulted to disable
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_TEMP_REFRESH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        An override switch to shut off broadcast mode
        Enum values:
        YES: broadcast mode is forced off
        NO:  broadcast mode uses the default value
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_FORCE_BCMODE_OFF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_FORCE_BCMODE_OFF</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        A bitmap containing the plug rules for NVDIMM.
        1 if a DIMM supports an NVDIMM being plugged in, 0 if it does not
        DIMM slot 0 is the left most bit
        The index to the bitmap is the position of the DIMM target
        As such, a bitmap of 0b10010000, would allow NVDIMM plugged into DIMM0 and DIMM3
        Note: this attribute is a 64 bit number to account for 16 DIMM per processor if there is ever a 4 processor system
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_NVDIMM_PLUG_RULES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_NVDIMM_PLUG_RULES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default> 0 </default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Switch that allows unsupported raw card references by providing a
      default raw card setting.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_ALLOW_UNSUPPORTED_RCW</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default> 1  </default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Bitmap of DRAM widths supported by a system. A 1 indicates that the system supports a density.
      Enums below represent the the bit location in the attribute for a given DRAM width.
      Default value is 0xC -&gt; both x4/x8 supported
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_SUPPORTED_DRAM_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default> 0xc0 </default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Machine Readable Workbook Thermal Memory Power Limit
        Used to calculate throttles to be at or under the power limit
        Per DIMM basis
        KEY (0-21): In order
        DIMM_SIZE = bits 0-3,
        DIMM_GEN = 4-5,
        DIMM_TYPE = 6-8,
        DIMM_WIDTH = 9-11,
        DIMM_DENSITY = 12-14,
        DIMM_STACK_TYPE = 15-16,
        DRAM_MFGID = 17-19,
        DIMM_HEIGHT = 20-21,
        Bits 22-32: Not used
        VALUE (bits 32-47) in cW:
        OCMB+DRAM thermal power limit per DIMM = 32-47
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>25</array>
      <uint64_t>
        <default>0xfffffc07940000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Machine Readable Workbook Power Curve Slope for DIMM
        Used to get the OCMB+DRAM power curve for each DIMM
        Per DIMM basis
        KEY (0-21): In order
        DIMM_SIZE = bits 0-3,
        DIMM_GEN = 4-5,
        DIMM_TYPE = 6-8,
        DIMM_WIDTH = 9-11,
        DIMM_DENSITY = 12-14,
        DIMM_STACK_TYPE = 15-16,
        DRAM_MFGID = 17-19,
        DIMM_HEIGHT = 20-21,
        Bits 22-32: Not used
        VALUE (bits 32-47) in cW/utilization:
        OCMB+DRAM thermal power limit per DIMM = 32-47
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OCMB_PWR_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_OCMB_PWR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>50</array>
      <uint64_t>
        <default>0xfffffc00044C0000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Machine Readable Workbook Power Curve Intercept for DIMM
        Used to get the OCMB+DRAM power curve for each DIMM
        Per DIMM basis
        KEY (0-21): In order
        DIMM_SIZE = bits 0-3,
        DIMM_GEN = 4-5,
        DIMM_TYPE = 6-8,
        DIMM_WIDTH = 9-11,
        DIMM_DENSITY = 12-14,
        DIMM_STACK_TYPE = 15-16,
        DRAM_MFGID = 17-19,
        DIMM_HEIGHT = 20-21,
        Bits 22-32: Not used
        VALUE (bits 32-47) in cW/utilization:
        OCMB+DRAM thermal power limit per DIMM = 32-47
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OCMB_PWR_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_OCMB_PWR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>50</array>
      <uint64_t>
        <default>0xfffffc00044C0000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Machine Readable Workbook Power Curve Intercept and limit for DIMM
        Used to get the PMIC power curve and limit for each DIMM
        Per DIMM basis
        KEY (0-21): In order
        DIMM_SIZE = bits 0-3,
        DIMM_GEN = 4-5,
        DIMM_TYPE = 6-8,
        DIMM_WIDTH = 9-11,
        DIMM_DENSITY = 12-14,
        DIMM_STACK_TYPE = 15-16,
        DRAM_MFGID = 17-19,
        DIMM_HEIGHT = 20-21,
        Bits 22-32: Not used
        VALUE (bits 32-39): Current limit (dA)
        VALUE (bits 40-51): Current slope (cA/utilization)
        VALUE (bits 52-63): Current intercept (cA)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>25</array>
      <uint64_t>
        <default>0xfffffc0000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Machine Readable Workbook value for safe mode dram data bus utilization in centi percent (c%).
        Set to below optimum value/ rate.
        On a per port basis
        Also used for emergency mode throttle
        Used to thermally protect the system in all supported environmental conditions when OCC is not functional
        Consumer: thermal_init, initfile
        Default to 2500 c%%
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x000009C4</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
            Hash Signature for SI settings from SPD. The hash signature is 32bits for 256 bytes of data.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_SIGNATURE_HASH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_SIGNATURE_HASH</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Array[DIMM] Register Clock Driver, Input Bus Termination for Command/Address in tens of Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_DIMM_RCD_IBT_CA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_DIMM_RCD_IBT_CA</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Array[DIMM] Register Clock Driver, Input Bus Termination for Clock Enable in tens of Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_DIMM_RCD_IBT_CKE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_DIMM_RCD_IBT_CKE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Array[DIMM] Register Clock Driver, Input Bus Termination for Chip Select in tens of Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_DIMM_RCD_IBT_CS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_DIMM_RCD_IBT_CS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Array[DIMM] Register Clock Driver, Input Bus Termination for On Die Termination in tens of Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_DIMM_RCD_IBT_ODT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_DIMM_RCD_IBT_ODT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          DQ and DQS Drive Impedance.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_DRAM_DRV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_DRAM_DRV_IMP_DQ_DQS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Number of clocks used for read/write preamble. Calibration only uses 1 nCK preamble (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble option.
          The value of &quot;0&quot; means 1 nCK preamble, the value of &quot;1&quot; means 2 nCK preamble. Bit 3 for READ preamble, and Bit 7 for WRITE preamble.
          E.g. 0b00010001 means 2 nCK preamble for both READ and WRITE
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_DRAM_PREAMBLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_DRAM_PREAMBLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          DRAM side Nominal Termination Resistance in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_DRAM_RTT_NOM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_DRAM_RTT_NOM</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          DRAM side Park Termination Resistance in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_DRAM_RTT_PARK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_DRAM_RTT_PARK</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          DRAM side Write Termination Resistance in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_DRAM_RTT_WR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_DRAM_RTT_WR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        ARRAY[DIMM][RANK]
        vrefdq_train value. This is for DDR4 MRS6.
      </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_VREF_DQ_TRAIN_VALUE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_VREF_DQ_TRAIN_VALUE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        ARRAY[DIMM][RANK]
        vrefdq_train range. This is for DDR4 MRS6.
      </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_VREF_DQ_TRAIN_RANGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_VREF_DQ_TRAIN_RANGE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        ARRAY[DIMM][RANK]
        Gear Down Mode.
        This is for DDR4 MRS3.
        Each memory channel will have a value.
      </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_GEARDOWN_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_GEARDOWN_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Tx drive impedance for DQ/DQS of all ranks in ohms
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_DRV_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_DRV_DQ_DQS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Receiver Equalization for Data and Data Strobe Lines.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_RCV_EQ_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_RCV_EQ_DQ_DQS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Drive Equalization for Data and Data Strobe Lines.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_DRV_EQ_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_DRV_EQ_DQ_DQS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Drive Impedance for Clock in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_DRV_IMP_CLK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_DRV_IMP_CLK</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Drive Impedance for Address, Bank Address, Bank Group and Activate Lines in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_DRV_IMP_CMD_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_DRV_IMP_CMD_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Drive Impedance for Clock Enable, ODT, Parity, and Reset Lines in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_DRV_IMP_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_DRV_IMP_CNTL</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Drive Impedance for Chip Select and Chip ID Lines in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_DRV_IMP_CSCID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_DRV_IMP_CSCID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Drive Impedance Pull Down for Data and Data Strobe Lines in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Drive Impedance Pull Up for Data and Data Strobe Lines in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Drive Slew Rate for Clock in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_DRV_SLEW_RATE_CLK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_DRV_SLEW_RATE_CLK</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Drive Slew Rate for Address, Bank Address, Bank Group and Activate Lines in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Drive Slew Rate for Clock Enable, ODT, Parity, and Reset Lines in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_DRV_SLEW_RATE_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_DRV_SLEW_RATE_CNTL</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Drive Slew Rate for Chip Select and Chip ID Lines in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_DRV_SLEW_RATE_CSCID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_DRV_SLEW_RATE_CSCID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Drive Slew Rate for Data and Data Strobe Lines in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Memory Controller side Receiver Impedance. Alert_N line in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_RCV_IMP_ALERT_N</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_RCV_IMP_ALERT_N</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          Memory Controller side Receiver Impedance. Data and Data Strobe Lines in Ohms.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_MC_RCV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_MC_RCV_IMP_DQ_DQS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          READ, On Die Termination triggering bitmap. Use bitmap to determine which ODT to fire for the designated rank.
          The bits in 8 bit field are
          [DIMM0 ODT0][DIMM0 ODT1][DIMM0 ODT2][DIMM0 ODT3][DIMM1 ODT0][DIMM1 ODT1][DIMM1 ODT2][DIMM1 ODT3]
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_ODT_RD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_ODT_RD</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Array[DIMM][RANK]
          WRITE, On Die Termination triggering bitmap. Use bitmap to determine which ODT to fire for the designated rank.
          The bits in 8 bit field are
          [DIMM0 ODT0][DIMM0 ODT1][DIMM0 ODT2][DIMM0 ODT3][DIMM1 ODT0][DIMM1 ODT1][DIMM1 ODT2][DIMM1 ODT3]
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_ODT_WR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_ODT_WR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            DRAM side Write Vref setting for DDR4. Bit encode is 01234567. Bit 0 is unused. Bit 1 is the Range. Bits 2-7 is the Value. Refer to the VrefDQ Training Table in JEDEC.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_VREF_DRAM_WR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_VREF_DRAM_WR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Memory Controller side Read Vref setting. Dividing by 1000 gives you percentage of Vdd. Disable = 0, defined as no HW adjustment or Vdd/2 if possible.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_VREF_MC_RD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_VREF_MC_RD</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Derived from calibration/characterization of read centering. Number of windage offset in units of pico-seconds[ps]. Default is 0 for no windage adjustment.
            Specification of the value in this file is 2's compliment hex
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_SI_WINDAGE_RD_CTR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_SI_WINDAGE_RD_CTR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <int16_t></int16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Indicates whether the OCMB can support enterprise mode or
            if it has been fused to only support non-enterprise mode.
            Note: needs to be setup by the get ECID functionality
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_ENTERPRISE_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_ENTERPRISE_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Indicates whether the OCMB is allowed to run in enterprise
            mode, commodity mode, or either.

            ALLOW_ENTERPRISE = Most permissive, uses whatever is installed in
               the way it is intended to be used.
            REQUIRE_ENTERPRISE = Throws an error for any commodity dimms that
               are installed.
            FORCE_NONENTERPRISE = Throws an error for any enterprise dimms that
               are installed.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_ENTERPRISE_POLICY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_ENTERPRISE_POLICY</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>ALLOW_ENTERPRISE</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
            An override to allow an enterprise capable DIMM to be run in non-enterprise mode.
            Defaults to NO_OVERRIDE
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Indicates whether the OCMB should be run in half DIMM mode or not
            Note: needs to be setup by the get ECID functionality
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_HALF_DIMM_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_HALF_DIMM_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            An override that allows the user to control full or half DIMM mode
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_HALF_DIMM_MODE_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_HALF_DIMM_MODE_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Mark store records from OCMB VPD. The array dimension is [port][mark].
          Explorer only has one port so only [0][mark] is used in explorer.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MEM_MVPD_FWMS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MEM_MVPD_FWMS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Indicate presence of DRAM at each Chip Select for PHY
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EXP_CS_PRESENT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EXP_CS_PRESENT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
           Initial VrefDQ setting before training
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EXP_INIT_VREF_DQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EXP_INIT_VREF_DQ</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
           Initial DQ Vref setting of PHY before training
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EXP_INIT_PHY_VREF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EXP_INIT_PHY_VREF</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
           CA and CS signal Driver Characteristics from F0RC03, F0RC04, F0RC05
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EXP_RCD_DIC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EXP_RCD_DIC</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
           RCD operating voltage VDD and VrefCA control from F0RC0B and F0RC1x
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EXP_RCD_VOLTAGE_CTRL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EXP_RCD_VOLTAGE_CTRL</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Ranks that have address mirroring.
            This data is derived from SPD or VPD.
            Note: This is a bit-wise map and muliple ranks can be mirrored.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EXP_DRAM_ADDRESS_MIRRORING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EXP_DRAM_ADDRESS_MIRRORING</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            RCD slew rate control from F1RC02,F1RC03,F1RC04,F1RC05
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EXP_RCD_SLEW_RATE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EXP_RCD_SLEW_RATE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Explorer setting for 3DS stack
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EXP_3DS_HEIGHT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EXP_3DS_HEIGHT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Cas Latency Supported by DRAM
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EXP_SPD_CL_SUPPORTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EXP_SPD_CL_SUPPORTED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Minimum Cas Latency Time (tAAmin) in Picosecond (Byte 24)
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EXP_SPD_TAA_MIN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EXP_SPD_TAA_MIN</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Contains the settings for write/read reorder queue
      </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_EXP_REORDER_QUEUE_SETTING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_EXP_REORDER_QUEUE_SETTING</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>REORDER</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Enable Special mode for Emulation Support
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EXP_FIRMWARE_EMULATION_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EXP_FIRMWARE_EMULATION_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Controls whether or not transaction bytes are
          swapped before and after mmio accesses to
          the buffer.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Controls whether the structure fields written
          and read to and from the buffer are big
          or little endian.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_STRUCT_ENDIAN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_EXP_STRUCT_ENDIAN</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            ECID of the chip as determined by the IPL getecid procedure.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_ECID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_ECID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>14</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            timing parameter for the DFIMRL clock
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EXP_DFIMRL_CLK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EXP_DFIMRL_CLK</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          ARRAY[ADDRESS INDEX]
          ATxDly_A/B[0]: ODT[1],ODT[0],CS_N[0],CS_N[1]
          ATxDly_A/B[1]: ADDR[13],ADDR[5],BG[0],CKE[1]
          ATxDly_A/B[2]: ADDR[17],ADDR[7],BA[0],ADDR[16]
          ATxDly_A/B[3]: ADDR[8],BG[1],CID[1],CID[0]
          ATxDly_A/B[4]: ADDR[1],ADDR[9],ADDR[2],CAPARITY
          ATxDly_A/B[5]: ADDR[12],ADDR[3],ADDR[4],ADDR[0]
          ATxDly_A/B[6]: CKE[0],ADDR[15],ACT_N,ADDR[10]
          ATxDly_A/B[7]: ADDR[11],ADDR[6],BA[1],ADDR[14]
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_ATXDLY_A</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_ATXDLY_A</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          ARRAY[ADDRESS INDEX]
          ATxDly_A/B[0]: ODT[1],ODT[0],CS_N[0],CS_N[1]
          ATxDly_A/B[1]: ADDR[13],ADDR[5],BG[0],CKE[1]
          ATxDly_A/B[2]: ADDR[17],ADDR[7],BA[0],ADDR[16]
          ATxDly_A/B[3]: ADDR[8],BG[1],CID[1],CID[0]
          ATxDly_A/B[4]: ADDR[1],ADDR[9],ADDR[2],CAPARITY
          ATxDly_A/B[5]: ADDR[12],ADDR[3],ADDR[4],ADDR[0]
          ATxDly_A/B[6]: CKE[0],ADDR[15],ACT_N,ADDR[10]
          ATxDly_A/B[7]: ADDR[11],ADDR[6],BA[1],ADDR[14]
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_ATXDLY_B</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_ATXDLY_B</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          ARRAY[DIMM]
          This byte defines the allowed number of
          P-States for the DDR4 Differential Memory Buffer.
          P-States can be thought of as an available performance profile.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_PSTATES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_PSTATES</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          ARRAY[DIMM]
          These bits are used to activate or deactivate bytes in the
          DDR interface of the differential memory
          buffer chip.
          Right aligned data.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_BYTE_ENABLES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_BYTE_ENABLES</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          ARRAY[DIMM]
          These bits are used to select the active nibbles or DQS on the DDR interface.
          Right aligned data.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_NIBBLE_ENABLES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_NIBBLE_ENABLES</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          ARRAY[DIMM]
          A-Side CA bus drives rank 0/1
          and B-Side CA bus drives rank 2/3, DQ/DQS are
          shared across the ranks
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_FOUR_RANK_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_FOUR_RANK_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          ARRAY[DIMM]
          MRAM Support
          Support timing parameters of Everspin DDR4 MRAM
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_MRAM_SUPPORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_MRAM_SUPPORT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          ARRAY[DIMM]
          DDP Compatibility
          Support 1 rank 3DS Device in DDP board routing.  CKE[1], CSN[1], ODT[1] of
          PHY are connected to C[0], C[1], C[2] of DRAM
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_DDP_COMPATIBILITY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_DDP_COMPATIBILITY</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          ARRAY[DIMM]
          TSV 8H Support
          Support 8H 3DS routing in board routing when parity check is disabled
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_EFF_TSV_8H_SUPPORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_EFF_TSV_8H_SUPPORT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
         Enable Explorer upstream transmit template 1.
         Should be disabled by default.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_ENABLE_US_TMPL_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_ENABLE_US_TMPL_1</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>DISABLED</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
         Enable Explorer upstream transmit template 5.
         Should be enabled by default.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_ENABLE_US_TMPL_5</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_ENABLE_US_TMPL_5</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>ENABLED</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
         Enable Explorer upstream transmit template 9.
         Should be enabled by default.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_ENABLE_US_TMPL_9</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_ENABLE_US_TMPL_9</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>ENABLED</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
         Enable Explorer upstream transmit template A.
         Not supported by Axone
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_ENABLE_US_TMPL_A</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_ENABLE_US_TMPL_A</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>DISABLED</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
         Enable Explorer upstream transmit template B.
         Not supported by Axone
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_ENABLE_US_TMPL_B</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_ENABLE_US_TMPL_B</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>DISABLED</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Template 0 pacing
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_TMPL_0_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_TMPL_0_PACING</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0xF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Template 1 pacing
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_TMPL_1_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_TMPL_1_PACING</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Template 5 pacing
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_TMPL_5_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_TMPL_5_PACING</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Template 9 pacing
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_TMPL_9_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_TMPL_9_PACING</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Template B pacing
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_TMPL_B_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_TMPL_B_PACING</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Short back-off timer value.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_SHRT_BACKOFF_TIMER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_SHRT_BACKOFF_TIMER</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
     Enable OpenCAPI metadata
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_METADATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_METADATA_ENABLE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
     The PASID base
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_PASID_BASE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_PASID_BASE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
     The desired actag base
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_ACTAG_BASE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_ACTAG_BASE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      The expected number of actags to be supported by the ocmb.
      Must be 1 for Explorer
      Validate via OCTRLTAG
      10518  OCTRLTAG_AFU_ACTAG_LENGTH_SUPPORTED
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_AFU_ACTAG_LEN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_AFU_ACTAG_LEN</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x1</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      The expected number of PASIDs to be supported by the ocmb.
      Number of consecutive PASIDs this AFU supports is 2^pasid_length_supported
      Validate via OPASID
      10100  OPASID_MAX_PASID_WIDTH
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXPLR_PASID_LEN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXPLR_PASID_LEN</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
            Indicates the FW MODE of the OCMB
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
            Indicates wheather to enable the loopback test
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
            The transport layer of OCMB
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
            Indicates whether the OpenCAPI DL boots immediately
            or waits for host command.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
            Set to disable DFE
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
            The lane width of the OpenCapi channel
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
            The frequency of the OpenCAPI
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>3</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
          This is the throttled N commands per window
          of M DRAM clocks setting for cfg_nm_n_per_port.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>This is the throttle numerator setting for cfg_nm_n_per_slot</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_MEM_THROTTLED_N_COMMANDS_PER_SLOT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Runtime throttled N commands per
          M DRAM clocks setting for cfg_nm_n_per_port.
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Runtime throttle numerator setting for cfg_nm_n_per_slot</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Safe mode throttle value for numerator cfg_nm_n_per_port
          Set to below optimum value/ rate.
          On a per port basis
          Also used for emergency mode throttle MBA_FARB4Q_EMERGENCY_N
          Used to thermally protect the system in all supported environmental conditions when OCC is not functional
      </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>32</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Runtime for M DRAM clocks setting for cfg_nm_m</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_RUNTIME_MEM_M_DRAM_CLOCKS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_RUNTIME_MEM_M_DRAM_CLOCKS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          This is the fapi position of the port that failed to calculate
          memory throttles given the passed in watt target and or utilization
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_MEM_PORT_POS_OF_FAIL_THROTTLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_MEM_PORT_POS_OF_FAIL_THROTTLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          Total memory power used to throttle for each dimm
          Used to compute the throttles on the channel and/or dimms for OCC
          OCC sets after IPL
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_MEM_WATT_TARGET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_MEM_WATT_TARGET</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            VDDR+VPP Power slope value for dimm
            creator: mss_eff_config
            consumer: mss_bulk_pwr_throttles
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_TOTAL_PWR_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_TOTAL_PWR_SLOPE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            VDDR+VPP Power intercept value for dimm
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_TOTAL_PWR_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_TOTAL_PWR_INTERCEPT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Databus utilization per port limit used to calculate memory throttles and power limit
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_DATABUS_UTIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_DATABUS_UTIL</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Channel Pair Max Power output from thermal procedures</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_PORT_MAXPOWER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_PORT_MAXPOWER</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            DIMM Max Power based on a thermal limit
            Decoded from ATTR_MSS_MRW_THERMAL_POWER_LIMIT
        </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_DIMM_THERMAL_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXP_DIMM_THERMAL_LIMIT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The frequency of a processor's nest mesh clock, in MHz.
    This is the same for all chips in the system.
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PB_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PB_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The frequency of a processor's Xbus mesh clocks, in MHz.
    This is the same for all chips in the system.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_X_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_X_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>2000</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>MC mesh to use Nest mesh or not</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MC_SYNC_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MC_SYNC_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>EQ boot frequency</description>
    <hwpfToHbAttrMap>
      <id>ATTR_BOOT_FREQ_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BOOT_FREQ_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>2400</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Select Nest I2C and pll setting from one of the supported frequencies</description>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_PLL_BUCKET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NEST_PLL_BUCKET</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x05</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>HWP/Init &quot;risk level&quot; enabled. Used by HB to pass to HB driven
      HWPs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_RISK_LEVEL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>RISK_LEVEL</id>
    <no_export></no_export>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Indicates if LPC console is enabled on system</description>
    <hwpfToHbAttrMap>
      <id>ATTR_LPC_CONSOLE_CNFG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>LPC_CONSOLE_CNFG</id>
    <no_export></no_export>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>DISABLE</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
  Switch to enable or disable Power Management Complex FFDC collection to HOMER.
  When set, the PM Complex Reset flow will collect PM Complex data to the chip
  HOMER region to assist with failure analysis and recovery.

  Producer: HB must set or reset this based on the platform use-case and state.
  Consumer: p9_pm_reset.C, p9_pm_callout.C
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_RESET_FFDC_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_RESET_FFDC_ENABLE</id>
    <no_export></no_export>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Effective fabric group ID associated with this chip.
    Directly drives programming of chip memory map layout.
    Compared with ATTR_PROC_FABRIC_GROUP_ID to configure FBC XOR masking.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_EFF_FABRIC_GROUP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_EFF_FABRIC_GROUP_ID</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Bit mask of group IDs which will be present in the fully configured
    CEC configuration.
      Bit 0 -&gt; group 0 present
      Bit 1 -&gt; group 1 present
      ...
      Bit 6 -&gt; group 6 present
      Bit 7 -&gt; group 7 present
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FABRIC_PRESENT_GROUPS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FABRIC_PRESENT_GROUPS</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Hostboot load address, in bytes, for a given node, replicated
        for each processor within a node.  A value of 0xFFFFFFFFFFFFFFFF
        implies the Hostboot load address is invalid and should be ignored.
        Hostboot is responsible for updating the load address to a valid
        value on every boot, and invalidating it just prior to shutdown.
        Used by p9_query_host_meminfo as a backup in case Hostboot's core
        scratch register is unavailable.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_HB_HRMOR_BYTES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>HB_HRMOR_BYTES</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Effective fabric chip ID associated with this chip.
    Directly drives programming of chip memory map layout.
    Compared with ATTR_PROC_FABRIC_CHIP_ID to configure FBC XOR masking.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_EFF_FABRIC_CHIP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_EFF_FABRIC_CHIP_ID</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    The frequency of a processor's Obus mesh clocks, in MHz.
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_O_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_O_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>1611,1611,1611,1611</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>This attribute denotes where our master proc's memory is
    located. In the case that the master-proc does not have usable memory,
    we are going to use another proc's memory to boot. The attribute will be
    set to the chip and group ID of which proc we want to use.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_TO_USE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_MEM_TO_USE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Capturing EQ Gard value</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EQ_GARD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EQ_GARD</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Capturing EC Gard Value</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EC_GARD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EC_GARD</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Per-link optics configuration
    0 = default = SMP
    1 = CAPI 2.0
    2 = NV 2.0
    3 = OPENCAPI
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_OPTICS_CONFIG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OPTICS_CONFIG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>NV</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Processor SMP Fabric broadcast scope configuration.
    CHIP_IS_NODE = MODE1 = default
    CHIP_IS_GROUP = MODE2
    Provided by the MRW.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_PUMP_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_PUMP_MODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    [PORT][Dimm DQ PIN]  The map from the Dual Inline Memory Module (DIMM) Data (DQ) Pin to the Module Package Data (DQ) Pinout
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_DQ_MAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_VPD_DQ_MAP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,72</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Spare DRAM availability. Used in various locations and is computed in mss_eff_cnfg.
      creator: mss_eff_cnfg consumer: various firmware notes: load from spd
      OBSOLETE: Use ATTR_VPD_DIMM_SPARE
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_SPARE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_DIMM_SPARE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2,4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
     A bit vector denoting bits in every DP16 on the port to be calibrated.
     That is, all of the set bits will be calibrated for all DP16. A value
     of zero indicates the calibration should not be run.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_RDVREF_CAL_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_RDVREF_CAL_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    In sub DD1.02 Nimbus the HW VREF calibrations should not be run
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SKIP_HW_VREF_CAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SKIP_HW_VREF_CAL</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    In sub DD1.03 Nimbus the HW VREF calibrations should not be run
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SKIP_RD_VREF_VREFSENSE_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SKIP_RD_VREF_VREFSENSE_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x1</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Set equal to 1 to disable setting of RTT_NOM to use RTT_WR values
    during WR_LEVEL calibration.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_RTT_NOM_OVERRIDE_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
   Time between invocations of the 24x7 performance collection function on
   GPE1.  The time (in milliseconds) is derived as  2^PERF_24x7_INVOCATION_TIME_MS
   with 0 indicating the function is OFF.

   Consumer: p9_hcode_image_build.c -&gt;
                SGPE Header field

   Provided by the Machine Readable Workbook to tune the collection.

   Platform default:  1
   </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PERF_24x7_INVOCATION_TIME_MS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PERF_24x7_INVOCATION_TIME_MS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
   Enables the SGPE Hcode to enable the CME instruction traces into the L3
   Trace array for debug.  Note:  all configured CMEs will be put into this
   mode if this attribute is ON.

   Consumer: p9_hcode_image_build.c -&gt;
                SGPE Header field

   Platform default:  OFF
   </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_INSTRUCTION_TRACE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CME_INSTRUCTION_TRACE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>

   Enables pstate parameter block code to use the static system vfrt data
   Consumer: p9_pstate_parameter_block.C -&gt;

   Platform default:  OFF
   
   </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS_VFRT_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYS_VFRT_STATIC_DATA_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Flags to indicate if rx / tx dccal has been run.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_DCCAL_FLAGS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OBUS_DCCAL_FLAGS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicate if debug data should be taken pre / post linktraining.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_DEBUG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_DEBUG</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Value to select amount of margin to be applied.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_MARGIN_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OBUS_TX_MARGIN_RATIO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Value to select amount of tx ffe precusor to apply.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_FFE_PRECURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OBUS_TX_FFE_PRECURSOR</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Value to select amount of tx ffe postcusor to apply.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_FFE_POSTCURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OBUS_TX_FFE_POSTCURSOR</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Override PHY rank group settings. The two uint16 values map to rank
      group0/1(Pri/Sec ranks) for unt16[X][0] and rank group2/3(Pri/Sec ranks)
      for uint16[X][1]. Bits map as follows: uint16[X][0]: (0:2)=RP0_primary,
      (3)=RP0_primary_valid, (4:6)=RP0_secondary, (7)=RP0_secondary_valid,
      (8:10)=RP1_primary, (11)=RP1_primary_valid, (12:14)=RP1_secondary,
      (15)=RP1_secondary_valid, uint16[X][1]: (0:2)=RP2_primary,
      (3)=RP2_primary_valid, (4:6)=RP2_secondary, (7)=RP2_secondary_valid,
      (8:10)=RP3_primary, (11)=RP3_primary_valid, (12:14)=RP3_secondary,
      (15)=RP3_secondary_valid. Note: that the DIMM1 ranks in a dual-drop
      config are stored in the attribute as the centaur canonical number (4,5).
      The code will automatically do the conversion from the Centaur canonical
      to the correct PHY nomenclature (2,3 for 4,5 respectively). Set this
      attribute to zero to use default settings.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_RANK_GROUP_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EFF_RANK_GROUP_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2,2</array>
      <uint16_t>
        <default>0x0</default>
      </uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicate if manufacturing tests should be taken pre / post linktraining.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_X_MFG_CHK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_X_MFG_CHK</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Minimum eye width to allow passing through manufacturing.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_X_MFG_MIN_EYE_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_X_MFG_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    This attribute provides an a way to stress the SMP Abus Even Lanes
    in Manufacturing. By applying a phase rotator offset we can further
    stress the phy.  This is a 6-bit 2's complement value that would be
    right justified in the 8 bit UINT attribute value.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_STRESS_PR_OFFSET_EVEN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_STRESS_PR_OFFSET_EVEN</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>i
    This attribute provides an a way to stress the SMP Abus Odd Lanes
    in Manufacturing. By applying a phase rotator offset we can further
    stress the phy.  This is a 6-bit 2's complement value that would be
    right justified in the 8 bit UINT attribute value.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_STRESS_PR_OFFSET_ODD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_STRESS_PR_OFFSET_ODD</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
   Enables the SGPE Hcode to enable the CME instruction traces into the CHTM
   for debug.  Note:  all configured CMEs will be put into this
   mode if this attribute is ON.

   Consumer: p9_hcode_image_build.c -&gt;
                SGPE Header field

   Platform default:  OFF
   </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_CHTM_TRACE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CME_CHTM_TRACE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
   CHTM Trace Memory Configuration value goes directly into CHTM_MEM register.
   User is responsible to put correct data for each bit field of the register.

   Consumer: p9_hcode_image_build.c -&gt;
                SGPE Header field

   Platform default:  0
   </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_CHTM_TRACE_MEMORY_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CME_CHTM_TRACE_MEMORY_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0x00</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Disables the enablement of Voltage Droop Monitors (VDM) in the system.

    Producer:  MRW

    Consumers:
      p9_pstate_parameter_block to clear flag for CME QuadManager Hcode
          reaction
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_VDM_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_VDM_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Indicator that all relevant attributes and required data for
  Voltage Droop Monitors (VDM) to be enabled is present and valid

  Producer: p9_build_pstate_datablock

  Consumers: p9_hcode_image_build -&gt;
                    SGPE Header
                    CME Header
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_ENABLED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_ENABLED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Pre-training bad lane data vector.  This data is persistant from previous
    IPLs so that the interface does not need to re-discover bad lanes.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_XBUS_GRP0_PRE_BAD_LANE_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_XBUS_GRP0_PRE_BAD_LANE_DATA</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Pre-training bad lane data vector.  This data is persistant from previous
    IPLs so that the interface does not need to re-discover bad lanes.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_XBUS_GRP1_PRE_BAD_LANE_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_XBUS_GRP1_PRE_BAD_LANE_DATA</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Disables IVRM enablement in the system

  Producer: Override

  Consumers: p9_build_pstate_datablock -&gt;
                    Pstate Parameter Block (PSPB) for PGPE/OCC
                    CME Quad Pstate Region (CQPR) for CM Quad Manager

  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_IVRM_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_IVRM_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Indicator that all relevant attributes and required data for
  Internal Voltage Regulator Macros (IVRMs) to be enabled is present and valid

  Producer: p9_build_pstate_datablock

  Consumers: p9_hcode_image_build -&gt;
                    PGPE Header
                    CME Header
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IVRM_ENABLED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IVRM_ENABLED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
  If wof_enabled, defines the Frequency Ratio calculation performed.
  (THIS IS NOT SUPPORTED IN P9 GA1!).
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_ENABLE_FRATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_ENABLE_FRATIO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
  If wof_enabled, defines the Voltage Ratio calculation performed.
  THIS IS NOT SUPPORTED AT PRESENT. GA1 SUPPORT IS TBD).
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_ENABLE_VRATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_ENABLE_VRATIO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
  If wof_enabled AND ATTR_WOF_ENABLE_VRATIO = CALCULATED, this attribute
  selects the Vratio calculation type.
  ACTIVE_CORES: Vratio is the number of active cores to the
  number of good cores
  FULL: Vratio is Vaverage to Vclip(Fclip) where Vclip(Fclip) is
  the normal interpolated regulator voltage (including load line uplife @ RDP
  current) derated with presently measured Idd current (from the AVSBus) and
  the loadline.

  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_VRATIO_SELECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_VRATIO_SELECT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
   SYSTEM Attribute
   Nest leakage percentage used to calculate the Core leakage.
   Will eventually be read into OCC Pstate Parameter Block
   so the OCC can see it for it's calculations.
   Valid Values: 0% thru 100%
   Producer: Machine Readable Workbook
   Consumer: OCC Firmware
   </description>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_LEAKAGE_PERCENT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NEST_LEAKAGE_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x3C</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Selects whether or not DCD should be run
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_RUN_DCD_CALIBRATION</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_RUN_DCD_CALIBRATION</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Controls ENABLE/DISABLE of Write CRC
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_EFF_WR_CRC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_EFF_WR_CRC</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Indicate if manufcaturing tests should be taken pre / post linktraining.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_CHK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_CHK</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Minimum eye width to allow passing through manufacturing.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_MIN_EYE_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>To allow for selective enablement for lab testing
  To allow skew function to be enabled/disabled. </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_CORECACHE_SKEWADJ_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_CORECACHE_SKEWADJ_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>To allow for selective enablement for lab testing
  To allow dcadj function to be enabled/disabled. </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_CORECACHE_DCADJ_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_CORECACHE_DCADJ_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Indicates that a special wakeup is in progress for an EQ

  Producer: p9_cpu_special_wakeup_eq.C

  Consumers: p9_cpu_special_wakeup_eq.C
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EQ_INSIDE_SPECIAL_WAKEUP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EQ_INSIDE_SPECIAL_WAKEUP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Adjusts the receiver internal current bias. ONLY set range 0-7. Default value is 3.
        [VPD Value] = [Binary bit value set in register]
        0 = 110 (Minimal power)
        1 = 010
        2 = 100
        3 = 000 (Default)
        4 = 111
        5 = 011
        6 = 101
        7 = 001 (Maximum power)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_BIAS_TRIM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_VPD_MT_MC_BIAS_TRIM</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Indicates that a special wakeup is in progress for an EX.

  Producer: p9_cpu_special_wakeup_ex.C

  Consumers: p9_cpu_special_wakeup_ex.C
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EX_INSIDE_SPECIAL_WAKEUP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EX_INSIDE_SPECIAL_WAKEUP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Alternate settings for short Xbus channels
    bit 0 -- Disable RX LTE
    bit 1 -- Disable AC BOOST
    bit 2 -- Low Gain/Peaking Init Settings
    bit 3 -- Lower VGA Gain Target -10%
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_XBUS_CHAN_EQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_XBUS_CHAN_EQ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Indicates if the Obus channel is a board or a cable
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_CHANNEL_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_CHANNEL_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Hierarchical path to the target with respect to logical affinity</description>
    <id>AFFINITY_PATH</id>
    <mrwRequired></mrwRequired>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>
        System attribute.
        If all MCS chiplets are in an interleaving group (1=true, 0=false).
        - If true the SMP fabric is setup in normal mode and multiple MCSs
          are grouped (disallowing systems with memory only under 1 MCS
          (i.e. systems with a single C-DIMM))
        - If false the SMP fabric is setup in checkerboard mode.
        Provided by the Machine Readable Workbook.
        This attribute is based on Machine-Type-Model (MTM) and is setup by
          the service processor.
    </description>
    <id>ALL_MCS_IN_INTERLEAVING_GROUP</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Chip which contains the FSI master logic that drives this slave when booting from the alternate master processor</description>
    <id>ALTFSI_MASTER_CHIP</id>
    <nativeType>
      <default>physical:sys-0</default>
      <name>EntityPath</name>
    </nativeType>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>Which port is this chip hanging off of when booting from the alternate master processor</description>
    <id>ALTFSI_MASTER_PORT</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        The asynchronous nest frequency
    </description>
    <id>ASYNC_NEST_FREQ_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>2000</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Specifies the &quot;intended&quot; starting memory address for PHYP's ATTN area 1.
    This is written to by Hostboot and read by FSP as a means for Hostboot to
    communicate its intentions of where the ATTN 1 area will be. Hostboot can
    then later open up an SBE window for PHYP to dump its debugging info. An
    address of 0xFFFFFFFFFFFFFFFF is considered N/A.
  </description>
    <id>ATTN_AREA_1_ADDR</id>
    <no_export></no_export>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Specifies the &quot;intended&quot; starting memory address for PHYP's ATTN area 2.
    This is written to by Hostboot and read by FSP as a means for Hostboot to
    communicate its intentions of where the ATTN 2 area will be. Hostboot can
    then later open up an SBE window for PHYP to dump its debugging info. An
    address of 0xFFFFFFFFFFFFFFFF is considered N/A.
  </description>
    <id>ATTN_AREA_2_ADDR</id>
    <no_export></no_export>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Memory AVDD voltage domain ID.  All memory buffers in the same AVDD
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        genHwsvMrwXml.pl
    </description>
    <id>AVDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Block speculative deconfig in reconfig loop.
        Flags when speculative deconfigurations should not be done for
        predictive gard records on a reconfig loop IPL due to out of
        hardware condition on prior IPL.
        0 = Allow speculative deconfiguration
        1 = Block speculative deconfiguration
        </description>
    <id>BLOCK_SPEC_DECONFIG</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>BMC FRU ID attribute to report the system firmware levels
        to the BMC.</description>
    <id>BMC_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Specifies a target's CEC degraded mode domain.  For example, all
        DIMMs are part of the DIMM CEC degraded mode domain.
    </description>
    <hasStringConversion></hasStringConversion>
    <id>CDM_DOMAIN</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <id>CDM_DOMAIN</id>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Cec Degraded Mode Policy flags
        Use the CDM_POLICIES enum to decode.
        If the appropriate bit is 1 then the policy mode is enabled,
        and those type of Guard records are disabled.
    </description>
    <id>CDM_POLICIES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines a they IPL types
         Applicable for System target only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Perform mainstore dump collection. Only valid for MPIPL
                0b0: Do not collect mainstore dump
                0b1: Perform mainstore dump collection
            </description>
        <name>PostDump</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>7</bits>
        <default>0</default>
        <description>Minor IPL Type</description>
        <name>MinorIPLType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      Attribute which describes optional IPL flavors
    </description>
    <id>CEC_IPL_TYPE</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>FRU ID attribute for centaur ECID data. This fru ID is used to
        report the ECID data to the BMC and make it available for systems which
        have then centaur chips soldered to the backplane.</description>
    <id>CENTAUR_ECID_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_AVDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VCS_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VOLT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_VOLT_VDDR_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
   </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VDDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VOLT_VPP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_VOLT_VPP_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>The address offset which each Chiplet types pervasive
     address space used to represent the a chiplet.
     0x00 to 0x0F =&gt; For P9 all non-core and non-cache chiplets
     0x10 to 0x1F =&gt; All Cache Chiplets
     0x20 to 0x37 =&gt; All Core Chiplets
     0x38 to 0x3F =&gt; Multicast Operation
   </description>
    <id>CHIPLET_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>attribute indicating the chip's ID</description>
    <id>CHIP_ID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      A unit's position within the chip with respect to similar units.
      Note that this value is relative to the parent chip, not a parent unit.
      This data is from the MRW.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_CHIP_UNIT_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CHIP_UNIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's class</description>
    <hasStringConversion></hasStringConversion>
    <id>CLASS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <id>CLASS</id>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>CPU Attribute</description>
    <id>CPU_ATTR</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Max CVPD sections </description>
    <id>CVPD_MAX_SECTIONS</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>32</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Size of CDIMM/ISDIMM
                 This is the size of the centaur vpd or memory buffer vpd.
                 It varies based on the type of the DIMM. For ISDIMMs,
                 the size will be 8KB and for CDIMM, it will be 4KB.
    </description>
    <id>CVPD_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0x2000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>L1 Data Cache Line Size in bytes</description>
    <id>DATA_CACHE_LINE_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>L1 Data Cache Size in KB</description>
    <id>DATA_CACHE_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>DCache Associative Sets</description>
    <id>DCACHE_ASSOC_SETS</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>DCache Line Size in bytes</description>
    <id>DCACHE_LINE_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>If the Target is directly deconfigurable and GARDable; target
    may still be deconfigured in 'by association' processing.</description>
    <id>DECONFIG_GARDABLE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Used to tell I2C code whether to run
        I2C Engine 2 Port 0 in diag mode or not
        0 = Use Diag Mode
        1 = Disable Diag Mode
    </description>
    <id>DISABLE_I2C_ENGINE2_PORT0_DIAG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Indicates if system should consider abus logic when deconfiguring in
        _deconfigureAssocProc(), will be overwritten on multi-node system
    </description>
    <id>DO_ABUS_DECONFIG</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Defines a negative percentage value that is applied to
        the ATTR_NOMINAL_FREQ_MHZ determined from MVPD #V.  It
        is used to explicitly raise the value of MIN_FREQ_MHZ above
        what is specified by MVPD #V data.  On FSP systems this
        is sourced from the power_management def file.
        Value must be between 0 and -100.
        A value of zero indicates no override.
    </description>
    <id>DPO_MIN_FREQ_PERCENT</id>
    <persistency>non-volatile</persistency>
    <range>
      <max>0</max>
      <min>-100</min>
    </range>
    <readable></readable>
    <simpleType>
      <int32_t>
        <default>0</default>
      </int32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Dummy attribute on the heap with zero initialization</description>
    <id>DUMMY_HEAP_ZERO_DEFAULT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Dummy attribute with read-only permissions</description>
    <id>DUMMY_RO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Dummy platInit uint8[1][3][5] attribute used for testing.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_DUMMY_SCRATCH_PLAT_INIT_UINT8</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DUMMY_RW</id>
    <ignoreEkb></ignoreEkb>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>1,3,5</array>
      <uint8_t>
        <default>5</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Dummy attribute with write-only permissions</description>
    <id>DUMMY_WO</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        EC level of a chip target.
        Read from the chip by the platform
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_EC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EC</id>
    <ignoreEkb></ignoreEkb>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Specifies a target's eeprom content type.</description>
    <hasStringConversion></hasStringConversion>
    <id>EEPROM_CONTENT_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <id>EEPROM_CONTENT_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for NV controller.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                master.
            </description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit
                value, but then shifted 2 bits left.
            </description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                but then shifted 1 bit left.
            </description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value,
                but then shifted 6 bits left.
            </description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x03</default>
        <description>
                The number of bytes a device requires to set its
                internal address/offset. For NV controller it's only
                one byte addressing with no page select (3)
                0 = Zero Byte Addressing
                1 = One Byte Addressing with page select
                2 = Two Byte Addressing
                3 = OneByte Addressing with no page select
            </description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                value possible for some devices.
            </description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The maximum number of bytes that can be written to
                a device at one time. 'Zero' value means no maximum value is
                expected or checked.
            </description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x05</default>
        <description>The amount of time in milliseconds a device requires
                on the completion of a write command to update its internal memory.
            </description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the NV controller on the NVDIMM</description>
    <id>EEPROM_NV_INFO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached I2C
          eeprom device that contains secondary VPD info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_VPD_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached I2C
          eeprom device that contains primary VPD info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>
                The number of bytes a device requires to set its
                internal address/offset. DDR4 DIMMs require a special EEPROM
                page switching mechanic denoted here by a value of 1
                0 = Zero Byte Addressing
                1 = One Byte Addressing with page select
                2 = Two Byte Addressing
                3 = OneByte Addressing with no page select
            </description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM slaves</description>
    <id>EEPROM_VPD_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>
        Holds the effective EC of the system.  Effective EC is the lowest EC
        among all the functional procs in the system.  Some cards may &quot;downbin&quot;
        the effective ECs of their contained processors, which could lower the
        effective EC of the system beyond what would occur when considering
        processor ECs alone
    </description>
    <id>EFFECTIVE_EC</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
       Bitmask of threads to enable for each processor,
       Zero means enable all architected threads
    </description>
    <id>ENABLED_THREADS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's engine type</description>
    <hasStringConversion></hasStringConversion>
    <id>ENGINE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <id>ENGINE_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Chip attribute.
        Logical fabric chip id for this chip (position within the fabric).
        Provided by the Machine Readable Workbook.
        Can vary across drawers.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CHIP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FABRIC_CHIP_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Chip attribute.
        Logical fabric group the chip belongs to.
        Provided by the Machine Readable Workbook.
        Can vary across drawers.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_GROUP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FABRIC_GROUP_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Correlate HDAT node number (physical) to the logical node
        (based on the PIR) that contains the host boot image.
    </description>
    <id>FABRIC_TO_PHYSICAL_NODE_MAP</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint8_t>
        <default>0,255,255,255,255,255,255,255</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define addressing this I2C slave device.
    </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master
      </description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.
      </description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
          but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>FAPI_I2C_CONTROL_INFO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>Common name across FAPI environments
    chip target -&gt; pu:k0:n0:s0:p00
    DIMM target -&gt; dimm:k0:n0:s0:p00
    chip unit target -&gt; pu.core:k0:n0:s0:p00:c0
    cage/system target -&gt; k0

    (chip type).(unit type):k(cage,always zero for us):n(node/drawer)
              :s(slot,always zero for us):p(chip position):c(core/unit position)
    pu  = generic processor
    </description>
    <id>FAPI_NAME</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <default>unknown</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>Field Core Override (FCO) is the override value for the
    number of functional cores allowed on the system.
    FCO is used when customers order a system with N cores but they only want
    to enable less than N cores to lower software license costs. A field in the
    anchor VPD is set by manufacturing to specify the maximum number of cores
    to enable. The number is maintained, even if some cores are garded out due
    to error.
    A value of 0 means all cores allowed;
    </description>
    <id>FIELD_CORE_OVERRIDE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Column Repairs allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <id>FIELD_TH_P8EX_L2_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>7</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Line Deletes allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <id>FIELD_TH_P8EX_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Column Repairs allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <id>FIELD_TH_P8EX_L3_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>7</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Line Deletes allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <id>FIELD_TH_P8EX_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The maximum frequency of the core mesh clock, in MHz.
    Determines the core frequency; nest and caches run at half this value.
    Must be greater than or equal to ATTR_FREQ_CORE_FLOOR_MHZ.
    This can differ per chip in the system.
    Provided by the #V bucket of module VPD.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_CEILING_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_CORE_CEILING_MHZ</id>
    <ignoreEkb></ignoreEkb>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      SYSTEM Attribute
      Maximum frequency (binary in MHz) that any processor in the system will
      run. Used to define the top end of the PState range in the frequency space.
      From this, the ATTR_PROCPM_PSTATE0_FREQUENCY is computed using
      ATTR_SYSTEM_REFCLK_FREQUENCY to determine the step size.

      Consumers: proc_build_gpstate_table.C (among others)

      Data is is provided by MVPD #V and is calculated as the minimum
      of the turbo frequencies
    </description>
    <id>FREQ_CORE_MAX</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The frequency of the processor refclock in MHz.
        Provided by the MRW.
    </description>
    <id>FREQ_PROC_REFCLOCK</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>FRU ID attribute used to report FRU information to the BMC
        for each fru in the system.</description>
    <global></global>
    <id>FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Chip which contains the FSI master logic that drives this slave when booting from the default master processor</description>
    <id>FSI_MASTER_CHIP</id>
    <nativeType>
      <default>physical:sys-0</default>
      <name>EntityPath</name>
    </nativeType>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>Which port is this chip hanging off of when booting from the default master processor</description>
    <id>FSI_MASTER_PORT</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Type of Master FSI connection to this slave (MFSI or cMFSI)</description>
    <hasStringConversion></hasStringConversion>
    <id>FSI_MASTER_TYPE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <default>NO_MASTER</default>
        <id>FSI_MASTER_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <complexType>
      <description>FSI flags</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
                Set on FSI master chips (procs) if that chip uses slaveB
                to attach to the acting master chip.
            </description>
        <name>flipPort</name>
        <type>uint16_t</type>
      </field>
      <field>
        <bits>15</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint16_t</type>
      </field>
    </complexType>
    <description>
        Reserved for any special flags we might need to access FSI
    </description>
    <id>FSI_OPTION_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>Slave cascade position</description>
    <id>FSI_SLAVE_CASCADE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Size of FSP IO Region</description>
    <id>FSP_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0x0000000100000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base Address of FSP IO Region</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FSP_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FSP_BASE_ADDR</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0x0003FFE000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Stores the SMT setting used to determine fused mode.
        SMT4_DEFAULT: Nimbus_DD1, boot in SMT4 but can change to SMT8
        SMT4_ONLY: Nimbus_DD2/Cumulus, set based on PVR info
        SMT8_ONLY: Nimbus_DD2/Cumulus, set based on PVR info
    </description>
    <id>FUSED_CORE_MODE_HB</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        If not loading PHYP or OPAL, then use this to
        decide whether to use FUSED cores or NOT.
    </description>
    <id>FUSED_CORE_OPTION</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Hostboot HRMOR = (HB_HRMOR_NODAL_BASE * node) + offset. </description>
    <id>HB_HRMOR_NODAL_BASE</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0x200000000000</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        The amount of mainstore that PHYP needs to preserve per node
        during MPIPL.
    </description>
    <id>HB_RSV_MEM_SIZE_MB</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>256</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines a system's HB settings.
         Applicable for System target only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Enable / Disable continuous trace.
                0b0: Continuous trace is disabled.
                0b1: Continuous trace is enabled.
            </description>
        <name>traceContinuous</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Override trace debug selection for SCAN component.
                0b0: TRACS entries for SCAN have default behavior.
                0b1: TRACS entries for SCAN are enabled.
            </description>
        <name>traceScanDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Override trace debug selection for DBG component.
                0b0: TRACS entries for DBG have default behavior.
                0b1: TRACS entries for DBG are enabled.
            </description>
        <name>traceFapiDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      Attribute which describes how the SP has configured features in
      Hostboot.
    </description>
    <id>HB_SETTINGS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
       Indicates the chip's EC level, distinct from ATTR_EC to handle
       non-standard mini-ECs, e.g. 1.01, separate from the real
       hardware-defined EC level.  By default, ATTR_HDAT_EC==ATTR_EC
       unless the chip has a mini-EC.
    </description>
    <id>HDAT_EC</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Number of internal data pointers we have in
        the hostboot runtime data section.
    </description>
    <id>HDAT_HBRT_NUM_SECTIONS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Biggest size for any of the hostboot
        runtime data sections.
    </description>
    <id>HDAT_HBRT_SECTION_SIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>9</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Number of internal data pointers we have in
        the hostboot reserved memory section.
    </description>
    <id>HDAT_RSV_MEM_NUM_SECTIONS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>PCIe slot HDDW order definition</description>
    <id>HDDW_ORDER</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Physical address where HOMER image is placed in mainstore.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_HOMER_PHYS_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>HOMER_PHYS_ADDR</id>
    <ignoreEkb></ignoreEkb>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Value of the next EID that host service should send.
        (Note - EID is more accurate, PLID being kept to handle legacy code.)
    </description>
    <id>HOSTSVC_PLID</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x89000000</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Hot Plug Controller values for a specific processor.
        Purpose: Holds information about the hot plug controllers so that a
            Hardware procedure is able to turn them on and off.
        Data Format: up to 8 Hot Plug Controllers x 7 variables of information
            This data is at the processor level.
            The needed information and their individual sizes are as follows:
            (1) I2C Master processor engine (uint8_t)
            (2) I2C Master processor port (uint8_t)
            (3) Bus Speed (uint16_t value: 2 uint8_t values: MSB, LSB)
            (4) Slave address (uint8_t)
            (5) Device type (uint8_t: see SUPPORTED_HOT_PLUG enum)
            (6) I2C Master processor node (uint8_t)
            (7) I2C Master processor position (uint8_t)
            Thus, the information will be 8 bytes.
    </description>
    <id>HOT_PLUG_POWER_CONTROLLER_INFO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>8,8</array>
      <uint8_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            </default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Hardware Unit ID
        SSSSNNNNTTTTTTTTiiiiiiiiiiiiiiii
        S=System
        N=Node Number
        T=Target Type (matches TYPE attribute)
        i=Instance/Sequence number of target, relative to node
    </description>
    <id>HUID</id>
    <mrwRequired></mrwRequired>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <default>0xFFFFFFFF</default>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <complexType>
      <description>struct - 4 booleans and a PLID</description>
      <field>
        <default>0</default>
        <description>if this target was deconfigured,
                this will be a special DECONFIGURED_BY_ enum,
                OR it will be the errlog EID that caused it,
                either directly or by association,
            </description>
        <name>deconfiguredByEid</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not powered on (is off);
             0b1: Target is powered on;
            </description>
        <name>poweredOn</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not present in the system;
             0b1: Target is present in the system
            </description>
        <name>present</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not functional;
             0b1: Target is functional
            </description>
        <name>functional</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>FSP Only, used by DUMP applet;
             0b0: target is dump capabile;
             0b1: target is not dump capabile;
            </description>
        <name>dumpfunctional</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Set for speculative deconfig;
             0b0: target not speculative deconfig;
             0b1: target is speculatively deconfigured;
            </description>
        <name>specdeconfig</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>HardWare Availability Service State Attribute.
        Keeps track of Target values poweredOn, present, functional</description>
    <id>HWAS_STATE</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>HardWare Availability Service State Changed Attribute.
        Keeps track of changedSinceChecked state, indicates if the
        target has changed since last checked by the appropriate service.
        This is a bit field of flags (see HWAS_CHANGED_BIT enumeration
        that follows).
        </description>
    <id>HWAS_STATE_CHANGED_FLAG</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0x0</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>HardWare Availability Service State Changed Mask.
        Used when a target changes (ie, via HCDB change) to set the
        HWAS_STATE_CHANGED_FLAG, so that the appropriate services will
        all handle the change.
        This is a bit field of flags (see HWAS_CHANGED_BIT enumeration
        that follows).
        </description>
    <id>HWAS_STATE_CHANGED_SUBSCRIPTION_MASK</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0x0</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Designates the speed at which a given I2C bus should run.
        Creator: MRW
        Purpose: Used by FW to know the fastest possible bus speed that all of
            the devices on a given bus are able to use.
        Data Format: 4x13 array of uint16_t values.  The first index indicates
            the engine number of the bus.  The second index indicates the port
            number of the bus.  The value in the array is the I2C bus speed
            used for that engine/port combination in KHz.
    </description>
    <id>I2C_BUS_SPEED_ARRAY</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4,13</array>
      <uint16_t>
        <default>
            0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define addressing this I2C slave device.
    </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master
      </description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.
      </description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
          but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the I2C mux for
            this device
                     must enable to connect this device to its I2C master, if applicable.
                     0xFF indicates no I2C mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path of the I2C mux for this device, if any.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>I2C_CONTROL_INFO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines which I2C access method to use at
        a point in time.  Only applicable if target supports one or more I2C
        types.  Only one bit (of the first two) can ever be set at any one time.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use FSI I2C at this time.  0b1: Use FSI
            I2C at this time</description>
        <name>useFsiI2C</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use Host I2C at this time.  0b1: Use
            Host I2C at this time</description>
        <name>useHostI2C</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>6</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute storing information about which I2C method to use</description>
    <id>I2C_SWITCHES</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>MCS Inband Scom base address</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MCS_INBAND_BASE_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IBSCOM_MCS_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PROC Inband Scom base address</description>
    <id>IBSCOM_PROC_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>ICache Assoc Sets</description>
    <id>ICACHE_ASSOC_SETS</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>ICache Block Size in bytes</description>
    <id>ICACHE_BLOCK_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Icache Line Size in bytes</description>
    <id>ICACHE_LINE_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>ICache Size in KB</description>
    <id>ICACHE_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Controls whether target discovery code should assume the target is
      initially present, functional, and powered on (even though later
      operations may change this).  Commonly used to avoid having to do presence
      detect on certain targets.
          0x00: Do not assume target is initially available
          0x01: Assume target is initially available
    </description>
    <id>INIT_TO_AVAILABLE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <range>
      <max>1</max>
      <min>0</min>
    </range>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>If True, puts HostBoot into SPLess SingleStep mode.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_ISTEP_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>ISTEP_MODE</id>
    <ignoreEkb></ignoreEkb>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Used to configure the parameters for enabling pause/stop between
      isteps. This attribute is set via attribute override.
    </description>
    <id>ISTEP_PAUSE_CONFIG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Used to enable pause/stop in between isteps. This attribute is set via
      attribute override.
    </description>
    <id>ISTEP_PAUSE_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Indicate an inter-enclosure bus at this endpoint target.
                 0 = No, 1 = Yes
    </description>
    <id>IS_INTER_ENCLOSURE_BUS</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Attribute indicating the status of the Secure Boot key transition for
    the node
  </description>
    <hasStringConversion></hasStringConversion>
    <id>KEY_TRANSITION_STATE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <default>KEY_TRANSITION_NOT_REQUESTED</default>
        <id>KEY_TRANSITION_STATE</id>
      </enumeration>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>L2 Cache Assoc Sets</description>
    <id>L2_CACHE_ASSOC_SETS</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>L2 Cache Line Size in bytes</description>
    <id>L2_CACHE_LINE_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>L2 Cache Size in KB</description>
    <id>L2_CACHE_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>L3 Cache Line Size in bytes</description>
    <id>L3_CACHE_LINE_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>L3 Cache Size in KB</description>
    <id>L3_CACHE_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Location code of the Fru target</description>
    <id>LOCATION_CODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>LPC Bus address - MMIO consumed by PHYP</description>
    <id>LPC_BUS_ADDR</id>
    <no_export></no_export>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max chiplets per proc available in the system.
    </description>
    <id>MAX_CHIPLETS_PER_PROC</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        The max compute nodes available in the system.
        Computed value based on CEC enclosures.
    </description>
    <id>MAX_COMPUTE_NODES_PER_SYSTEM</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max DIMMs per MBA Port available in the system.
    </description>
    <id>MAX_DIMMS_PER_MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max DMI units per proc available in the system.
    </description>
    <id>MAX_DMI_PER_PROC</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max EX units per proc chip available in the system.
    </description>
    <id>MAX_EXS_PER_PROC_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max MBAS per membuf available in the system.
    </description>
    <id>MAX_MBAS_PER_MEMBUF_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max MBA ports per MBA available in the system.
    </description>
    <id>MAX_MBA_PORTS_PER_MBA</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max MCS units available in the system.
    </description>
    <id>MAX_MCS_PER_SYSTEM</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>4</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Defines the maximum power consumption for a PCIe slot</description>
    <id>MAX_POWER</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max proc chips per node available in the system.
    </description>
    <id>MAX_PROC_CHIPS_PER_NODE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Defines the maximum Seeprom storage size for the fully-customized SBE image
      permitted by the platform.
      For platforms (FSP/HB FW) which require the image to be constrained into a
      physical storage device (SEEPROM), this should reflect the maximum size of that
      memory (e.g., 256KB).
      For platforms (Cronus) which may use a customized image in a virtual
      envrionment with no physical storage constraints, this size may be
      larger than the physical SEEPROM size.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MAX_SBE_SEEPROM_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MAX_SBE_SEEPROM_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x40000</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
       MBA port DIMM number of this DIMM
       (deprecated in favor of POS_ON_MEM_PORT)
    </description>
    <id>MBA_DIMM</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
       MBA port this DIMM is connected to
       (deprecated in favor of MEM_PORT)
    </description>
    <id>MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>MC0, MC1, MC2, MC3 pll bucket selection</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MC_PLL_BUCKET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MC_PLL_BUCKET</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Memory AVDD voltage domain offset in mV.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_AVDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Base Address for all mainstore behind this processor</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_BASE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_BASE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
       Memory port this DIMM is connected to
    </description>
    <id>MEM_PORT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Memory VCS voltage domain offset in mV.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VCS_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_VCS_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Memory VDDR voltage domain offset in mV.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VDDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_VDDR_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Memory VDD voltage domain offset in mV.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VDD_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_VDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Memory VPP voltage domain offset in mV.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPP_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_VPP_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Override this to a non-zero value to have the FAPI manufacturing
        traces output to the console or go to a fsp trace buffer when
        console not enabled.
    </description>
    <id>MFG_TRACE_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Due to fabric limitations, we can only enable 2 links
      at a time during wrap testing. This attribute defines
      which set this ABUS link belong to. This attribute
      will live on the OBUS target. The value will come
      from MRW. When the value for this attribute matches
      MFG_WRAP_TEST_ABUS_LINKS_SET_ENABLE, then we leave the
      OBUSes configured. Otherwise, we deconfigure them.
    </description>
    <id>MFG_WRAP_TEST_ABUS_LINKS_SET</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <default>SET_NONE</default>
        <id>MFG_WRAP_TEST_ABUS_LINKS_SET</id>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute defines which set of ABUS links to enable
      during MST wrap testing. This attribute will live on
      the system target. The value will be overriden during
      MST testing. When the value of MFG_WRAP_TEST_ABUS_LINKS_SET
      on each of the OBUS matches with this value, then we leave the
      OBUSes configured. Otherwise, we deconfigure them.
    </description>
    <id>MFG_WRAP_TEST_ABUS_LINKS_SET_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>defines MGC load source</description>
    <id>MGC_LOAD_SOURCE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The minimum frequency of the core mesh clock, in MHz.
    Determines the core frequency; nest and caches run at half this value.
    Must be less than or equal to ATTR_FREQ_CORE_CEILING_MHZ.
    This can differ per chip in the system.
    Provided by the #V bucket of module VPD.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_FLOOR_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MIN_FREQ_MHZ</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>4800</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>System Mirrorable Base Address
       Bits8-12 Specifies System Selects
       Bits13-14 Memory select
       Bits15-18 Group ID (within an SMP)
       Bits19-21 Chip ID (8 Max)
       Bits22-63 Chip internal address (42 bits, 4TB)
       Mirroring uses memory select
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MIRROR_BASE_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MIRROR_BASE_ADDRESS</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0x4000000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      System attribute
      8 bit rx_min_eye_height value for A bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <id>MNFG_ABUS_MIN_EYE_HEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      System attribute
      6 bit rx_min_eye_width value for A bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <id>MNFG_ABUS_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      System attribute.
      8 bit rx_min_eye_height value for DMI bus interfaces during system
      manufacturing; used for both centaur and p8
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <id>MNFG_DMI_MIN_EYE_HEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      System attribute.
      6 bit rx_min_eye_width value for DMI bus interfaces during system
      manufacturing; used for both centaur and p8
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <id>MNFG_DMI_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the maximum number of L4 Cache CEs allowed.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_CEN_L4_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Base threshold (for 2GB DRAM ) of
      Memory CEs allowed during IPL.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_CEN_MBA_IPL_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the maximum number of Memory RCEs
      allowed per Rank during runtime.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_CEN_MBA_RT_RCE_PER_RANK</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Base threshold (for 2GB DRAM ) of
      Memory CEs allowed during runtime.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_CEN_MBA_RT_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when a
      memory intermittent MPE attention count is equal to this value. A value of
      0 defaults to the max threshold of 0xff.
    </description>
    <id>MNFG_TH_MEMORY_IMPES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when a
      memory intermittent UE attention count is equal to this value. A value of
      0 defaults to the max threshold of 0xff.
    </description>
    <id>MNFG_TH_MEMORY_IUES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Cache CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L2_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Column Repairs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L2_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Directory CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L2_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Line Deletes allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Cache CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L3_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>3</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Column Repairs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L3_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Directory CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L3_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Line Deletes allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when an
      RCD parity error (recovery enabled) attention count is equal to this
      value. A value of 0 defaults to the max threshold of 0xff.
    </description>
    <id>MNFG_TH_RCD_PARITY_ERRORS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      System attribute
      6 bit rx_min_eye_width value for X bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <id>MNFG_XBUS_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's model</description>
    <hasStringConversion></hasStringConversion>
    <id>MODEL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <id>MODEL</id>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>MRU ID attribute for chip/unit class</description>
    <id>MRU_ID</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR
        voltage setpoint. In mV.
    </description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR
        voltage setpoint. In mV.
    </description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage
        setpoint. In mV.
    </description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage
        setpoint. In mV.
    </description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Attribute indicating the default risk level for the system. Applied if
        scratch registers are not overriden
    </description>
    <id>MRW_DEFAULT_RISK_LEVEL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Machine Readable Workbook throttle value for denominator cfg_nm_m</description>
    <id>MRW_MEM_THROTTLE_DENOMINATOR</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>AVDD memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion></hasStringConversion>
    <id>MSS_AVDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_CENT_AVDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_ACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_CENT_AVDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_CENT_AVDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_CENT_VCS_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VCS_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VCS_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_CENT_VDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>MBA DRAM data bus utilization percent to use to determine cfg_nm_n_per_mba</description>
    <id>MSS_DATABUS_UTIL_PER_MBA</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>sets the Centaur address bits used to interleave addresses between MBA01 and MBA23. valid values are 23 through 32.</description>
    <id>MSS_MBA_ADDR_INTERLEAVE_BIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>centaur interleave mode. 1 = 256-BIT, 0 = 128-BIT.</description>
    <id>MSS_MBA_CACHELINE_INTERLEAVE_MODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Controls ENABLE/DISABLE of workaround that sets
      the PHY sequencer to trigger refresh after draminit.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_PHY_SEQ_REFRESH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_PHY_SEQ_REFRESH</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>VCS memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion></hasStringConversion>
    <id>MSS_VCS_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>VDDR memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic,
    3 = DEFAULT  - domain needs to be programmed, pgm values in sys xml file
    </description>
    <hasStringConversion></hasStringConversion>
    <id>MSS_VDDR_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>VDD memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion></hasStringConversion>
    <id>MSS_VDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_AVDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_AVDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VCS_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VCS_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VOLT_VDDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_VOLT_VDDR_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDDR_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_VPP_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VOLT_VPP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_VOLT_VPP_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>MSS_VOLT_VPP_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: uV/DRAM
    </description>
    <id>MSS_VOLT_VPP_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: uV/DRAM
    </description>
    <id>MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>VPP memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion></hasStringConversion>
    <id>MSS_VPP_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Constant defining number of NEST PLL frequency options ('buckets')
      to be built into unsigned HW image.
  </description>
    <id>NEST_PLL_FREQ_BUCKETS</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x05</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      I2C bus divisor
      index is bucket number
      The values in this list will be factor of 1:64 to the NEST_PLL_FREQ_LIST
  </description>
    <id>NEST_PLL_FREQ_I2CDIV_LIST</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>5</array>
      <uint32_t>
        <default>25,29,31,33,37</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Nest PLL frequency in MHZ
      index is bucket number
  </description>
    <id>NEST_PLL_FREQ_LIST</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>5</array>
      <uint32_t>
        <default>1600,1866,2000,2133,2400</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VCS Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <id>NEST_VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VDDR Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <id>NEST_VDDR_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VDD Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <id>NEST_VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VDN Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <id>NEST_VDN_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VIO Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <id>NEST_VIO_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    The nominal core frequency in MHz.
    This is the same for all cores in the system.
    Provided by the #V bucket of module VPD.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_NOMINAL_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NOMINAL_FREQ_MHZ</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>NPU MMIO BAR base address values
        creator: platform
        consumer: proc_setup_bars
        firmware notes:
            64-bit address representing BAR RA
            NOTE: BAR register covers RA 14:51
            first dimension: unit number (0:3)
            second dimension: BAR number (0:1)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NPU_MMIO_BAR_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>NPU MMIO BAR size values
        creator: platform
        consumer: proc_setup_bars
        firmware notes: none
            first dimension: unit number (0:3)
            second dimension: BAR number (0:1)
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NPU_MMIO_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <complexType>
      <description>Numeric POD type test structure</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path for testing purposes</description>
        <name>fsiPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>CHIP</default>
        <description>Class for testing purposes</description>
        <name>className</name>
        <type>CLASS</type>
      </field>
      <field>
        <default>0xAB</default>
        <description>Test uint8</description>
        <name>uint8</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xABCD</default>
        <description>Test uint16</description>
        <name>uint16</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xABCDEF01</default>
        <description>Test uint32</description>
        <name>uint32</name>
        <type>uint32_t</type>
      </field>
      <field>
        <default>0xABCDEF0123456789</default>
        <description>Test uint64</description>
        <name>uint64</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>-124</default>
        <description>Test int8</description>
        <name>int8</name>
        <type>int8_t</type>
      </field>
      <field>
        <default>-32764</default>
        <description>Test int16</description>
        <name>int16</name>
        <type>int16_t</type>
      </field>
      <field>
        <default>-2147483644</default>
        <description>Test int32</description>
        <name>int32</name>
        <type>int32_t</type>
      </field>
      <field>
        <default>-9223372036854775804</default>
        <description>Test int64</description>
        <name>int64</name>
        <type>int64_t</type>
      </field>
    </complexType>
    <description>Attribute which tests numeric POD types</description>
    <id>NUMERIC_POD_TYPE_TEST</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <complexType>
      <description>Armed State</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Is NVDIMM armed</description>
        <name>armed</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>NVDIMM controller error detected</description>
        <name>error_detected</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>6</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      NVDIMM(s) are armed for backup incase of power loss (DDR Reset_n goes low)
      This keeps track of the armed state
    </description>
    <id>NVDIMM_ARMED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        NVDIMM timeout value for 6 main operations
        0 - CSAVE
        1 - Page Switch
        2 - Restore
        3 - ERASE
        4 - ARM
        5 - CHARGE

        This attribute is set to volatile because the timeout values vary
        depending on the vendor and capacity. The timeout values will be
        determined during init by reading the i2c registers on the NV
        controller.
        The indices are defined in src/usr/isteps/nvdimm.H and the attribute
        is consumed in nvdimm.C
    </description>
    <id>NV_OPS_TIMEOUT_MSEC</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>6</array>
      <uint32_t>
        <default>0,0,0,0,0,0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        NVDIMM status flag. This is used to record the status and
        later report to OPAL/PHYP. Possible values:

        0x08 - contents not preserved (genesis)
        0x04 - contents preserved
        0x02 - failed to preserve contents
        0x01 - unable to preserve future contents
    </description>
    <id>NV_STATUS_FLAG</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x08</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Lane mask for which 8 lanes belong to this brick
      This is a right justified 24-bit value. Only 8 of the
      24 bits will be set representing the lanes belonging to
      the associated brick.
      Provided by the MRW.
  </description>
    <id>OBUS_BRICK_LANE_MASK</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Position of the obus slot that the Obus brick is connected to
      (represented in decimal). There is only one slot that a given
      brick connects to and there are only 6 slots per proc,
      so, we just need a single uint8_t representing the position
      of the slot.
      Provided by the MRW.
  </description>
    <id>OBUS_SLOT_INDEX</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This attribute is to determine whether an occ is master capable.
        An OCC is master capable if it's parent processor is wired to the
        APSS.
    </description>
    <id>OCC_MASTER_CAPABLE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Physical entity path an OMI's associated OMIC parent target
    </description>
    <id>OMIC_PARENT</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <virtual></virtual>
  </attribute>

  <attribute>
    <description>Ordinal ID of a target</description>
    <id>ORDINAL_ID</id>
    <mrwRequired></mrwRequired>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines a target's deconfigure rules.
        Structure is read-only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Are the rule bits set correctly?
        </description>
        <name>valid</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            0b0: Target should NOT be deconfigured by child rollup
            0b1: Target allowed to be deconfigured by child rollup
            </description>
        <name>childRollupAllowed</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            0b0: Target should NOT rollup its deconfigure to its parent
            0b1: Target should deconfigure its parent if no more functioning
                 children of same type exist for its parent
        </description>
        <name>deconfigureParent</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      Rules on how to handle a deconfigure to parent level
    </description>
    <id>PARENT_DECONFIG_RULES</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>
        Physical entity path of the target's associated pervasive target
    </description>
    <id>PARENT_PERVASIVE</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <virtual></virtual>
  </attribute>

  <attribute>
    <description>Base address (target HRMOR) of the payload.  Value is in MB.</description>
    <id>PAYLOAD_BASE</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>256</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>The offset from base address of the payload entry-point.
        Current default is 0x180</description>
    <id>PAYLOAD_ENTRY</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0x180</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Indicate that payload should be placed in mirrored memory.
        Set by the FSP based on the value of the registry key indicating
        the memory mirroring mode.
    </description>
    <id>PAYLOAD_IN_MIRROR_MEM</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Attribute indicating what kind of payload is to be started.
    </description>
    <hasStringConversion></hasStringConversion>
    <id>PAYLOAD_KIND</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <id>PAYLOAD_KIND</id>
      </enumeration>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>PCIe slot 32bit DMA size definition</description>
    <id>PCIE_32BIT_DMA_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIe slot 32bit MMIO size definition</description>
    <id>PCIE_32BIT_MMIO_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIe slot 64bit DMA size definition</description>
    <id>PCIE_64BIT_DMA_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIe slot 64bit MMIO size definition</description>
    <id>PCIE_64BIT_MMIO_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Denotes the capabilites of this pcie slot</description>
    <id>PCIE_CAPABILITES</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base Address of PCI 32 bit Memory Space</description>
    <id>PCI_BASE_ADDRS_32</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base Address of PCI 64 bit Memory Space</description>
    <id>PCI_BASE_ADDRS_64</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Defines system specific value of PCI refclock receiver termination (FSI GP4 bits 10:11)
    </description>
    <hasStringConversion></hasStringConversion>
    <id>PCI_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This attribute indicates if the PEC can be bifurcated. The value is determined from the workbook.
        0 - PEC is not bifurcateable
        1 - PEC can be bifurcated
        Note: Altering the lane map can be done using the HX keyword.
    </description>
    <id>PEC_IS_BIFURCATABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
          This attribute holds the contents of the HX keyword read by the FSP
          from a PCIe card. The keyword data is used to determine the PHB
          bifurcation settings.
          byte    0 = Keyword Version
                        0x00 - Keyword not used, ignore remaining data
                        0x01 - Data describes this enitity's logical PCIe device
                               to physical PCIe lane mapping as one or more
                               logical devices, each connected to a set of PCIe
                               lanes (always an integral multiple of 8 lanes)
          byte    1 = Number of x8 lane set entries X (0 to 7)
                      Each lane set entry is a one-byte value which indicates
                      whether the lane set is used by any logical device, and if
                      used, the logical device ID to which the lane set
                      is assigned, if this byte is zero the remaining keyword
                      data should be ignored.
          bytes 2+N = Lane set entry N
                      where N={0,1..X-1}
                      Each lane set entry maps a set of physical lanes
                      (8*N through N*8+7) to a logical device. Bit 0 indicates
                      whether the lane set is used by a logical device. If used,
                      the next three bits indicate which logical device ID
                      uses those lanes.

                      Bit0:
                         0b0 = Lanes not used by a logical device; ignore
                         0b1 = Lanes used by a logical device; logical device
                               id below is valid
                      Bit 1-3:
                         0b000 = reserved (when bit 0 = 0b0)
                         0b001 -&gt; 0b111
                      Bit 4-7
                      reserved

          Example: bifurcate PEC into 2-x8 devices PHB3 and PHB4
          HX keyword data  kw = { 01 02 B0 C0 xx xx xx xx xx }
              kw[0] = 01 - data is valid
              kw[1] = 02 - there are two lane sets defined
              kw[2] = B0 - b0   = 1 lane set 0xFF00 is used
                           b1:3 = 011 - lane set is assigned to device ID3
              kw[3] = C0 - b0   = 1 lane set 0x00FF is used
                           b1:3 = 100 - lane set is assigned to device ID4
              kw[4:8]   - remaining data is ignored


         Example: un-bifurcate a slot which is by default bifurcated
          HX keyword data  kw = { 01 02 B0 B0 xx xx xx xx xx }
              kw[0] = 01 - data is valid
              kw[1] = 02 - there are two lane sets defined
              kw[2] = B0 - b0   = 1 lane set 0xFF00 is used
                           b1:3 = 011 - lane set is assigned to device ID3
              kw[3] = B0 - b0   = 1 lane set 0x00FF is used
                           b1:3 = 011 - lane set is assigned to device ID3
              kw[4:8]   - remaining data is ignored

         HX keyword data must map to a valid slot configuration as defined by
         the system workbook.
    </description>
    <id>PEC_PCIE_HX_KEYWORD_DATA</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>9</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Effective PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the effective PCIE IOP reversal value after taking into
            account any IOP bifurcations.  If no IOP bifurcations present, this
            is just the value of the PROC_PCIE_IOP_REVERSAL_NON_BIFURCATED
            attribute.
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            for lane set 0, the second for lane set 1 and so on. The given
            index in the array is a mask which specifies which bit to invert
            in the lane swap settings for the given PEC/lane set.
    </description>
    <id>PEC_PCIE_IOP_REVERSAL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Base PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the PCIE IOP reversal value for cases where the IOP
            is bifurcated
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. The given index in
            the array is a mask which specifies which bit to invert in the lane
            swap settings for the given lane set
    </description>
    <id>PEC_PCIE_IOP_REVERSAL_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the base PCIE IOP reversal value without considering IOP
            bifurcation.
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            for lane set 0, the second for lane set 1 and so on. The given
            index in the array is a mask which specifies which bit to invert
            in the lane swap settings for the given lane set.
    </description>
    <id>PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Bifurcated PCIE IOP swap configuration value
        Creator: MRW
        Purpose: Holds the base IOP swap configuration value for the IOPs in the
            case where they are bifurcated.  The swap value controls how PCIE
            lanes are recordered when the leave the IOP, to provide lane routing
            flexibility.
        Data Format: A uint8_t value. The value specifices for the hardware how
            to swap the PCIE lanes for the given PEC.
    </description>
    <id>PEC_PCIE_IOP_SWAP_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base PCIE IOP swap configuration value
        Creator: MRW
        Purpose: Holds the base IOP swap configuration value without considering
            IOP bifurcation.  The swap value controls how PCIE lanes are
            recordered when the leave the IOP, to provide lane routing
            flexibility.
        Data Format: A uint8_t value. The value specifices for the hardware how
            to swap the PCIE lanes for the given PEC.
    </description>
    <id>PEC_PCIE_IOP_SWAP_NON_BIFURCATED</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Mask bifurcated configuration
        Creator: MRW
        Purpose: Holds the PCIE lane mask assuming IOPs are bifurcated.
        Data Format: x4 array of uint16_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. A lane set mask
            indicates which groups of lanes are assigned to an IOP. For
            instance, lane set 0 value of 0xFF00 and lane set 1 value of 0x00FF
             means the IOP is bifurcated into two x8s.
    </description>
    <id>PEC_PCIE_LANE_MASK_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Mask base configuration
        Creator: MRW
        Purpose: Holds the base PCIE lane mask assuming no dynamic IOP
            bifurcations.
        Data Format: x4 array of uint16_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. A lane set mask
            indicates which groups of lanes are assigned to an IOP.  For
            instance, lane set 0 value of 0xFFFF and lane set 1 value of 0x0000
            means the PEC is a x16. Lane set 0 value of 0xFF00 and lane
            set 1 value of 0x00FF, means the PEC is split into two x8s.
    </description>
    <id>PEC_PCIE_LANE_MASK_NON_BIFURCATED</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Entity path of the peer target of a bus target
    </description>
    <id>PEER_PATH</id>
    <nativeType>
      <default>physical:na</default>
      <name>EntityPath</name>
    </nativeType>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>Peer target's address of a A/X-bus connection.
                 NULL means address 0 for no peer target. If a
                 target instance overrides the default with the
                 peer target's PHYS_PATH. The target compiler will
                 convert the valid PHYS_PATH string into the runtime
                 virtual address of the peer target instance.
    </description>
    <id>PEER_TARGET</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <Target_t>
        <default>NULL</default>
      </Target_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Chiplet partial good information to be consumed by IPL HWP code.
    This attribute logically represents the combination of VPD PG plus
    any additional runtime deconfiguration to be applied on the current IPL.
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PG</id>
    <ignoreEkb></ignoreEkb>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Base Address of PHB Register Space</description>
    <id>PHB_BASE_ADDRS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint64_t>
        <default>
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF
            </default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Physical hierarchical path to the target</description>
    <id>PHYS_PATH</id>
    <mrwRequired></mrwRequired>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>
    i2c pll for the system
    default is 0x26 (For PIB @500 MHz (2 GHz nest)) for
    I2C speed = ~1Mhz per Andreas Koenig.
</description>
    <id>PIB_I2C_NEST_PLL</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x026</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    i2c reference clock for the system.
    default is 0x4 =&gt; I2C speed = ~1Mhz per Andreas Koenig
</description>
    <id>PIB_I2C_REFCLOCK</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x4</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Set to 1 by HWSV to indicate that attribute overrides exist in a PLCK IPL
      (not an IPL by steps). This is read by Hostboot to determine if it needs
      to request the attribute overrides from HWSV before starting its IPL.
    </description>
    <id>PLCK_IPL_ATTR_OVERRIDES_EXIST</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Save state of the sfc driver flash workarounds for runtime</description>
    <id>PNOR_FLASH_WORKAROUNDS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Position of target relative to node</description>
    <id>POSITION</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
       Position of this DIMM on its memory port
    </description>
    <id>POS_ON_MEM_PORT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Hierarchical path to the target with respect to power</description>
    <id>POWER_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>
      PRD will perform error isolation for certain errors that may cause a HWP
      to fail. This attribute will be used by the HWP to store the PLID so that
      PRD can subsequently check it for a non-zero value and link the HWP PLID
      to the PRD error log.
    </description>
    <id>PRD_HWP_PLID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
       Tracks if a specific core has previously experienced a timeout during
       initial activation.
          0 = No previous errors reported;
          1 = Core failed on the last attempt to be started
    </description>
    <id>PREVIOUS_WAKEUP_FAIL</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines a target's primary capabilities.
        A target can only support at most FSI SCOM and one of the other two SCOM
        types.  Applicable for all targets.  Structure is read-only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support FSI SCOM;
            0b1: Target supports FSI SCOM
            </description>
        <name>supportsFsiScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support XSCOM;
            0b1: Target supports FSI XSCOM</description>
        <name>supportsXscom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support inband SCOM</description>
        <name>supportsInbandScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute which describes capabilities of a target</description>
    <id>PRIMARY_CAPABILITIES</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>Required Processor Compatibility Setting</description>
    <id>PROC_COMPATIBILITY_REQ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <id>PROC_COMPATIBILITY_REQ</id>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      PROC_CHIP Attribute
        If true, the chip is installed on a Dual Chip Module
        Provided by the Machine Readable Workbook
    </description>
    <id>PROC_DCM_INSTALLED</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Type of Master, ACTING_MASTER or MASTER_CANDIDATE or
      NOT_MASTER</description>
    <hasStringConversion></hasStringConversion>
    <id>PROC_MASTER_TYPE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>NOT_MASTER</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>PCIE IOP lane configuration
      creator: platform
      consumer: proc_pcie_scominit
      firmware notes:
        Encoded PCIE IOP lane configuration
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_IOP_CONFIG</id>
    <ignoreEkb></ignoreEkb>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        PCIE iovalid enable valid mask
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOVALID_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_IOVALID_ENABLE</id>
    <ignoreEkb></ignoreEkb>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Indicates whether PCIE lanes terminate at a pluggable slot
        Creator: MRW
        Purpose: Used by FW to know whether the given PCIE lanes terminate at a
            pluggable slot or not.  If this is the case, and the platform
            supports bifurcation, the card's VPD should be interrogated to
            determine whether to bifurcate the IOP or not.
        Data Format: x4 array of uint8_t values.  The first value indicates
            whether lane set 0 terminates at a pluggable slot.  The
            next three values indicate the same for lane sets 1-3. A value of
            1 at a given array index indicates the lanes terminate at a
            pluggable slot, 0 otherwise.
    </description>
    <id>PROC_PCIE_IS_SLOT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Equalization values for each PHB
        Creator: MRW
        Purpose: Holds settings which are loaded into the HW to optimize the
            PCIE lane signal eye between the chips + PCIE Gen3 endpoints
        Data Format: 16 entries of 16 bytes of EQ data per PHB.  Each PHB has an EQ
            value for each of its 16 lanes.  Each value is a uint16 formatted as
            follows:
                Bit 0:3   - up_rx_hint (bit 0 reserved)
                Bit 4:7   - up_tx_preset
                Bit 8:11  - dn_rx_hint (bit 0 reserved)
                Bit 12:15 - dn_tx_preset
    </description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN3</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777
        </default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Equalization values for each PHB
        Creator: MRW
        Purpose: Holds settings which are loaded into the HW to optimize the
            PCIE lane signal eye between the chips + PCIE Gen4 endpoints
        Data Format: 16 entries of 16 bytes of EQ data per PHB.  Each PHB has an EQ
            value for each of its 16 lanes.  Each value is a uint16 formatted as
            follows:
                Bit 0:3   - up_rx_hint (bit 0 reserved)
                Bit 4:7   - up_tx_preset
                Bit 8:11  - dn_rx_hint (bit 0 reserved)
                Bit 12:15 - dn_tx_preset
    </description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN4</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777
        </default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Effective PCIE Lane Mask
        Creator: Firmware
        Purpose: Holds the effective PCIE lane mask of each PEC after taking
            into account any IOP bifurcations. If no IOP bifurcations present,
            this is just the value of the PEC_PCIE_LANE_MASK_NON_BIFURCATED
            attribute
        Data Format: x4 array of uint16_t values.  The uint16_t value is a
            mask for lane 0, the next for lane 1 and so on until lane 3.
            A lane set mask indicates which groups of lanes are assigned to an
            IOP.  For instance, lane set 0 value of 0xFFFF and lane set 1 value
            of 0x0000 for PEC0 means PEC0 is a x16. Lane set 0 value of 0xFF00
            and lane set 2 value of 0x00FF for PEC0, means the IOP is bifurcated
            into two x8s.
    </description>
    <id>PROC_PCIE_LANE_MASK</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      creator: platform
        Number of PCIe PEC units present on target
        Nimbus: 3
  </description>
    <id>PROC_PCIE_NUM_PEC</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        PCS rx loff control
        creator: platform
        consumer: p9_pcie_scominit
        firmware notes:
        The value of rx loff control for PCS.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
    </description>
    <id>PROC_PCIE_PCS_RX_LOFF_CONTROL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Value of PCS rx phase rotator control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <id>PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Value of PCS rx sigdet control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <id>PROC_PCIE_PCS_RX_SIGDET_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        PCS rx vga control register3
        creator: platform
        consumer: p9_pcie_scominit
        firmware notes:
        The value of rx vga control register3.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
    </description>
    <id>PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4</array>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Value of PCS system control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_SYSTEM_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_SYSTEM_CNTL</id>
    <ignoreEkb></ignoreEkb>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Value of PCS tx fifo config offset
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <id>PROC_PCIE_PCS_TX_FIFO_CONFIG_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE PHB valid mask
      creator: platform
      consumer: proc_pcie_scominit
      firmware notes:
        Bit mask defining set of active/valid PHBs
        bit0=PHB0, bit1=PHB1, bit2=PHB2, bit3=PHB3
  </description>
    <id>PROC_PCIE_PHB_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>PCIE refclock enable valid mask
      PCIE refclock enable valid mask
      creator: platform
      consumer: p9_pcie_scominit
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_REFCLOCK_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_REFCLOCK_ENABLE</id>
    <ignoreEkb></ignoreEkb>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Defines system specific value of processor refclock receiver termination (FSI GP4 bits 8:9)
    </description>
    <hasStringConversion></hasStringConversion>
    <id>PROC_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
    Specifies which SEEPROM image should be used to boot a processor
      FIRST  - the first image was selected
      SECOND - the second image was selected
  </description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
    Specifies which SEEPROM image should be used for the boot master.
      FIRST  - the first image was selected
      SECOND - the second image was selected
      Platforms are expected to set this to FIRST in normal operation
  </description>
    <id>PROC_SELECT_SEEPROM_IMAGE</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Base Address of PSI Bridge Logic</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PSI_BRIDGE_BASE_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>PSIHB - ESB space address - MMIO consumed by PHYP
    </description>
    <id>PSI_HB_ESB_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
       Raw value of system MTM
    </description>
    <id>RAW_MTM</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      The number of reconfig loops allowed due to RCD parity errors when
      recovery is disabled. PRD will make a predictive callout and stop issuing
      reconfigs due to RCD parity errors when RCD_PARITY_RECONFIG_LOOP_COUNT is
      greater than this value. A value of 0 indicates that no reconfig loops are
      allowed due to RCD parity errors.
    </description>
    <id>RCD_PARITY_RECONFIG_LOOPS_ALLOWED</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      PRD will increment this count and issue a reconfig loop each time an RCD
      parity error (recovery disabled) is detected during Memory Diagnostics.
      This value will be cleared at the end of Memory Diagnostics if it is able
      to complete without the need to issue a reconfig loop.
    </description>
    <id>RCD_PARITY_RECONFIG_LOOP_COUNT</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description> System attribute array that defines the reconfig loop test cases
      consumer: istep dispatcher reconfigLoopTestRunner function
      This array is loaded with data via attribute override. The attribute is
      then read  and then overlayed onto a test case structure.
  </description>
    <id>RECONFIG_LOOP_TESTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>5</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Indicates whether reconfigure loop tests are enabled.
        This attribute is set via attribute override
    </description>
    <id>RECONFIG_LOOP_TESTS_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        1 = System has redundant clock oscillators
        0 = System does not have redundant clock oscillators
        From the Machine Readable Workbook
    </description>
    <id>REDUNDANT_CLOCKS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      A target's position relative to its immediate parent target.

      PROC - EQ - EX - CORE
      PROC - XBUS
      PROC - OBUS - OBUS_BRICK
      PROC - SBE
      PROC - PPE
      PROC - PERV
      PROC - PEC - PHB
      PROC - CAPP
      PROC - NMMU
      PROC - PAUC
      PROC - PAU
      PROC - IOHS
      PROC - MCBIST - MCS - MCA/MEM_PORT - DIMM
      PROC - MC - MI - DMI
      PROC - MC - MI - MCC - OMI
        (OMIC - OMI is not supported)
      PROC - PMIC
      MEMBUF - MBA - DIMM
      MEMBUF - L4
      OCMB - MEM_PORT - DIMM

    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_REL_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>REL_POS</id>
    <ignoreEkb></ignoreEkb>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Used to tell if a resource is critical to perform an IPL. If this
        attribute is set to 1 and the target is deconfigured, the IPL MUST
        terminate.
    </description>
    <id>RESOURCE_IS_CRITICAL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Where did the RISK_LEVEL setting originate?
    This is used to make sure the MRW isn't setting an invalid level
    for FORCED_COMPATIBILITY.
    </description>
    <id>RISK_LEVEL_ORIGIN</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <id>RISK_LEVEL_ORIGIN</id>
      </enumeration>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Size of RNG IO Region</description>
    <id>RNG_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0x000000000001000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base Address of RNG IO Region</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>RNG_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Policy indicating whether to perform the maximum amount of memory
            pattern testing possible or not.
        Set to 0x01 to perform the maximum amount of memory pattern testing
            possible.
        Set to 0x00 to perform the default amount of memory pattern testing.
    </description>
    <id>RUN_MAX_MEM_PATTERNS</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            uint8_t attribute to be used for storing functional state of a target during
            test cases.
        </description>
    <id>SAVED_STATE_UINT8</id>
    <no_export></no_export>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        A hexadecimal value of the commit ID associated
        with the SBE.
    </description>
    <id>SBE_COMMIT_ID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        If 0, SBE for the processor has not been started.
        Otherwise, SBE for the processor has been started.
    </description>
    <id>SBE_IS_STARTED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        An ascii value of the SBE release tag
    </description>
    <id>SBE_RELEASE_TAG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <default></default>
        <sizeInclNull>21</sizeInclNull>
      </string>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Control execution of updateProcessorSbeSeeproms()

      if 0, enable SBE update of processor SEEPROM
      if 1, disable SBE update of processor SEEPROM

      Consumer:  sbe_update.C

      Default:  0
    </description>
    <id>SBE_UPDATE_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        A hexadecimal value of the major and minor
        version of the SBE.  The major info is in the
        first 16 bits followed by the minor.
        0:15: Major Version
        16:31: Minor Version
    </description>
    <id>SBE_VERSION_INFO</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines which SCOM to use at a point in
        time.  Only applicable if target supports one or more SCOM types.  Only
        one bit (of the first three) can ever be set at any one time.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use FSI SCOM at this time.  0b1: Use FSI
            SCOM at this time</description>
        <name>useFsiScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use XSCOM at this time.  0b1: Use XSCOM at
            this time</description>
        <name>useXscom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use inband SCOM at this time.  0b1: Use
            inband SCOM at this time</description>
        <name>useInbandScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use SBE SCOM at this time.  0b1: Use
            SBE SCOM at this time</description>
        <name>useSbeScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
          0b0: Do not use I2C SCOM at this time.
          0b1: Use I2C SCOM at this time
        </description>
        <name>useI2cScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>3</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute storing information about which SCOM path to use</description>
    <id>SCOM_SWITCHES</id>
    <no_export></no_export>
    <persistency>volatile</persistency>
    <readable></readable>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        To deconfigure a TPM in a secure system - 01 to set TDP bit
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SECUREBOOT_PROTECT_DECONFIGURED_TPM</id>
    <ignoreEkb></ignoreEkb>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>PCIe slot index definition</description>
    <id>SLOT_INDEX</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIe slot name definition</description>
    <id>SLOT_NAME</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      The socket power in nominal mode.
      Controls how much power can be used.
      This is the same for all cores in the system.
      Data is provided by MVPD #V.
    </description>
    <id>SOCKET_POWER_NOMINAL</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      The socket power in turbo mode.
      Controls how much power can be used.
      This is the same for all cores in the system.
      Data is provided by MVPD #V.
    </description>
    <id>SOCKET_POWER_TURBO</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <complexType>
      <description>
         Structure which defines a system's SP functions.
         Applicable for System target only.  Structure is read-only.
         Default values match OpenBMC implementation.
      </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             If this flag is set then mailboxEnabled MUST also be set

             0b0: SP does not support for VPD, payload, ATTR sync, VDDR, TOD;
             0b1: SP supports VPD, payload, ATTR sync, VDDR, TOD
            </description>
        <name>baseServices</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not initialize FSI slave logic, Hostboot must;
             0b1: SP does initialize FSI slave logic so Hostboot should not
            </description>
        <name>fsiSlaveInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: There is no SP mailbox support;
             0b1: There is SP mailbox support
            </description>
        <name>mailboxEnabled</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not initialize FSI master logic, Hostboot must;
             0b1: SP does initialize FSI master logic so Hostboot should not
            </description>
        <name>fsiMasterInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not perform hardware change detection, Hostboot must;
             0b1: SP does perform hardware change detection (HCDB) so Hostboot should not
            </description>
        <name>hardwareChangeDetection</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not perform Power Line Disturbance (PLD) detection, Hostboot must;
             0b1: SP does perform Power Line Disturbance (PLD) detection so Hostboot should not
            </description>
        <name>powerLineDisturbance</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>26</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>
      Attribute which describes what the SP is or is not doing in this system
    </description>
    <id>SP_FUNCTIONS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>
      Specifies the starting memory address that corresponds to the TCE Token
      used by the FSP to transfer the PAYLOAD into system memory.
      If 0xFFFFFFFFFFFFFFFF, then invalid; otherwise, valid.
  </description>
    <id>START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description> Control CME response to execution of PowerPC STOP instruction
    if OFF, treat STOP5 as STOP5
    if ON,  treat STOP5 as STOP4

    Producer: ???

    Consumer:  p8_hcode_image_build.C

    Platform default: OFF
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP5_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP5_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      STOP levels supported at runtime (sent to Host via HDAT):
        Bit 0: STOP0 Supported - Quiesce thread only
        Bit 1: STOP1 Supported - P8 Nap
        Bit 2: STOP2 Supported - P8 Fast Sleep
        Bit 3: STOP3 Supported - P8 Fast Sleep using iVRMs
        Bit 4: STOP4 supported - P8 Deep Sleep
        Bit 5: STOP5 Supported - WOF-friendly &quot;Instant on&quot;
        Bit 6,7: Reserved
        Bit 8: STOP8 supported - Half Quad Sleep
        Bit 9: STOP9 supported - P8 Fast Winkle
        Bit 10: Reserved
        Bit 11: STOP11 supported - P8 Deep Winkle
        Bit 12-15 : Reserved
        Bits 16..31 - Reserved
  </description>
    <id>SUPPORTED_STOP_STATES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0xEC100000</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Do we support dynamically updating memory voltages?
        0 = no, 1 = yes
    </description>
    <id>SUPPORTS_DYNAMIC_MEM_VOLT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Attribute to enable targetting attribute sync when in istep mode.
        1 = sync will occur following each substep when ipl'ing in single step mode
        0 = sync will not be done after each step
    </description>
    <id>SYNC_BETWEEN_STEPS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        This field is of the form &quot;vendor,name&quot; where the name indicates
        the family of the systems.  The textual portion of the string has
        a maximum length of 63 characters to accommodate a terminating NULL.
        Both vendor and name fields are lower case US ASCII. No special
        characters other than &quot;,&quot;, &quot;-&quot;, and &quot;+&quot; as described below should
        be used in the string.
    </description>
    <id>SYSTEM_FAMILY</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <default>ibm,p9</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This field is of the form ?vendor,type? where the type indicates
        a type of system within the System Family. The textual portion of
        the string has a maximum length of 63 characters to accommodate a
        terminating NULL. Both vendor and name fields are lower case US
        ASCII. No special characters other than &quot;,&quot;, &quot;-&quot;, and &quot;+&quot; as described
        below should be used in the string.  If identification of specific
        models within a system type is desired, &quot;-model&quot; should be appended
        to the end of the name. The &quot;-model&quot; portion is optional and could be
        used to identify the packaging, specific model numbers, etc.
        NOTE: No Hostboot code should ever key off of this value.
    </description>
    <id>SYSTEM_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <default>ibm,miscopenpower</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Specifies which TCE Token the FSP should start with to transfer the
      HDAT section into system memory.
      If 0xFFFFFFFF, then invalid; otherwise, valid.
  </description>
    <id>TCE_START_TOKEN_FOR_HDAT</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Specifies which TCE Token the FSP should start with to transfer the
      PAYLOAD into system memory.
      If 0xFFFFFFFF, then invalid; otherwise, valid.
  </description>
    <id>TCE_START_TOKEN_FOR_PAYLOAD</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>TEMP_SENSOR_I2C_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>Test attribute; largest string possible given size</description>
    <id>TEST_MAX_STRING</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <default>abc</default>
        <sizeInclNull>4</sizeInclNull>
      </string>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Test attribute; smallest string possible given size</description>
    <id>TEST_MIN_STRING</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <default>a</default>
        <sizeInclNull>10</sizeInclNull>
      </string>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Attribute to test signed attribute
        functionality in the system</description>
    <id>TEST_NEGATIVE_FCN</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <int8_t>
        <default>-6</default>
      </int8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Test attribute; string with no default supplied</description>
    <id>TEST_NO_DEFAULT_STRING</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <sizeInclNull>10</sizeInclNull>
      </string>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Test attribute; string with empty default value</description>
    <id>TEST_NULL_STRING</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <default></default>
        <sizeInclNull>10</sizeInclNull>
      </string>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Thread Count</description>
    <id>THREAD_COUNT</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x4</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Time Base frequency in MHZ</description>
    <id>TIME_BASE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x800000</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>TLB Data Associative Sets</description>
    <id>TLB_DATA_ASSOC_SETS</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>TLB Data Entries</description>
    <id>TLB_DATA_ENTRIES</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>TLB Instruction Associative Sets</description>
    <id>TLB_INSTR_ASSOC_SETS</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>TLB Instruction Entries</description>
    <id>TLB_INSTR_ENTRIES</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Reserve Size in bytes</description>
    <id>TLB_RESERVE_SIZE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>TOD CHIP DATA for each CHIP
        The size of the TOD CHIP DATA must be equal to the sizeof(TodChipData)
    </description>
    <id>TOD_CPU_DATA</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>44</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Bitmask indicating what role this chip has in tod topology
    </description>
    <id>TOD_ROLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     TPM.</description>
      <field>
        <default>0x0</default>
        <description>Boolean indicating whether this TPM is available
              in the system</description>
        <name>tpmEnabled</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x01</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xAE</default>
        <description>Device address on the I2C bus for Locality 0.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
        <name>devAddrLocality0</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA8</default>
        <description>Device address on the I2C bus for Locality 1.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
        <name>devAddrLocality1</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xAA</default>
        <description>Device address on the I2C bus for Locality 2.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
        <name>devAddrLocality2</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA4</default>
        <description>Device address on the I2C bus for Locality 3.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
        <name>devAddrLocality3</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA6</default>
        <description>Device address on the I2C bus for Locality 4.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
        <name>devAddrLocality4</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x00</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the TPM slaves</description>
    <id>TPM_INFO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>
        A flag indicating whether the TPM has been poisoned. A poisoned TPM
        has a random number extended into its PCR but not mirrorred to its
        log. That creates a disconnection between the TPM and its log, which
        in turn makes it impossible to perform remote attestation on the TPM.
    </description>
    <id>TPM_POISONED</id>
    <no_export></no_export>
    <persistency>volatile-zeroed</persistency>
    <range>
      <max>1</max>
      <min>0</min>
    </range>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Setting to require(0x1) or not require(0x0) a functional TPM to
        boot the system.
    </description>
    <id>TPM_REQUIRED</id>
    <persistency>non-volatile</persistency>
    <range>
      <max>1</max>
      <min>0</min>
    </range>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Indicates whether the TPM is unusable. Hostboot should not read this
        value for any purpose other than tracing. This value should only be
        written to when there is a certainty that the TPM is not usable.
        This attribute is consumed by FSP during alignment check to determine
        the optimal boot configuration. This attribute can be removed if TPM
        gard is ever supported.
    </description>
    <id>TPM_UNUSABLE</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <range>
      <max>1</max>
      <min>0</min>
    </range>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's type</description>
    <hasStringConversion></hasStringConversion>
    <id>TYPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <id>TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        If non-zero then use value as the discovered MFR_REVISION value from
        the UCD device rather than the actual value from the device.
    </description>
    <id>UCD_MFR_REVISION_OVERRIDE</id>
    <no_export></no_export>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>1</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      The ultra turbo frequency in MHz.
      This is the same for all cores in the system.
      Data is provided by MVPD #V and is calculated as
      the minimum of the ultra turbo frequencies.
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_ULTRA_TURBO_NOMINAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>ULTRA_TURBO_FREQ_MHZ</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Specifies whether or not the FSP is ready for Hostboot to enable TCEs
      for DMAs for the given IPL.  This is a temporary attribute which will
      be used to phase-in TCE support.
      If 0, DO NOT use TCEs;
      If 1, use TCEs
  </description>
    <id>USE_TCES_FOR_DMAS</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Memory VCS voltage domain ID.  All memory buffers in the same VCS
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        genHwsvMrwXml.pl
    </description>
    <id>VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Voltage Memory Rail Manager ID.  Currently HB only needs
        to configured the Vddr voltage rail manager during the IPL.  The ID
        is an arbitary value and needed as correlation token between HB and
        HWSV.  It will be generated by the genHwsvMrwXml.pl.
    </description>
    <id>VDDR_ID</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Memory VDD voltage domain ID.  All memory buffers in the same VDD
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        genHwsvMrwXml.pl
    </description>
    <id>VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIe vendor ID definition</description>
    <id>VENDOR_ID</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Record offset for this target's VPD</description>
    <id>VPD_REC_NUM</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0xFFFF</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Memory VPP voltage domain ID.  All memory buffers in the same VPP
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        genHwsvMrwXml.pl
    </description>
    <id>VPP_ID</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      System control to set the power limit for Workload Optimized
      Frequency (WOF) algorithms.  This is used to select the
      proper VFRT tables.
      Producer: TMGT
      Consumers: FW that selects VFRT tables
    </description>
    <id>WOF_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      LID id used to load tables for Workload Optimized
      Frequency (WOF) algorithms.
      Producer: TMGT
      Consumers: FW that selects VFRT tables
    </description>
    <id>WOF_TABLE_LID_NUMBER</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x81E00440</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>XIVE - Controller Bar address
        MMIO consumed by PHYP
    </description>
    <id>XIVE_CONTROLLER_BAR_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>XIVE - Thread Management Bar address register 1
         MMIO consumed by HB/PHYP
    </description>
    <id>XIVE_THREAD_MGMT1_BAR_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>XSCOM base address</description>
    <id>XSCOM_BASE_ADDRESS</id>
    <no_export></no_export>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Indicates if Attribute Overrides are allowed when the system is booted
        in secure mode.  The default is 0x0, where attribute overrides are not
        allowed.  However, the SBE can read mailbox scratch register 3 bit 7
        to set it to 0x1, meaning that attribute overrides are allowed. The SBE
        passes this information up to hostboot via the bootloader.
            0x00 = Attribute Overrides are not allowed (default)
            0x01 = Attribute Overrides are allowed
    </description>
    <hbOnly></hbOnly>
    <id>ALLOW_ATTR_OVERRIDES_IN_SECURE_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Returns whether to treat SBE as quiesced or not.  When Hostboot goes
        through an SBE update (always during key transition, possibly during
        normal flow), it may attempt to quiesce the SBE.  Whether or not this
        was successful, firmware should treat the SBE as if it had been
        quiesced (and inhibit attribute synchronization during shutdown, etc.)

        Valid values (bool):
             0x00: Do not assume SBE is quiesced
            !0x00: Assume SBE is quiesced
    </description>
    <hbOnly></hbOnly>
    <id>ASSUME_SBE_QUIESCED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Used to tell ATTN code whether to chk MASTER(0) OR all PROCs(1)
      when the checkForIplAttns routine is called.
    </description>
    <id>ATTN_CHK_ALL_PROCS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Are we doing checkstop analysis on
      systems as we are booting back up based
      on information captured in FIRDATA section.
  </description>
    <id>CHKSTOP_ANALYSIS_ON_STARTUP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Used to enable clearing of SPD on all present DIMMs. This attribute is
      set via attribute override.
    </description>
    <id>CLEAR_DIMM_SPD_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>The size of DIMM (in bytes) within the SPD.  This a raw value,
                 512 = 512 bytes, 1024 = 1024 bytes or 1 kilobyte, etc.
                 This is set programatically, not designed for a static value.
    </description>
    <id>DIMM_SPD_BYTE_SIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Indicates which istep we should execute the CXX testcases after, if
        CONFIG_EARLY_TESTCASES is set.
        Format: 0xMMmm, where MM=major step, mm=minor step, e.g. 6.9=0x0609.
    </description>
    <id>EARLY_TESTCASES_ISTEP</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0x0609</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Used to keep track of which EEPROM page the current I2C master bus is set to
        0 = PAGE_ZERO
        1 = PAGE_ONE
        2 = UNKNOWN_PAGE
    </description>
    <id>EEPROM_PAGE_ARRAY</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>4,4</array>
      <uint8_t>
        <default>2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        The frequency of the memory controller channel. In synchronous mode,
        this is equivalent to ATTR_FREQ_PB_MHZ. This may be independently set
        per pair of memory channels if operating in asynchronous mode,
        but this configuration is not anticipated. This clock drives the MCU queues,
        and all the associated logic that drives the inputs to the DMI and reads
        its outputs
    </description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_MCA_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_MCA_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Mutex for FSI Master Operations</description>
    <hbOnly></hbOnly>
    <id>FSI_MASTER_MUTEX</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbmutex></hbmutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Mutex for FSI-based SCOM Operations</description>
    <hbOnly></hbOnly>
    <id>FSI_SCOM_MUTEX</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbmutex></hbmutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Effective ID used by the hypervisor to specify a given target. A value
      of 0xFFFFFFFFFFFFFFFF means invalid/unknown.
  </description>
    <hbOnly></hbOnly>
    <id>HBRT_HYP_ID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Indicates which logical nodes have a hostboot image.</description>
    <hbOnly></hbOnly>
    <id>HB_EXISTING_IMAGE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Indicates that a chip has already been put into reset elsewhere
        such that the next reset request will be skipped.
    </description>
    <id>HB_INITIATED_PM_RESET</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Host boot mutex for testing</description>
    <hbOnly></hbOnly>
    <id>HB_MUTEX_TEST_LOCK</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbmutex></hbmutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Mutex to guard Node Comm ABUS register access</description>
    <hbOnly></hbOnly>
    <id>HB_NODE_COMM_ABUS_MUTEX</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbmutex></hbmutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Mutex to guard Node Comm XBUS register access</description>
    <hbOnly></hbOnly>
    <id>HB_NODE_COMM_XBUS_MUTEX</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbmutex></hbmutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Host boot recursive mutex for testing</description>
    <hbOnly></hbOnly>
    <id>HB_RECURSIVE_MUTEX_TEST_LOCK</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbrecursivemutex></hbrecursivemutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        The next HB reserved memory section available to assign
        a new reserved memory range.
    </description>
    <id>HB_RSV_MEM_NEXT_SECTION</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Describes if the processor's SBE's seeprom versions match or not
        0x0 = MATCH
        0x1 = MISMATCH
    </description>
    <id>HB_SBE_SEEPROM_VERSION_MISMATCH</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        This attribute indicates if the target can be SCOMed.
        It's used in FSP only but declared here because the attribute
        is defined in chip_attributes.xml, which is a common file
        between FSP and HB (without this, HB will get a compilation error).
    </description>
    <hbOnly></hbOnly>
    <hwpfToHbAttrMap>
      <id>ATTR_TARGET_SCOMABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>HB_TARGET_SCOMABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Whether TPM initialization was attempted or not
            0x00 (false) = Did not attempt to initialize TPM
            0x01 (true)  = Attempted to initialize TPM
    </description>
    <hbOnly></hbOnly>
    <id>HB_TPM_INIT_ATTEMPTED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Pointer to TPM log manager</description>
    <hbOnly></hbOnly>
    <id>HB_TPM_LOG_MGR_PTR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Mutex to guard TPM access</description>
    <hbOnly></hbOnly>
    <id>HB_TPM_MUTEX</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbmutex></hbmutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Used to decide whether or not to prevent INFORMATIONAL/RECOVERED error
        logs from being sent to the BMC via SEL/eSEL, saved to the PNOR, and
        displayed to the console.
        0 = Prevent INFORMATIONAL/RECOVERED error logs from being processed.
        1 = Send only INFORMATIONAL error logs.
        2 = Send only RECOVERED error logs.
        3 = Allow all hidden error logs to be processed.
    </description>
    <id>HIDDEN_ERRLOGS_ENABLE</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Attribute to check if HCODE is loaded in HOMER
    </description>
    <hbOnly></hbOnly>
    <id>HOMER_HCODE_LOADED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Virtual address where HOMER memory is mapped into.  If value is zero,
        memory must be mapped into virtual space.
    </description>
    <hbOnly></hbOnly>
    <id>HOMER_VIRT_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Mutex for I2C Master engine 0</description>
    <hbOnly></hbOnly>
    <id>I2C_ENGINE_MUTEX_0</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbrecursivemutex></hbrecursivemutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Mutex for I2C Master engine 1</description>
    <hbOnly></hbOnly>
    <id>I2C_ENGINE_MUTEX_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbrecursivemutex></hbrecursivemutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Mutex for I2C Master engine 2</description>
    <hbOnly></hbOnly>
    <id>I2C_ENGINE_MUTEX_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbrecursivemutex></hbrecursivemutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Mutex for I2C Master engine 3</description>
    <hbOnly></hbOnly>
    <id>I2C_ENGINE_MUTEX_3</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbrecursivemutex></hbrecursivemutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Mutex to protect page select operations for I2C Master engine 0
    </description>
    <hbOnly></hbOnly>
    <id>I2C_PAGE_MUTEX_0</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbmutex></hbmutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Mutex to protect page select operations for I2C Master engine 1
    </description>
    <hbOnly></hbOnly>
    <id>I2C_PAGE_MUTEX_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbmutex></hbmutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Mutex to protect page select operations for I2C Master engine 2
    </description>
    <hbOnly></hbOnly>
    <id>I2C_PAGE_MUTEX_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbmutex></hbmutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Mutex to protect page select operations for I2C Master engine 3
    </description>
    <hbOnly></hbOnly>
    <id>I2C_PAGE_MUTEX_3</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbmutex></hbmutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Used to force IBSCOM enabled for lab testing</description>
    <hbOnly></hbOnly>
    <id>IBSCOM_ENABLE_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Mutex for Inband SCOM Operations</description>
    <hbOnly></hbOnly>
    <id>IBSCOM_MUTEX</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbmutex></hbmutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Cached Virtual Address of Inband Scom memory space for this Chip</description>
    <hbOnly></hbOnly>
    <id>IBSCOM_VIRTUAL_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Global IPC Buffer Addresseses for each Node
        dimension: node number (0:7)
    </description>
    <id>IPC_NODE_BUFFER_GLOBAL_ADDRESS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>8</array>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>1 = in Memory Preserving IPL mode. 0 = in normal IPL mode.</description>
    <hbOnly></hbOnly>
    <hwpfToHbAttrMap>
      <id>ATTR_IS_MPIPL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IS_MPIPL_HB</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>0 = is master node, 1 = is slave node</description>
    <id>IS_SLAVE_DRAWER</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Value of the master mailbox scratch regs
      at the beginning of the boot.  Need to save these
      away since HB uses some of them for communication purposes.
    </description>
    <hbOnly></hbOnly>
    <id>MASTER_MBOX_SCRATCH</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>16</array>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Working offset for MEMD section, this allows us to move between
            the different MEMD instances and the MEMD header.
    </description>
    <id>MEMD_OFFSET</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
            Virtual memory address this device has been mapped to.
    </description>
    <id>MMIO_VM_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Actual MDRT count in Memory Preserving IPL mode.</description>
    <hbOnly></hbOnly>
    <id>MPIPL_HB_MDRT_COUNT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR
        voltage setpoint. In mV.
    </description>
    <hbOnly></hbOnly>
    <id>MRW_DDR3_VDDR_MAX_LIMIT_EFF_CONFIG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage
        setpoint. In mV.
    </description>
    <hbOnly></hbOnly>
    <id>MRW_DDR4_VDDR_MAX_LIMIT_EFF_CONFIG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <hbOnly></hbOnly>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT_EFF_CONFIG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <hbOnly></hbOnly>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE_EFF_CONFIG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <hbOnly></hbOnly>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT_EFF_CONFIG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <hbOnly></hbOnly>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE_EFF_CONFIG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <hbOnly></hbOnly>
    <id>MSS_VOLT_VPP_INTERCEPT_EFF_CONFIG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Units: uV/DRAM
    </description>
    <hbOnly></hbOnly>
    <id>MSS_VOLT_VPP_SLOPE_EFF_CONFIG</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Physical address where OCC Common Area is placed in mainstore.
    </description>
    <hbOnly></hbOnly>
    <id>OCC_COMMON_AREA_PHYS_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      While in Secureboot, this value is set to 1 the first time attribute
      override is attempted and error logged.
    </description>
    <hbOnly></hbOnly>
    <id>OVERRIDES_ATTEMPTED_FLAG</id>
    <no_export></no_export>
    <persistency>volatile-zeroed</persistency>
    <range>
      <max>1</max>
      <min>0</min>
    </range>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>The part number for a particular FRU target</description>
    <hbOnly></hbOnly>
    <hwpfToHbAttrMap>
      <id>ATTR_PART_NUMBER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PART_NUMBER</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>48</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Processor Dump Area Table's captured thread
        register state array address.
    </description>
    <hbOnly></hbOnly>
    <id>PDA_CAPTURED_THREAD_REG_ARRAY_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Processor Dump Area Table's captured thread
        register state array size.
    </description>
    <hbOnly></hbOnly>
    <id>PDA_CAPTURED_THREAD_REG_ARRAY_SIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Processor Dump Area Table's thread register entry size.
    </description>
    <hbOnly></hbOnly>
    <id>PDA_THREAD_REG_ENTRY_SIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Processor Dump Area Table's thread entry format.
    </description>
    <hbOnly></hbOnly>
    <id>PDA_THREAD_REG_STATE_ENTRY_FORMAT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Virtual address where SBE Communications are placed in mainstore.
        This area is used for SBE message passing and may contain an SBE
        command or the response to it from HBRT.
    </description>
    <hbOnly></hbOnly>
    <id>SBE_COMM_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Virtual address where SBE FFDC is placed in mainstore.
    </description>
    <hbOnly></hbOnly>
    <id>SBE_FFDC_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Mutex for SCAN operations</description>
    <hbOnly></hbOnly>
    <id>SCAN_MUTEX</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbmutex>
        <default>0</default>
      </hbmutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Mutex for Indirect SCOM read operation</description>
    <hbOnly></hbOnly>
    <id>SCOM_IND_MUTEX</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <hbmutex></hbmutex>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>The serial number for a particular FRU target</description>
    <hbOnly></hbOnly>
    <hwpfToHbAttrMap>
      <id>ATTR_SERIAL_NUMBER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SERIAL_NUMBER</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>18</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Keep track of the calls to Special Wakeup. Increment for each
        call to enable, decrement for each call to disable. Not
        thread-safe, used at runtime which is single-threaded.
    </description>
    <hbOnly></hbOnly>
    <id>SPCWKUP_COUNT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Indicates TPM Model (or family) for a TPM Target
            0x00 = Undetermined (reserved if actively detected in the future)
            0x01 = Nuvoton 65x (default)
            0x02 = Nuvoton 75x
    </description>
    <id>TPM_MODEL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Whether the TPM is primary or backup within its parent node.  It is
        dynamically computed during the boot.
    </description>
    <hbOnly></hbOnly>
    <id>TPM_ROLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <complexType>
      <description>VPD flags</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Set when this target's VPD data has been loaded
                from EEPROM into the PNOR.
            </description>
        <name>pnorCacheValid</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>See pnorCacheValid. Allows runtime version to be
                set separately from common version.
            </description>
        <name>pnorCacheValidRT</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Set to disable write-thru to PNOR at runtime
            </description>
        <name>disableWriteToPnorRT</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute storing VPD state information</description>
    <id>VPD_SWITCHES</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      The selected WOF frequency uplift table.
  </description>
    <hbOnly></hbOnly>
    <id>WOF_FREQUENCY_UPLIFT_SELECTED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>22,13</array>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Cached Virtual Address of Xscom memory space for this Chip</description>
    <hbOnly></hbOnly>
    <id>XSCOM_VIRTUAL_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>LX keyword VPD data for HDAT module
    </description>
    <id>ASCII_VPD_LX_KEYWORD</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's chip version</description>
    <hasStringConversion></hasStringConversion>
    <id>CHIP_VER</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <id>CHIP_VER</id>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        User configuration for creating default partition
    </description>
    <id>CREATE_DEF_PARTITION</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        User configuration for Enlarged IO SLot Count
    </description>
    <id>ENLARGED_IO_SLOT_COUNT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
       Huge Memory Page Count
    </description>
    <id>HUGE_PAGE_COUNT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
       Huge Memory Page Size
    </description>
    <id>HUGE_PAGE_SIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's hw version</description>
    <hasStringConversion></hasStringConversion>
    <id>HW_VER</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <id>HW_VER</id>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Hypervisor IPL Destination
    </description>
    <id>HYPERVISOR_IPL_DESTINATION</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
       Platform IPL Side
    </description>
    <id>HYPERVISOR_IPL_SIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
       Hypervisor Dispatch Wheel
    </description>
    <id>HYP_DISPATCH_WHEEL</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <complexType>
      <description>struct - 8 booleans </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Dont create default partition;
             0b1: Create default partition;
            </description>
        <name>createDefaultPartition</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Customer has not accepted license agreement;
             0b1: Customer has accepted license agreement;
            </description>
        <name>clickToAcceptState</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Enable Virtual IO Connections between partitions;
             0b1: Disable Virtual IO Connections between partitions;
            </description>
        <name>disableVirtIO</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Do not reset PCI Numbers;
             0b1: Reset PCI Numbers;
            </description>
        <name>resetPCINumbers</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Do not clear HYP NVRAM;
             0b1: Clear HYP NVRAM;
            </description>
        <name>clearHypNVRAM</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Do not delete SELs originating from HYP;
             0b1: Delete SELs originating from HYP;
            </description>
        <name>deleteHYPSELs</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Do not delete SELs originating from Hostboot;
             0b1: Delete SELs originating from Hostboot;
            </description>
        <name>deleteHBSELs</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Do not delete SELs originating from BMC;
             0b1: Delete SELs originating from BMC;
            </description>
        <name>deleteBMCSELs</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
       Assorted list of differnt IPL attributes passed via HDAT
   </description>
    <id>IPL_ATTRIBUTES</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Indicates if Idle Power Save is enabled.  This is independent of
        the OPEN_POWER_PM_MODE (DPS and IPS can be enabled at the same time).
        Valid Values: 0 = Disabled (default), 1 = Enabled.
        See IPS_ENTER / IPS_EXIT attributes for IPS configuration.
    </description>
    <id>IPS_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        When IPS is enabled, this defines the delay time in seconds
        (between 10 and 600) to enter Idle Power Save.
    </description>
    <id>IPS_ENTER_TIME_SECONDS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>240</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        When IPS is enabled, this defines the utilization threshold as a
        percent (between 0 and 100) to enter Idle Power Save.  This value
        should be less than IPS_EXIT_UTILIZATION_PERCENT.
    </description>
    <id>IPS_ENTER_UTILIZATION_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        When IPS is enabled, this defines the delay time in seconds
        (between 10 and 600) to exit Idle Power Save.
    </description>
    <id>IPS_EXIT_TIME_SECONDS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>10</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        When IPS is enabled, this defines the utilization threshold as a
        percent (between 0 and 100) to exit Idle Power Save.  This value
        should be greater than IPS_ENTER_UTILIZATION_PERCENT.
    </description>
    <id>IPS_EXIT_UTILIZATION_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>12</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
       Logical Memory Block Size
    </description>
    <id>LMB_SIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        User configuration for max HSL Opticonnect connections
    </description>
    <id>MAX_HSL_OPTICONNECT_CONNECTIONS</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
      Power management mode the system should use.
      Valid values: 1 = Nominal (default),
      5 = Static Power Save (percentage below nominal whose value
      is defined in OPEN_POWER_PM_MODE_FREQ_PERCENT),
      6 = Dynamic Power Save - Favor Energy (DPS-FE),
      10 = Dynamic Power Save - Favor Performance (DPS-FP),
      11 = Fixed Frequency Override - (percentage above nominal whose
      value is defined in OPEN_POWER_PM_MODE_FREQ_PERCENT)
    </description>
    <id>OPEN_POWER_PM_MODE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Percentage from nominal that the processors should run at when
        OPEN_POWER_PM_MODE is set to Static Power Save or
        Fixed Frequency Override (ignored on all other modes).
        Unit is in tenths of a percent (150 = 15.0%).
        Static Power Save (5): percentage to decrease frequency,
        Fixed Frequency Override (11): percentage to increase frequency
    </description>
    <id>OPEN_POWER_PM_MODE_FREQ_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
       Operating System IPL Mode
    </description>
    <id>OS_IPL_MODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>PHYP system type value for habanero
            and barreleye (0x3015 and 0x3016 respectively).
            The value is updated in the system xml.
    </description>
    <id>PHYP_SYSTEM_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        MFG setting to preserve MDC partition vpd
    </description>
    <id>PRESERVE_MDC_PARTITION_VPD</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Hardware topology for HDAT
        creator:MRW
        consumer:HDAT
        firmware notes:
        Hardware Topology 2 Bytes
        Byte 1:
            bit 0-3: Node Id
            bit 4-7: Socket id inside the node
            bit 8-11: Proc id inside socket
            bit 12-15:Hub Id inside proc
    </description>
    <id>PROC_HW_TOPOLOGY</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's role</description>
    <hasStringConversion></hasStringConversion>
    <id>ROLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <id>ROLE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>
       SLCA index for this FRU
    </description>
    <id>SLCA_INDEX</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
       SLCA RID for this FRU
    </description>
    <id>SLCA_RID</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's software version</description>
    <hasStringConversion></hasStringConversion>
    <id>SW_VER</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <enumeration>
        <id>SW_VER</id>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>
       Brand Name of OEM systems
    </description>
    <id>SYSTEM_BRAND_NAME</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
       Number of VLAN Switches
    </description>
    <id>VLAN_SWITCHES</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
       Virtual TPM Enabled
    </description>
    <id>VTPM_ENABLED</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>ADC Channel function id. 16 channels.</description>
    <id>ADC_CHANNEL_FUNC_IDS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>16</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>ADC channel gain * 1000. 16 channels.</description>
    <id>ADC_CHANNEL_GAINS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>16</array>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>ADC Channel ground. 16 channels.</description>
    <id>ADC_CHANNEL_GNDS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>16</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>ADC channel offset * 1000. 16 channels</description>
    <id>ADC_CHANNEL_OFFSETS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>16</array>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>ADC Channel IPMI sensor numbers. 16 channels.</description>
    <id>ADC_CHANNEL_SENSOR_NUMBERS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>16</array>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Flag used to allow sending informational call-home errors as ESELS to the BMC</description>
    <id>ALLOW_CALLHOME_ESELS_TO_BMC</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>APSS GPIO PORT MODES</description>
    <id>APSS_GPIO_PORT_MODES</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>APSS GPIO PORT PINS
        Port0 pin 0-7
        Port1 pin 8-15
    </description>
    <id>APSS_GPIO_PORT_PINS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>16</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>The type of hardware of the BMC</description>
    <id>BMC_HW_CHIP_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <default>ast2500</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>The manufacturer of the BMC</description>
    <id>BMC_MANUFACTURER</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <default>ibm</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>max size of error log that can be sent to BMC</description>
    <id>BMC_MAX_ERROR_LOG_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>2048</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>The software type of the BMC</description>
    <id>BMC_SW_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <default>openbmc</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        HTMGT calculates the total non-GPU maximum power in W when the
        CPUs are at max frequency and memory at max power (least throttled)
        and then adds MISC_SYSTEM_COMPONENTS_MAX_POWER_WATTS
    </description>
    <id>CALCULATED_MAX_SYS_POWER_EXCLUDING_GPUS</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0x0000</default>
      </uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        HTMGT calculates the total processor/memory power drop in W when the
        CPUs are at min frequency and memory at min power (most throttled).
        This is the how much CALCULATED_MAX_SYS_POWER_EXCLUDING_GPUS
        can be reduced by.
    </description>
    <id>CALCULATED_PROC_MEMORY_POWER_DROP</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0x0000</default>
      </uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Number of PM Complex resets since the system was booted.
        Value will only be cleared at power on.
    </description>
    <id>CUMULATIVE_PMCOMPLEX_RESET_COUNT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addessing for an I2C
                     slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>
                Logical GPIO pin number used to enabled/disable VDDR
            </description>
        <name>vddrPin</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address GPIO device</description>
    <id>GPIO_INFO</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
  </attribute>

  <attribute>
    <description>Attribute to hold 3 possible GPU sensors.
    Includes sensor types, ids, and OBUS_CFG bits
    </description>
    <id>GPU_SENSORS</id>
    <no_export></no_export>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>3,7</array>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This attribute holds the values of the I2C address from the i2c
        device connections as defined in the MRW.  It is parsed into a
        struct in i2c.C
    </description>
    <id>HDAT_I2C_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>32</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This attribute holds the values of the I2C bus frequency in Hz from
        the i2c device connections as defined in the MRW.  It is parsed
        into a struct in i2c.C
    </description>
    <id>HDAT_I2C_BUS_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>32</array>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This attribute holds the string descriptions of the I2C devices from
        the i2c device connections as defined in the MRW.  It is parsed into
        a struct in i2c.C
    </description>
    <id>HDAT_I2C_DEVICE_LABEL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>32</array>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This attribute holds the values of the I2C device purpose from the i2c
        device connections as defined in the MRW.  It is parsed into a
        struct in i2c.C
    </description>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>32</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This attribute holds the values of the I2C device type from the i2c
        device connections as defined in the MRW.  It is parsed into a
        struct in i2c.C
    </description>
    <id>HDAT_I2C_DEVICE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>32</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This attribute holds the number of elements that were found under this
        particular target, and how many devices are stored in the arrays.
    </description>
    <id>HDAT_I2C_ELEMENTS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This attribute holds the values of the I2C Engine from the i2c device
        connections as defined in the MRW.  It is parsed into a struct in i2c.C
    </description>
    <id>HDAT_I2C_ENGINE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>32</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This attribute holds the values of the I2C Master Port from the i2c
        device connections as defined in the MRW.  It is parsed into a
        struct in i2c.C
    </description>
    <id>HDAT_I2C_MASTER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>32</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This attribute holds the values of the I2C slave port from the i2c
        device connections as defined in the MRW.  It is parsed into a
        struct in i2c.C
    </description>
    <id>HDAT_I2C_SLAVE_PORT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>32</array>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>HTMGT internal flags
    </description>
    <id>HTMGT_INTERNAL_FLAGS</id>
    <persistency>volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t>
        <default>0x00000000</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
       Timer value used to periodically clear the PM Complex reset
       counters.  Used internally by HTMGT.
    </description>
    <id>HTMGT_PMCOMPLEX_RESET_COUNT_TIMER</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>1 = in safemode. 0 = in normal mode.</description>
    <hbOnly></hbOnly>
    <id>HTMGT_SAFEMODE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>User power limit information from the BMC to be used if
        communication with the BMC is lost after system is powered on.
        Used internally by HTMGT.
    </description>
    <id>HTMGT_SAVED_POWER_LIMIT</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Holds the IPMI instance number for this entity.</description>
    <id>IPMI_INSTANCE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>max buffer size to use for ipmi messages</description>
    <hbOnly></hbOnly>
    <id>IPMI_MAX_BUFFER_SIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>Attribute to hold 16 pairs of sensor name, sensor number
        pairs. A sensor name consists of one byte of general sensor type
        and one byte of sub-type</description>
    <id>IPMI_SENSORS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <array>16,2</array>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Specifies if the mpipl is supported on this platform
        0 : No , 1 : Yes
    </description>
    <id>IS_MPIPL_SUPPORTED</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
       Maximum theoretical Vdd current reading in 10mA units.
       Used when VDD_CURRENT_OVERFLOW_WORKAROUND_ENABLE is set.
    </description>
    <id>MAX_VDD_CURRENT_READING</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0x0000</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Power used by components other than CPU, memory,
        or GPUs in Watts
    </description>
    <id>MISC_SYSTEM_COMPONENTS_MAX_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t></uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Machine Readable Workbook safe mode throttle value for
        numerator cfg_nm_n_per_chip
    </description>
    <id>MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        cfg_nm_n_per_mba throttle N value that was calculated from
        MSS_DATABUS_UTIL_PER_MBA
    </description>
    <id>MSS_UTIL_N_PER_MBA</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint32_t></uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        A constant power (in watts) that the OCC is to add onto Vdd and Vdn
        power to represent any processor part that is not measured(i.e.Vcs,Vio)
        This is used by the OCC to calculate a total processor socket power.
    </description>
    <id>NO_APSS_PROC_POWER_VCS_VIO_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Maximum memory power in centiWatts with throttle
        set to nominal/turbo
    </description>
    <id>N_PLUS_ONE_MEM_POWER</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint32_t>
        <default>0,0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Static per chip numerator setting when not in oversubscription.
    </description>
    <id>N_PLUS_ONE_N_PER_CHIP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint16_t>
        <default>0,0</default>
      </uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Static per MBA numerator setting when not in
        oversubscription.  Calculated based on MRW memory
        power with redundant power. Lowest per MBA numerator
        ever allowed when OCC is throttling due to OT.
    </description>
    <id>N_PLUS_ONE_N_PER_MBA</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint16_t>
        <default>0,0</default>
      </uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>OCC operational data
    </description>
    <id>OCC_CONTROL_DATA</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>256</array>
      <uint8_t></uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Specifies the compatible model name for Opal to key off of.
        This is sourced from the MRW and should be of the format
        'vendor,model', e.g. 'tyan,palmetto'.
    </description>
    <id>OPAL_MODEL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <string>
        <default>ibm,miscopenpower</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        DIMM temperature where an error will be generated
        in degrees C
    </description>
    <id>OPEN_POWER_DIMM_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        DIMM read timeout in seconds
    </description>
    <id>OPEN_POWER_DIMM_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        DIMM temperature threshold where throttling will
        occur in degrees C
    </description>
    <id>OPEN_POWER_DIMM_THROTTLE_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        GPU core temperature error threshold in degrees C
    </description>
    <id>OPEN_POWER_GPU_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        GPU memory temperature error threshold in degrees C
    </description>
    <id>OPEN_POWER_GPU_MEM_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        GPU memory temperature read timeout in seconds
    </description>
    <id>OPEN_POWER_GPU_MEM_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        GPU core temperature read timeout in seconds
    </description>
    <id>OPEN_POWER_GPU_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Memory controller temperature where an error will occur
        in degrees C
    </description>
    <id>OPEN_POWER_MEMCTRL_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Memory controller read timeout in seconds
    </description>
    <id>OPEN_POWER_MEMCTRL_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
         Memory controller temperature threshold
         where throttling will occur in degrees C
    </description>
    <id>OPEN_POWER_MEMCTRL_THROTTLE_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Minimum memory utilization percent (from 0-100)
        for power capping
    </description>
    <id>OPEN_POWER_MIN_MEM_UTILIZATION_POWER_CAP</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Minimum memory utilization percent (from 0-100)
        for memory throttling
    </description>
    <id>OPEN_POWER_MIN_MEM_UTILIZATION_THROTTLING</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Minimum hard power cap in Watts
    </description>
    <id>OPEN_POWER_MIN_POWER_CAP_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        N mode bulk power supply limit in Watts
    </description>
    <id>OPEN_POWER_N_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Maximum power allocated to DIMMs in Watts
    </description>
    <id>OPEN_POWER_N_MAX_MEM_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        N+1 bulk power limit in Watts for systems running
        with redundant power supplies (default)
    </description>
    <id>OPEN_POWER_N_PLUS_ONE_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        N+1 bulk power limit in Watts for High Performance Computing
        systems running with a non-redundant power supply policy
    </description>
    <id>OPEN_POWER_N_PLUS_ONE_HPC_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        N+1 max memory power in Watts
    </description>
    <id>OPEN_POWER_N_PLUS_ONE_MAX_MEM_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Processor temperature where DVFS will occur in degrees C
    </description>
    <id>OPEN_POWER_PROC_DVFS_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Processor temperature error threshold in degrees C
    </description>
    <id>OPEN_POWER_PROC_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Processor read timeout in seconds
    </description>
    <id>OPEN_POWER_PROC_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Weight factor (in 1/10ths) for each core DTS to calculate a core
        temperature.
    </description>
    <id>OPEN_POWER_PROC_WEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Weight factor (in 1/10ths) for each quad (cache) DTS to calculate a core
        temperature.
    </description>
    <id>OPEN_POWER_QUAD_WEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Regulator efficiency factor
    </description>
    <id>OPEN_POWER_REGULATOR_EFFICIENCY_FACTOR</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Minimum soft power cap in Watts
    </description>
    <id>OPEN_POWER_SOFT_MIN_PCAP_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint64_t></uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        If this system supports Turbo frequency mode.
            0x00 = no
            0x01 = yes
    </description>
    <id>OPEN_POWER_TURBO_MODE_SUPPORTED</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        VRM read timeout in seconds (from 0-255)
        Use 0 to disable VRM OT monitoring
    </description>
    <id>OPEN_POWER_VRM_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        VRM Vdd Temperature in degrees C to invoke DVFS (clip max Pstate)
    </description>
    <id>OPEN_POWER_VRM_VDD_DVFS_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        VRM Vdd Temperature in degrees C that an overtemp error will be logged
    </description>
    <id>OPEN_POWER_VRM_VDD_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
         Maximum time in seconds allowed without having a new VRM Vdd
         temperature before DVFS will occur
    </description>
    <id>OPEN_POWER_VRM_VDD_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Enable Trace lite on openpower.
    </description>
    <hbOnly></hbOnly>
    <id>OP_TRACE_LITE</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default></default>
      </uint8_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Maximum memory power in centiWatts with throttle
        set to minimum.
    </description>
    <id>OT_MEM_POWER</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint32_t>
        <default>0,0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Lowest per MBA numerator ever allowed when OCC is
        throttling due to OT.
    </description>
    <id>OT_MIN_N_PER_MBA</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint16_t>
        <default>0,0</default>
      </uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Maximum memory power in centiWatts with when power is being capped.
    </description>
    <id>POWERCAP_MEM_POWER</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint32_t>
        <default>0,0</default>
      </uint32_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Static per chip numerator setting when power is being capped.
    </description>
    <id>POWERCAP_N_PER_CHIP</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint16_t>
        <default>0,0</default>
      </uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Static per slot numerator setting when power is being capped.
    </description>
    <id>POWERCAP_N_PER_MBA</id>
    <persistency>volatile-zeroed</persistency>
    <readable></readable>
    <simpleType>
      <array>2</array>
      <uint16_t>
        <default>0,0</default>
      </uint16_t>
    </simpleType>
    <writeable></writeable>
  </attribute>

  <attribute>
    <description>
        Frequency (in MHz) for 1 Watt of processor power change.  Used by the
        power capping algorithm to determine how much to change the frequency
        based on power available.
        This is used in populating CALCULATED_MAX_SYS_POWER_EXCLUDING_GPUS
    </description>
    <id>PROC_MHZ_PER_WATT</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>28</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        The maximum power a single procesor socket can support (in watts)
        This is used to populate CALCULATED_MAX_SYS_POWER_EXCLUDING_GPUS
    </description>
    <id>PROC_SOCKET_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>250</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
         Indicates if OCC should wait to report DVFS due to power/thermal until
         max frequency has been lowered below nominal.
         Default OCC will report DVFS when max frequency is lowered below turbo.
         DVFS is reported in poll response extended status bits and in OPAL
         shared memory throttle status byte.
         1 = OCC report throttling only when max freq. lowered below nominal
         0 = OCC report throttling when max freq. lowered below turbo
    </description>
    <id>REPORT_THROTTLE_BELOW_NOMINAL</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Used to enable Vdd current overflow worakaround.
        To enable this attribute should be set to 1 and
        MAX_VDD_CURRENT_READING must be populated.
        Set to 0 to disable.
    </description>
    <id>VDD_CURRENT_OVERFLOW_WORKAROUND_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable></readable>
    <simpleType>
      <uint16_t>
        <default>0x0000</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>DRAM Device Type.
          Decodes SPD byte 2.
          Generation of memory: DDR3, DDR4.
          creator: mss_eff_config
          consumer: various
          firmware notes: none</description>
    <enumerator>
      <name>EMPTY</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>DDR3</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DDR4</name>
      <value>2</value>
    </enumerator>
    <id>EFF_DRAM_GEN</id>
  </enumerationType>

  <enumerationType>
    <description>Base Module Type.
          Decodes SPD Byte 3 (bits 3~0).
          Type of DIMM: RDIMM, UDIMM, LRDIMM as specified by the JEDEC standard.
          creator: mss_eff_config
          consumer: various
          firmware notes: none</description>
    <enumerator>
      <name>EMPTY</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>RDIMM</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>UDIMM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>LRDIMM</name>
      <value>3</value>
    </enumerator>
    <id>EFF_DIMM_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>Hybrid Media.
          Decodes SPD Byte 3 (bits 6~4)
          creator: mss_eff_config
          consumer: various
          firmware notes: none</description>
    <enumerator>
      <name>NONE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NVDIMM</name>
      <value>1</value>
    </enumerator>
    <id>EFF_HYBRID_MEMORY_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>Hybrid.
          Decodes SPD Byte 3 (bit 7)
          creator: mss_eff_config
          consumer: various
          firmware notes: none</description>
    <enumerator>
      <name>NOT_HYBRID</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>IS_HYBRID</name>
      <value>1</value>
    </enumerator>
    <id>EFF_HYBRID</id>
  </enumerationType>

  <enumerationType>
    <description>DRAM Density.
            Decodes SPD Byte 4 (bits 3~0).
            Total SDRAM capacity per die.
            For multi-die stacks (DDP, QDP, or 3DS), this represents
            the capacity of each DRAM die in the stack.
            creator: mss_eff_config
            consumer: various
            firmware notes: none</description>
    <enumerator>
      <name>4G</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>8G</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>16G</name>
      <value>16</value>
    </enumerator>
    <id>EFF_DRAM_DENSITY</id>
  </enumerationType>

  <enumerationType>
    <description>Row Address Bits.
            Decodes Byte 5 (bits 5~3).
            Number of DRAM column address bits.
            Actual number of DRAM rows is 2^N,
            where N is the number of row address bits
            creator: mss_eff_config
            consumer: various
            firmware notes: none</description>
    <enumerator>
      <name>NUM14</name>
      <value>14</value>
    </enumerator>
    <enumerator>
      <name>NUM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>NUM16</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>NUM17</name>
      <value>17</value>
    </enumerator>
    <enumerator>
      <name>NUM18</name>
      <value>18</value>
    </enumerator>
    <id>EFF_DRAM_ROW_BITS</id>
  </enumerationType>

  <enumerationType>
    <description>Primary SDRAM Package Type.
            Decodes Byte 6.
            This byte defines the primary set of SDRAMs.
            Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
            creator: mss_eff_config
            consumer: various
            firmware notes: none</description>
    <enumerator>
      <name>SDP</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>DDP_QDP</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>3DS</name>
      <value>2</value>
    </enumerator>
    <id>EFF_PRIM_STACK_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
            creator: mss_eff_cnfg
            consumer: various
            firmware notes: none</description>
    <enumerator>
      <name>NOT_SUPPORTED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SUPPORTED</name>
      <value>1</value>
    </enumerator>
    <id>EFF_DRAM_PPR</id>
  </enumerationType>

  <enumerationType>
    <description>Soft Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
            creator: mss_eff_cnfg
            consumer: various
            firmware notes: none</description>
    <enumerator>
      <name>NOT_SUPPORTED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SUPPORTED</name>
      <value>1</value>
    </enumerator>
    <id>EFF_DRAM_SOFT_PPR</id>
  </enumerationType>

  <enumerationType>
    <description>Minimum CAS to CAS Delay Time, same bank group
          in nck (number of clock cycles).
          Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0).
          This is for DDR4 MRS6.
          Each memory channel will have a value.
          Creator: eff_config
          Consumer:various
          Firmware notes: none</description>
    <enumerator>
      <name>4NCK</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>5NCK</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>6NCK</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>7NCK</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>8NCK</name>
      <value>8</value>
    </enumerator>
    <id>EFF_DRAM_TCCD_L</id>
  </enumerationType>

  <enumerationType>
    <description>SDRAM Device Width
          Decodes SPD Byte 12 (bits 2~0).
          Options: X4 (4 bits), X8 (8 bits), X16 (16 bits), X32 (32 bits).
          creator: mss_eff_cnfg
          consumer: various
          firmware notes: none</description>
    <enumerator>
      <name>X4</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>X8</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>X16</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>X32</name>
      <value>32</value>
    </enumerator>
    <id>EFF_DRAM_WIDTH</id>
  </enumerationType>

  <enumerationType>
    <description>DRAM Device Rank Mix
          Decodes SPD Byte 12 (bits 5~3).
          creator: mss_eff_cnfg
          consumer: various
          firmware notes: none</description>
    <enumerator>
      <name>SYMMETRICAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ASYMMETICAL</name>
      <value>1</value>
    </enumerator>
    <id>EFF_DRAM_RANK_MIX</id>
  </enumerationType>

  <enumerationType>
    <description>Total number of ranks in each DIMM.
        For monolithic and multi-load stack modules (SDP/DDP) this is the same as
        the number of package ranks per DIMM (SPD Byte 12 bits 5~3).

        For single load stack (3DS) modules this value represents the number
        of logical ranks per DIMM.
        Logical rank refers the individually addressable die in a 3DS stack
        and has no meaning for monolithic or multi-load stacked SDRAMs.
        creator: mss_eff_cnfg
        consumer: various
        firmware notes: none</description>
    <enumerator>
      <name>1R</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>2R</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>4R</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>8R</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>16R</name>
      <value>16</value>
    </enumerator>
    <id>EFF_NUM_RANKS_PER_DIMM</id>
  </enumerationType>

  <enumerationType>
    <description>Register Type
            Decodes SPD Byte 131
            creator: mss_eff_cnfg
            consumer: eff_dimm</description>
    <enumerator>
      <name>RCD01</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>RCD02</name>
      <value>0x1</value>
    </enumerator>
    <id>EFF_REGISTER_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>DRAM Manufacturer ID Code
            Decodes SPD Byte 350 and 351
            creator: mss_eff_cnfg
            consumer: power_thermal::decoder</description>
    <enumerator>
      <name>MICRON</name>
      <value>0x802C</value>
    </enumerator>
    <enumerator>
      <name>SAMSUNG</name>
      <value>0x80CE</value>
    </enumerator>
    <enumerator>
      <name>HYNIX</name>
      <value>0x80AD</value>
    </enumerator>
    <id>EFF_DRAM_MFG_ID</id>
  </enumerationType>

  <enumerationType>
    <description>Register Manufacturer ID Code
            Decodes SPD Byte 133 and 134
            creator: mss_eff_cnfg</description>
    <enumerator>
      <name>INPHI</name>
      <value>0xB304</value>
    </enumerator>
    <enumerator>
      <name>MONTAGE</name>
      <value>0x3286</value>
    </enumerator>
    <enumerator>
      <name>IDT</name>
      <value>0xB380</value>
    </enumerator>
    <id>EFF_RCD_MFG_ID</id>
  </enumerationType>

  <enumerationType>
    <description>True or false whether row repair is supported
          MRW attribute</description>
    <enumerator>
      <name>SUPPORTED</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>UNSUPPORTED</name>
      <value>0</value>
    </enumerator>
    <id>ROW_REPAIR_SUPPORTED_MRW</id>
  </enumerationType>

  <enumerationType>
    <description>The frequency of the memory controller mesh clock, in MHz.
    This clock is asynchronous to the nest and drives the MCU queues, and all the
    associated logic that drives the inputs to the OMI.
    This can be set differently for each memory controller in the chip.</description>
    <enumerator>
      <name>1333</name>
      <value>1333</value>
    </enumerator>
    <enumerator>
      <name>1600</name>
      <value>1600</value>
    </enumerator>
    <id>FREQ_MC_MHZ</id>
  </enumerationType>

  <enumerationType>
    <description>The frequency of a processor's IOHS mesh clocks, in MHz.
    This can be set differently on a by-link basis.</description>
    <enumerator>
      <name>1611</name>
      <value>1611</value>
    </enumerator>
    <enumerator>
      <name>2060</name>
      <value>2060</value>
    </enumerator>
    <id>FREQ_IOHS_MHZ</id>
  </enumerationType>

  <enumerationType>
    <description>Specify the system policy to enforce synchronous mode between memory and
    nest. This drives the value of ATTR_MEM_IN_SYNCH_MODE.
    UNDETERMINED : Run synchronously if the dimm and nest freq matches
    ALWAYS : Require matching frequencies and deconfigure memory that
    does not match the nest
    NEVER : Do not run synchronously, even if the frequencies match</description>
    <enumerator>
      <name>UNDETERMINED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALWAYS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NEVER</name>
      <value>2</value>
    </enumerator>
    <id>REQUIRED_SYNCH_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Holds data and mask to be programmed into Memory BAR/configuration registers.
    These values are calculated by p10_mss_eff_grouping HWP.

    Array arrangements: 4 MIs x 9 registers x 2 entries (data/mask)
      [0][0][0] = [MI0][MCFGP0][data] .... [MI0][9][1] = [MI0][MCMODE0][mask]
      [1][0][0] = [MI1][MCFGP0][data] .... [MI1][9][1] = [MI1][MCMODE0][mask]
      [2][0][0] = [MI2][MCFGP0][data] .... [MI2][9][1] = [MI2][MCMODE0][mask]
      [3][0][0] = [MI3][MCFGP0][data] .... [MI3][9][1] = [MI3][MCMODE0][mask]

    The BARs will be written by p10_sbe_exit_cache_contained HWP when
    called by Hostboot.

    The mask value specifies which bits of the data should be written to the
    underlying HW register.

    Set by p10_mss_eff_grouping.
    Consumers: HB (p10_exit_cache_contaiend)</description>
    <enumerator>
      <name>MCFGP0</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MCFGP1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>MCFGPM0</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>MCFGPM1</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MCFGP0A</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>MCFGP1A</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>MCFGPM0A</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>MCFGPM1A</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>MCMODE0</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>NUM_BAR_REGS</name>
      <value>9</value>
    </enumerator>
    <id>MEMORY_BAR_REGS</id>
  </enumerationType>

  <enumerationType>
    <description>creator: p10_mss_eff_grouping
    consumer: mss_setup_bars
    Data Structure from eff grouping to setup bars to help determine
    different groups. Measured in GB.
    Non-Mirroring array[0-7][0.20]:
            0-- Port size;
            1-- No of ports in group;
            2-- Total group size of non-mirroring;
            3-- Base address;
         4-11-- PortID number in group;
           12-- Alt Memory valid(0);
           13-- Alt Memory valid (1);
           14-- Alt Group size (0);
           15-- Alt Group size(1);
           16-- Alt Base address (0);
           17-- Alt Base address (1);
           18-- SMF Memory Valid
           19-- SMF Group Size (size[22:35] in lower bits)
           20-- SMF Base Address (addr[22:35] in lower bits)
    Mirroring array[8-15][0:20]:
           Same index description as above for mirror groups.</description>
    <enumerator>
      <name>MCC_SIZE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NUM_MCC_IN_GROUP</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>GROUP_SIZE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>BASE_ADDR</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MCC_ID_1</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>MCC_ID_2</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>MCC_ID_3</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>MCC_ID_4</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>MCC_ID_5</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>MCC_ID_6</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>MCC_ID_7</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>MCC_ID_8</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>ALT_VALID_0</name>
      <value>12</value>
    </enumerator>
    <enumerator>
      <name>ALT_VALID_1</name>
      <value>13</value>
    </enumerator>
    <enumerator>
      <name>ALT_SIZE_0</name>
      <value>14</value>
    </enumerator>
    <enumerator>
      <name>ALT_SIZE_1</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>ALT_BASE_ADDR_0</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>ALT_BASE_ADDR_1</name>
      <value>17</value>
    </enumerator>
    <enumerator>
      <name>SMF_VALID</name>
      <value>18</value>
    </enumerator>
    <enumerator>
      <name>SMF_SIZE</name>
      <value>19</value>
    </enumerator>
    <enumerator>
      <name>SMF_BASE_ADDR</name>
      <value>20</value>
    </enumerator>
    <id>MSS_MCC_GROUP_32</id>
  </enumerationType>

  <enumerationType>
    <description>Define placement policy/scheme for non-mirrored/mirrored memory layout
    NORMAL = non-mirrored start: 0, mirrored start: 1024TB
    FLIPPED = mirrored start: 0, non-mirrored start: 512TB
    Set by platform.
    Used by p10_mss_eff_grouping.</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>FLIPPED</name>
      <value>0x1</value>
    </enumerator>
    <id>MEM_MIRROR_PLACEMENT_POLICY</id>
  </enumerationType>

  <enumerationType>
    <description>Determines the stride covered by each granule in an interleaving
    group. The default stride -- 128B -- is the only value intended for
    production FW use. All other combinations are for experimental
    performance evaluation.

    Regardless of this attribute value, groups of size 1, 3, and 6
    will be forced to 128B stride based on the logic capabilities.</description>
    <enumerator>
      <name>128_B</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>256_B</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>512_B</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>1_KB</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>2_KB</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>4_KB</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>8_KB</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>16_KB</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>32_KB</name>
      <value>0x08</value>
    </enumerator>
    <id>MSS_INTERLEAVE_GRANULARITY</id>
  </enumerationType>

  <enumerationType>
    <description>REQUIRED:
      HW mirroring is enabled, and all channels are required
      to be part of a mirrored group.
    REQUESTED:
      HW mirroring is enabled. Mirroring will be configured for
      groups which support it, but not all channels are required
      to be mirrored.
    OFF:
      HW mirroring is disabled.
    Provided by the MRW.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>REQUIRED</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>REQUESTED</name>
      <value>0x2</value>
    </enumerator>
    <id>MRW_HW_MIRRORING_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Processor fabric topology id table. Index is the value of RA[15:19] and the
    value stored is the 4-bit topology id of the owning chip (of that space).</description>
    <enumerator>
      <name>INVALID</name>
      <value>0xff</value>
    </enumerator>
    <id>PROC_FABRIC_TOPOLOGY_ID_TABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Processor fabric SL domain (proxime) configuration.</description>
    <enumerator>
      <name>CHIP</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>HEMISPHERE</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_FABRIC_SL_DOMAIN</id>
  </enumerationType>

  <enumerationType>
    <description>Processor fabric broadcast scope configuration.
    Provided by the MRW.</description>
    <enumerator>
      <name>1HOP_CHIP_IS_GROUP</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>1HOP_CHIP_IS_NODE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>RESERVED</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>2HOP_CHIP_IS_NODE</name>
      <value>0x03</value>
    </enumerator>
    <id>PROC_FABRIC_BROADCAST_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Processor fabric topology mode, determines format of the topology ID.
    MODE0 = GGG_C (max 8x2)
    MODE1 = GG_CC (max 4x4)
    Provided by the MRW.</description>
    <enumerator>
      <name>MODE0</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>MODE1</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_FABRIC_TOPOLOGY_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates if the given chip should serve as the fabric system master.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_SYSTEM_MASTER_CHIP</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates if the given chip should serve as the fabric group master.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_GROUP_MASTER_CHIP</id>
  </enumerationType>

  <enumerationType>
    <description>Per-link optics configuration
    OPT0 = SMPA/SMPX/OCAPI/NV
    OPT1 = SMPA/SMPX
    OPT2 = SMPA/SMPX
    OPT3 = SMPA/SMPX/OCAPI/NV
    OPT4 = SMPA/SMPX/OCAPI/NV
    OPT5 = SMPA/SMPX/OCAPI/NV
    OPT6 = SMPA/SMPX/OCAPI/NV
    OPT7 = SMPA/SMPX/OCAPI/NV
    Provided by the MRW.</description>
    <enumerator>
      <name>SMPX</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>SMPA</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NV</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>OCAPI</name>
      <value>0x3</value>
    </enumerator>
    <id>IOHS_CONFIG_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Processor optics bus width per link.
    Provided by the MRW.</description>
    <enumerator>
      <name>1_BYTE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>2_BYTE</name>
      <value>0x02</value>
    </enumerator>
    <id>IOHS_BUS_WIDTH</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates if the link is used to connect between drawers.
    Should be considered valid only if ATTR_IOHS_CONFIG_MODE for the given
    link is configured as an SMPX or SMPA.
    Provided by the MRW.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IOHS_DRAWER_INTERCONNECT</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates if the endpoint target is actively being used as a fabric link</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_LINK_ACTIVE</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates which sublinks should be initialized/trained. This bus-scoped
    attribute is used to shadow info into the chip-scoped attribute
    ATTR_PROC_FABRIC_[XA]_ATTACHED_CHIP_CNFG respectively.</description>
    <enumerator>
      <name>BOTH</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>EVEN_ONLY</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>ODD_ONLY</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>NONE</name>
      <value>0x3</value>
    </enumerator>
    <id>IOHS_LINK_TRAIN</id>
  </enumerationType>

  <enumerationType>
    <description>For each fabric X link on this chip, specifies whether or not the chip at the
    receiving end of the link is present and configured</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>EVEN_ONLY</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>ODD_ONLY</name>
      <value>0x3</value>
    </enumerator>
    <id>PROC_FABRIC_X_ATTACHED_CHIP_CNFG</id>
  </enumerationType>

  <enumerationType>
    <description>For each fabric A link on this chip, specifies whether or not the chip at the
    receiving end of the link is present and configured</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>EVEN_ONLY</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>ODD_ONLY</name>
      <value>0x3</value>
    </enumerator>
    <id>PROC_FABRIC_A_ATTACHED_CHIP_CNFG</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates if X links on this chip should be configured in aggregate mode.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_X_AGGREGATE</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates if link should be used to carry data only (in aggregate configurations).
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG
    index is true.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_X_ADDR_DIS</id>
  </enumerationType>

  <enumerationType>
    <description>Average of local/remote end link delay counter values.
    Used to designate coherent link in aggregate configurations.
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG
    index is true.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_X_LINK_DELAY</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates if A links on this chip should be configured in aggregate mode.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_A_AGGREGATE</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates if link should be used to carry data only (in aggregate configurations).
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG
    index is true.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_A_ADDR_DIS</id>
  </enumerationType>

  <enumerationType>
    <description>Average of local/remote end link delay counter values.
    Used to designate coherent link in aggregate configurations.
    Should be considered valid only if corresponding ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG
    index is true.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_A_LINK_DELAY</id>
  </enumerationType>

  <enumerationType>
    <description>Fabric topology ID table configuration.
    Used to indicate whether the topology ID table entry is valid.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_TID_TABLE_ENTRY_VALID</id>
  </enumerationType>

  <enumerationType>
    <description>Configuration for fabric asynchronous boundary crossings that exist
    between the fabric and the MC/PAU/IOHS units.</description>
    <enumerator>
      <name>PERF_MODE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>SAFE_MODE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_ASYNC_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Processor core floor/ceiling frequency ratio used for epsilon calculations.</description>
    <enumerator>
      <name>RATIO_8_8</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>RATIO_7_8</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>RATIO_6_8</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>RATIO_5_8</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>RATIO_4_8</name>
      <value>0x4</value>
    </enumerator>
    <id>PROC_FABRIC_CORE_FREQ_RATIO</id>
  </enumerationType>

  <enumerationType>
    <description>Stores the state of registers affected by p10_sbe_mcs_setup
    To be restored in p10_revert_sbe_mcs_setup.
    Set by p10_sbe_mcs_setup.</description>
    <enumerator>
      <name>MCFGP0</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MCMODE0</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>MCMODE1</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>MCMODE2</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MCPERF1</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>MCFIRMASK</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>MCFIRACT0</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>MCFIRACT1</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>MCTO</name>
      <value>8</value>
    </enumerator>
    <id>PROC_SBE_MCS_SETUP_REG_STATES</id>
  </enumerationType>

  <enumerationType>
    <description>The frequency of the OMI channel.</description>
    <enumerator>
      <name>19200</name>
      <value>19200</value>
    </enumerator>
    <enumerator>
      <name>21330</name>
      <value>21330</value>
    </enumerator>
    <enumerator>
      <name>23460</name>
      <value>23460</value>
    </enumerator>
    <enumerator>
      <name>25600</name>
      <value>25600</value>
    </enumerator>
    <id>FREQ_OMI_MHZ</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates if SBE on this chip is serving as hostboot drawer master</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_SBE_MASTER_CHIP</id>
  </enumerationType>

  <enumerationType>
    <description>enable the pulse mode</description>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <id>PULSE_MODE_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Skip locking sequence and check for lock of PAU DPLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>PAU_DPLL_BYPASS</id>
  </enumerationType>

  <enumerationType>
    <description>Skip locking sequence and check for lock of NEST DPLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>NEST_DPLL_BYPASS</id>
  </enumerationType>

  <enumerationType>
    <description>Skip locking sequence and check for lock of IO PLLs</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>IO_TANK_PLL_BYPASS</id>
  </enumerationType>

  <enumerationType>
    <description>Summarizes the fused status of cores. This is same for all p10 chips
    in the system. If a core is in a fused state, attribute should read 1
    else zero. It needs to be populated during ipl but before istep 15.</description>
    <enumerator>
      <name>CORE_UNFUSED</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CORE_FUSED</name>
      <value>0x1</value>
    </enumerator>
    <id>FUSED_CORE_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>0 = OCC has never been loaded and FIR Masks have never been initialized,
    1 = FIR masks have been initialized and the hardware should reflect correct
    2 = FIR masks have been initialized but the current hardware state is the
        value</description>
    <enumerator>
      <name>NO_INIT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FIRS_INITED</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FIRS_INITED_IN_RESET</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FIRS_RESET_IN_HB</name>
      <value>3</value>
    </enumerator>
    <id>PM_FIRINIT_DONE_ONCE_FLAG</id>
  </enumerationType>

  <enumerationType>
    <description>Indicator that all relevant attributes and required data for Pstates to be
        is present and valid

    Producer: proc_build_pstate_datablock

    Consumers: proc_pm_pstate_gpe_init</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>PSTATES_ENABLED</id>
  </enumerationType>

  <enumerationType>
    <description>Indicator that all relevant attributes and required data for Resonant
        to be enabled is present and valid

    Producer: proc_build_pstate_datablock

    Consumers: p10_hcode_image_build -&gt;
    PGPE Header CME Header</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>RESCLK_ENABLED</id>
  </enumerationType>

  <enumerationType>
    <description>Indicator that all relevant attributes and required data for Digital Droop
        (DDS) to be enabled is present and valid

    Producer: proc_build_pstate_datablock

    Consumers: p10_hcode_image_build -&gt;
    PGPE Header QME Header</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>DDS_ENABLED</id>
  </enumerationType>

  <enumerationType>
    <description>Indicator that all relevant attributes and required data for Retention
        Regulator Macros (RVRMs) to be enabled is present and valid

    Producer: proc_build_pstate_datablock

    Consumers: p10_hcode_image_build -&gt;
    PGPE Header QME Header</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>RVRM_ENABLED</id>
  </enumerationType>

  <enumerationType>
    <description>Indicator that all relevent attributes and required data for WOF to be
        is present and valid

    Producer: proc_build_pstate_datablock

    Consumers: p10_hcode_image_build -&gt;
    PGPE Header CME Header</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>WOF_ENABLED</id>
  </enumerationType>

  <enumerationType>
    <description>Enable debug halt function upon XGPE Phantom interrupts

    Consumers: p10_hcode_image_build -&gt;
    XGPE Header</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>XGPE_PHANTOM_HALT_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Enable debug halt function upon PGPE Phantom interrupts

    Consumers: p10_hcode_image_build -&gt;
    PGPE Header</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>PGPE_PHANTOM_HALT_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Enable debug halt function upon QME Stop Phantom stop interrupts

    Consumers: p10_hcode_image_build -&gt;
    QME Header</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>QME_STOP_PHANTOM_HALT_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates that a special wakeup is in progress for a core.

    Producer: proc_cpu_special_wakeup_core.C

    Consumers: proc_cpu_special_wakeup_core.C</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>CORE_INSIDE_SPECIAL_WAKEUP</id>
  </enumerationType>

  <enumerationType>
    <description>Attribute is set at the start of PM halt and cleared at the end. It act as a
        for FFDC collection utility to behave differently during PM restart</description>
    <enumerator>
      <name>INACTIVE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ACTIVE</name>
      <value>0x01</value>
    </enumerator>
    <id>INITIATED_PM_HALT</id>
  </enumerationType>

  <enumerationType>
    <description>Attribute is set in PM Reset and cleared in the immediate subsequent PM
        when handling a PM Malfunction related PM Complex restart cycle.</description>
    <enumerator>
      <name>INACTIVE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ACTIVE</name>
      <value>0x01</value>
    </enumerator>
    <id>PM_MALF_CYCLE</id>
  </enumerationType>

  <enumerationType>
    <description>Enable trap function upon broadside scan

    Consumers: p10_hcd_core/cache_*_initf</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>QME_BROADSIDE_SCAN</id>
  </enumerationType>

  <enumerationType>
    <description>Digital Droop Sensors (DDS) Extreme Threshold Select Value per VPD point.
    a negative value below the DDS setting that will trigger droop event.  This
    attibute overrides the

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid.

    Producer: Override</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>8mV</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>16mV</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>24mV</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>32mV</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>40mV</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>48mV</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>56mV</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>64mV</name>
      <value>0x08</value>
    </enumerator>
    <enumerator>
      <name>72mV</name>
      <value>0x09</value>
    </enumerator>
    <enumerator>
      <name>80mV</name>
      <value>0x0A</value>
    </enumerator>
    <enumerator>
      <name>88mV</name>
      <value>0x0B</value>
    </enumerator>
    <enumerator>
      <name>92mV</name>
      <value>0x0C</value>
    </enumerator>
    <enumerator>
      <name>96mV</name>
      <value>0x0D</value>
    </enumerator>
    <id>DDS_DROOP_EXTREME_OVERRIDE</id>
  </enumerationType>

  <enumerationType>
    <description>Digital Droop Sensors (DDS) Large Threshold Select Value per VPD point.
    a negative value below the DDS setting that will trigger droop event.

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid.

    Producer: Override</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>8mV</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>16mV</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>24mV</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>32mV</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>40mV</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>48mV</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>56mV</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>64mV</name>
      <value>0x08</value>
    </enumerator>
    <enumerator>
      <name>72mV</name>
      <value>0x09</value>
    </enumerator>
    <enumerator>
      <name>80mV</name>
      <value>0x0A</value>
    </enumerator>
    <enumerator>
      <name>88mV</name>
      <value>0x0B</value>
    </enumerator>
    <enumerator>
      <name>92mV</name>
      <value>0x0C</value>
    </enumerator>
    <enumerator>
      <name>96mV</name>
      <value>0x0D</value>
    </enumerator>
    <id>DDS_DROOP_LARGE_OVERRIDE</id>
  </enumerationType>

  <enumerationType>
    <description>Digital Droop Sensors (DDS) Small Select Value per VPD point. Indicates a
    value below the DDS setting that will trigger droop event.

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid.

    Producer: Override</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>8mV</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>16mV</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>24mV</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>32mV</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>40mV</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>48mV</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>56mV</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>64mV</name>
      <value>0x08</value>
    </enumerator>
    <enumerator>
      <name>72mV</name>
      <value>0x09</value>
    </enumerator>
    <enumerator>
      <name>80mV</name>
      <value>0x0A</value>
    </enumerator>
    <enumerator>
      <name>88mV</name>
      <value>0x0B</value>
    </enumerator>
    <enumerator>
      <name>92mV</name>
      <value>0x0C</value>
    </enumerator>
    <enumerator>
      <name>96mV</name>
      <value>0x0D</value>
    </enumerator>
    <id>DDS_DROOP_SMALL_OVERRIDE</id>
  </enumerationType>

  <enumerationType>
    <description>Controls the enablement of Digital Droop Sensors (DDS) to throttle the core
    extreme droop event.

    Producer:Machine Readable Workbook

    Consumers: QME attribute?</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>DDS_EXTREME_THOTTLE_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Digital Droop Sensor (DDS) OverVoltage Threshold Select Value per VPD. The
    a positive value above the VDM setting that will an overvolt condition.

    Array of 9 entries-:
        0: PowerSave;
        1: CF1;
        2: CF2;
        3: WOF Base;
        4: CF3;
        5: CF4;
        6: UltraTurbo;
        7: Fmax;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid.

    Producer: Override</description>
    <enumerator>
      <name>FORCE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>8mV</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>16mV</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>24mV</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>32mV</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>40mV</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>48mV</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>56mV</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>64mV</name>
      <value>0x08</value>
    </enumerator>
    <id>DDS_OVERVOLT_OVERRIDE</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates the response of the DPLL frequency upon DDS events if is not ON.

    NONE -&gt; DPLL Mode 2 DROOP_PROTECT -&gt; DPLL Mode 3 DROOP_PROTECT_OVERVOLT -&gt;
    3.5 DYNAMIC -&gt; DPLL Mode 4 DYNAMIC_PROTECT -&gt; DPLL Mode 5

    Producer: MRWB</description>
    <enumerator>
      <name>DROOP_PROTECT</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>DROOP_PROTECT_OVERVOLT</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>DYNAMIC</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>DYNAMIC_PROTECT</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>NONE</name>
      <value>0x04</value>
    </enumerator>
    <id>DPLL_DDS_RESPONSE</id>
  </enumerationType>

  <enumerationType>
    <description>Enables the PGPE Hcode to physically perform frequency and voltage based on
    parameters (eg #V VPD, system parameters, biases, VFRTs. etc). If OFF,
    PGPE provides an immedicate good response to Pstate/WOF IPC operations
    the OCC for firmware integration testing

    Consumer: p10_hcode_image_build.c -&gt; PGPE Header field

    Platform default: ON</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>PGPE_HCODE_FUNCTION_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Enables the XGPE Hcode to support the MPIPL function that coordinates the 
    suspension of the Power Management subsystem. If ON (DISABLED), XGPE provides 
    and immediate good response to allow for general integration testing

    Consumer: p10_hcode_image_build.c -&gt; XGPE Header field

    Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>XGPE_PM_SUSPEND_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Enables pstate parameter block code to use the static #W data

    Consumer: p10_pstate_parameter_block.C

    Platform default:OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>POUND_W_STATIC_DATA_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Attribute in place to allow override of which POUNDV bucket to use to set
    data.</description>
    <enumerator>
      <name>BUCKETA</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>BUCKETB</name>
      <value>2</value>
    </enumerator>
    <id>POUNDV_BUCKET_NUM</id>
  </enumerationType>

  <enumerationType>
    <description>Enables pstate parameter block code to use the static system vrt data

    Consumer: p10_pstate_parameter_block.C -&gt; PGPE Hcode

    Platform default:OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>VDN_STEP_OFF</name>
      <value>0x02</value>
    </enumerator>
    <id>SYS_VRT_STATIC_DATA_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Disables the validity checking of #V VPD content from causing IPL failures.

    OFF:Will enable PStates given all validity checks pass. If validity checks
    a failure is log and error reaction will occur (eg IPL failure) ON: Will
    #V validity checking of #V from causing IPL to halt. check failures will
    error logs and Pstates (including other functions) will be disabled.

    Producer: Override

    Consumers: p10_pstate_parameter_block</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_POUNDV_VALIDITY_HALT_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Debug modes supported for QME Scan layout in HOMER.</description>
    <enumerator>
      <name>SCAN_RING_NO_DEBUG</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>SCAN_RING_TRACE_DEBUG</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>SCAN_RING_DEEP_DEBUG</name>
      <value>0x02</value>
    </enumerator>
    <id>SYSTEM_RING_DBG_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Switch to enable or disable Power Management Malfunction Alert Handling on
    platform support. e.g. True for PHYP based systems and False for based
    depending on support available.

    Producer: Initialized by Hostboot firmware based on platform support Read by
    p10_pm_stop_gpe_init.C</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x01</value>
    </enumerator>
    <id>PM_MALF_ALERT_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Switch to enable or disable Power Management Complex FFDC collection during
    the PM Complex Halt flow to HOMER to assist with failure analysis and recovery.

    Producer: HB must set or reset this based on the platform use-case and
    p10_pm_halt.C, p10_pm_callout.C</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x01</value>
    </enumerator>
    <id>PM_HALT_FFDC_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Disables the enablement of Digital Droop Sensors (DDS) in the system.

    Producer:MRW

    Consumers:p10_pstate_parameter_block -&gt;
    QME Pstate parameter block ????</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>SYSTEM_DDS_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Producer:Override

    Consumers:p10_pstate_parameter_block -&gt;
    QME Pstate parameter block ????</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>SYSTEM_DDS_FREQ_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Controls the mode of Pstate Protocol for testing. ON: Boots the PGPE in &quot;OCC
    Mode&quot; but does NOT start the Pstate protocol OFF: Does NOT boot the PGPE
    Boots the PGPE and automatically starts the Pstate protocol. PMCR
    to move Pstates are honored.

    Producer:Override

    Consumers: p10_pstate_parameter_block and p10_pm_pstate_gpe_init</description>
    <enumerator>
      <name>ON</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>OFF</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>AUTO</name>
      <value>0x02</value>
    </enumerator>
    <id>SYSTEM_PSTATES_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Disables the enablement of resonant clocking in the system.

    Producer: Override Consumers: p10_pstate_parameter_block to clear the flag
    CME QuadManager
    reaction</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>SYSTEM_RESCLK_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Disables RVRM enablement in the system

    Producer: Override

    Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_RVRM_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Disables Work Load Optimized Frequency (WOF) algorithms to modify frequency
    active core count and other inputs.

    OFF:Will enable WOF given all validity check pass. If validity checks fail,
    be disabled for the present IPL.

    ON: Will disable WOF OFF_SKIP_DD: as but skips any validity checking of the
    design level (lab use

    Producer: Override

    Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>OFF_SKIP_DD</name>
      <value>2</value>
    </enumerator>
    <id>SYSTEM_WOF_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Disables Workload Optimized Voltage (WOV) undervolting algorithms which
    voltage below the value calculated from VPD.

    OFF: Will enable WOV overvolting given all validity check pass. If validity
    WOV overvolting will be disabled for the present IPL.

    ON:Will disable overvolting

    Producer: Override

    Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_WOV_OVERV_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Disables Workload Optimized Voltage (WOV) undervolting algorithms which
    voltage below the value calculated from VPD.

    OFF:Will enable WOV undervolting given all validity check pass. If validity
    WOV undervolting will be disabled for the present IPL.

    ON: Will disable undervolting

    Producer: Override

    Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_WOV_UNDERV_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Disables Over Current Sensor functions

    OFF:Will enable Over Current Sensor (OCS) given all validity check pass. If
    checks fail,
    WOV undervolting will be disabled for the present IPL.

    ON: Will disable OCS and WOF (TBD on the this phase in of validity)

    Producer: Override

    Consumers: p10_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB)</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_OCS_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Defines which of the PSS chip selects (0 or 1) that the APSS is connected

    Producer:  Machine Readable Workbook
    Consumer: p10_pm_pss_init</description>
    <enumerator>
      <name>NONE</name>
      <value>0xFF</value>
    </enumerator>
    <enumerator>
      <name>CS0</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>CS1</name>
      <value>0x01</value>
    </enumerator>
    <id>SPIPSS_SELECT</id>
  </enumerationType>

  <enumerationType>
    <description>The powerbus frequency that should be used to locate a valid #V bucket in
    Module VPD if the actual ATTR_FREQ_PB_MHZ value isn't present.</description>
    <enumerator>
      <name>NO_FALLBACK</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>1600</name>
      <value>1600</value>
    </enumerator>
    <enumerator>
      <name>1866</name>
      <value>1866</value>
    </enumerator>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <enumerator>
      <name>2133</name>
      <value>2133</value>
    </enumerator>
    <enumerator>
      <name>2400</name>
      <value>2400</value>
    </enumerator>
    <id>FREQ_PB_MHZ_POUNDV_FALLBACK</id>
  </enumerationType>

  <enumerationType>
    <description>Enables the platform mode where the most recent PMCR update
    will be the controlling value for Pstate changes. If disabled,
    the legacy &quot;fastest one wins&quot; algorithm is used.

    Producer: p10_build_pstate_datablock

    Consumers: p10_hcode_image_build -&gt;
    PGPE Header
    QME attribute</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>PMCR_MOST_RECENT_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Disables the MMA power-off function within the QME.

    OFF: Enables the QME MMA power-off funtion as further controlled by

    ON: Disables the dynamic MMA power-off function within the QME The MMA will
    be on if the core is powered on.

    Producer: Override

    Consumers: QME Hcode</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_MMA_POWEROFF_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Disables the MMA power-on function within the QME. This can be use for
    that will NEVER have MMA based applications running so as to save the MMA

    OFF: Enables the QME MMA power-on funtion. This will have the MMA powered on
    istep 16 and then controlled by ATTR_SYSTEM_MMA_POWEROFF_DISABLE and
    thereafter.

    ON: Disables the MMA power-on function and leaves the MMA permenantly off.
    core will hang on MMA instruction that are dispatched.

    Producer: Override

    Consumers: QME Hcode</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_MMA_POWERON_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Product name of a chip target.
      Provided by the MRW.</description>
    <enumerator>
      <name>NONE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>EXPLORER</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>GEMINI</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>P10</name>
      <value>0xA</value>
    </enumerator>
    <id>NAME</id>
  </enumerationType>

  <enumerationType>
    <description>1 if the target is functional, else 0.  Set by the platform.</description>
    <enumerator>
      <name>NON_FUNCTIONAL</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>FUNCTIONAL</name>
      <value>0x1</value>
    </enumerator>
    <id>FUNCTIONAL</id>
  </enumerationType>

  <enumerationType>
    <description>Scratch uint64_t attribute
        Can be used by HWPs for testing.</description>
    <enumerator>
      <name>VAL_A</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>VAL_B</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>VAL_C</name>
      <value>0xffffffffffffffff</value>
    </enumerator>
    <id>SCRATCH_UINT64_2</id>
  </enumerationType>

  <enumerationType>
    <description>Scratch uint64_t[2][2] attribute.
        Can be used by HWPs for testing.</description>
    <enumerator>
      <name>VAL_A</name>
      <value>0x0123456789abcdef</value>
    </enumerator>
    <enumerator>
      <name>VAL_B</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>VAL_C</name>
      <value>0xffffffffffffffff</value>
    </enumerator>
    <id>SCRATCH_UINT64_ARRAY_2</id>
  </enumerationType>

  <enumerationType>
    <description>Scratch int64_t attribute
        Can be used by HWPs for testing.</description>
    <enumerator>
      <name>VAL_A</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>VAL_B</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>VAL_C</name>
      <value>0xffffffffffffffff</value>
    </enumerator>
    <id>SCRATCH_INT64_2</id>
  </enumerationType>

  <enumerationType>
    <description>Scratch int64_t[2][2] attribute.
        Can be used by HWPs for testing.</description>
    <enumerator>
      <name>VAL_A</name>
      <value>0x0123456789abcdef</value>
    </enumerator>
    <enumerator>
      <name>VAL_B</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>VAL_C</name>
      <value>0xffffffffffffffff</value>
    </enumerator>
    <id>SCRATCH_INT64_ARRAY_2</id>
  </enumerationType>

  <enumerationType>
    <description>Which execution platform the HW Procedure is running on
        Some HWPs (e.g. special wakeup) use different registers for different
          platforms to avoid arbitration problems when multiple platforms do
          the same thing concurrently</description>
    <enumerator>
      <name>HOST</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>0x03</value>
    </enumerator>
    <id>EXECUTION_PLATFORM</id>
  </enumerationType>

  <enumerationType>
    <description>The manufacturing flags.
        This is a bitfield. Each bit is a flag and multiple flags can be set</description>
    <enumerator>
      <name>MNFG_NO_FLAG</name>
      <value>0x0000000000000000</value>
    </enumerator>
    <enumerator>
      <name>MNFG_THRESHOLDS</name>
      <value>0x0000000000000001</value>
    </enumerator>
    <enumerator>
      <name>MNFG_TEST_ALL_SPARE_DRAM_ROWS</name>
      <value>0x0000000000000040</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_DRAM_REPAIRS</name>
      <value>0x0000000000000080</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENABLE_STANDARD_PATTERN_TEST</name>
      <value>0x0000000000000200</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_FABRIC_eREPAIR</name>
      <value>0x0000000000000800</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_MEMORY_eREPAIR</name>
      <value>0x0000000000001000</value>
    </enumerator>
    <enumerator>
      <name>MNFG_FABRIC_DEPLOY_LANE_SPARES</name>
      <value>0x0000000000002000</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DMI_DEPLOY_LANE_SPARES</name>
      <value>0x0000000000004000</value>
    </enumerator>
    <id>MNFG_FLAGS</id>
  </enumerationType>

  <enumerationType>
    <description>Contains the settings for write/read reorder queue</description>
    <enumerator>
      <name>REORDER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FIFO</name>
      <value>1</value>
    </enumerator>
    <id>MEM_REORDER_QUEUE_SETTING</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      CS to CMD/ADDR Latency.
      This is for DDR4 MRS4.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>3CYC</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>4CYC</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>5CYC</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>6CYC</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>8CYC</name>
      <value>8</value>
    </enumerator>
    <id>MEM_CS_CMD_LATENCY</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      C/A Parity Latency Mode. This is for DDR4 MRS5.
      Computed in mss_eff_cnfg. Each memory channel will have a value.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PL4</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>PL5</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>PL6</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>PL8</name>
      <value>8</value>
    </enumerator>
    <id>MEM_CA_PARITY_LATENCY</id>
  </enumerationType>

  <enumerationType>
    <description>DRAM Device Type.
      Decodes SPD byte 2.
      Created for use by attributes that need this data
      earlier than eff_config, such as c_str and the hypervisor.
      Not meant for direct HWP use. This is just an abstraction
      of any chip specific EFF_DRAM_GEN attribute.</description>
    <enumerator>
      <name>EMPTY</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>DDR3</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DDR4</name>
      <value>2</value>
    </enumerator>
    <id>MEM_DRAM_GEN_METADATA</id>
  </enumerationType>

  <enumerationType>
    <description>Base Module Type.
      Decodes SPD Byte 3 (bits 3~0).
      Created for use by attributes that need this data
      earlier than eff_config, such as c_str and the hypervisor.
      Not meant for direct HWP use. This is just an abstraction
      of any chip specific EFF_DIMM_TYPE attribute.</description>
    <enumerator>
      <name>EMPTY</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>RDIMM</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>UDIMM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>LRDIMM</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>DDIMM</name>
      <value>4</value>
    </enumerator>
    <id>MEM_DIMM_TYPE_METADATA</id>
  </enumerationType>

  <enumerationType>
    <description>EDPL (Error Detection Per Lane) is a feature in the DL that adds some additional checks to
      the traffic going across the OpenCAPI link in order to better track which lanes are having issues.
      Note: EDPL must be set the same on both sides of the link. This attribute affects both the proc/mc
      side and the OCMB side.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_OMI_EDPL_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      DRAM Device Type.
      Decodes SPD byte 2.
      Generation of memory: DDR3, DDR4.</description>
    <enumerator>
      <name>EMPTY</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>DDR3</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DDR4</name>
      <value>2</value>
    </enumerator>
    <id>MEM_EFF_DRAM_GEN</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      Base Module Type.
      Decodes SPD Byte 3 (bits 3~0).
      Type of DIMM: RDIMM, UDIMM, LRDIMM as specified by the JEDEC standard.</description>
    <enumerator>
      <name>EMPTY</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>RDIMM</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>UDIMM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>LRDIMM</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>DDIMM</name>
      <value>4</value>
    </enumerator>
    <id>MEM_EFF_DIMM_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      Hybrid Media.
      Decodes SPD Byte 3 (bits 6~4)</description>
    <enumerator>
      <name>NONE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NVDIMM</name>
      <value>1</value>
    </enumerator>
    <id>MEM_EFF_HYBRID_MEMORY_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      Hybrid.
      Decodes SPD Byte 3 (bit 7)</description>
    <enumerator>
      <name>NOT_HYBRID</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>IS_HYBRID</name>
      <value>1</value>
    </enumerator>
    <id>MEM_EFF_HYBRID</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      OMI to DDR frequency ratio</description>
    <enumerator>
      <name>1_TO_1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>2_TO_1</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>4_TO_1</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>8_TO_1</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>16_TO_1</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>32_TO_1</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>64_TO_1</name>
      <value>64</value>
    </enumerator>
    <enumerator>
      <name>128_TO_1</name>
      <value>128</value>
    </enumerator>
    <id>MEM_EFF_HOST_TO_DDR_SPEED_RATIO</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      DRAM Density.
      Decodes SPD Byte 4 (bits 3~0).
      Total SDRAM capacity per die.
      For multi-die stacks (DDP, QDP, or 3DS), this represents
      the capacity of each DRAM die in the stack.</description>
    <enumerator>
      <name>4G</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>8G</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>16G</name>
      <value>16</value>
    </enumerator>
    <id>MEM_EFF_DRAM_DENSITY</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      Row Address Bits.
      Decodes Byte 5 (bits 5~3).
      Number of DRAM column address bits.
      Actual number of DRAM rows is 2^N,
      where N is the number of row address bits</description>
    <enumerator>
      <name>NUM14</name>
      <value>14</value>
    </enumerator>
    <enumerator>
      <name>NUM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>NUM16</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>NUM17</name>
      <value>17</value>
    </enumerator>
    <enumerator>
      <name>NUM18</name>
      <value>18</value>
    </enumerator>
    <id>MEM_EFF_DRAM_ROW_BITS</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      Primary SDRAM Die Count.
      Decodes Byte 6 (bits 6~4).</description>
    <enumerator>
      <name>D1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>D2</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>D3</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>D4</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>D5</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>D6</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>D7</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>D8</name>
      <value>8</value>
    </enumerator>
    <id>MEM_EFF_PRIM_DIE_COUNT</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      Primary SDRAM Package Type (bits 1~0).
      Decodes Byte 6.
      This byte defines the primary set of SDRAMs.
      Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS</description>
    <enumerator>
      <name>SDP</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>DDP_QDP</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>3DS</name>
      <value>2</value>
    </enumerator>
    <id>MEM_EFF_PRIM_STACK_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      Primary bus with (bits 1~0).
      Decodes Byte 13.</description>
    <enumerator>
      <name>8_BITS</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>16_BITS</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>32_BITS</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>64_BITS</name>
      <value>64</value>
    </enumerator>
    <id>MEM_EFF_PRIM_BUS_WIDTH</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.</description>
    <enumerator>
      <name>NOT_SUPPORTED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SUPPORTED</name>
      <value>1</value>
    </enumerator>
    <id>MEM_EFF_DRAM_PPR</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      Soft Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.</description>
    <enumerator>
      <name>NOT_SUPPORTED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SUPPORTED</name>
      <value>1</value>
    </enumerator>
    <id>MEM_EFF_DRAM_SOFT_PPR</id>
  </enumerationType>

  <enumerationType>
    <description>Minimum CAS to CAS Delay Time, same bank group
      in nck (number of clock cycles).
      Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0).
      This is for DDR4 MRS6.
      Each memory channel will have a value.</description>
    <enumerator>
      <name>4NCK</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>5NCK</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>6NCK</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>7NCK</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>8NCK</name>
      <value>8</value>
    </enumerator>
    <id>MEM_EFF_DRAM_TCCD_L</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      SDRAM Device Width
      Decodes SPD Byte 12 (bits 2~0).
      Options: X4 (4 bits), X8 (8 bits), X16 (16 bits), X32 (32 bits).</description>
    <enumerator>
      <name>X4</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>X8</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>X16</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>X32</name>
      <value>32</value>
    </enumerator>
    <id>MEM_EFF_DRAM_WIDTH</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      Total number of ranks in each DIMM.
      For monolithic and multi-load stack modules (SDP/DDP) this is the same as
      the number of package ranks per DIMM (SPD Byte 12 bits 5~3).

      For single load stack (3DS) modules this value represents the number
      of logical ranks per DIMM.
      Logical rank refers the individually addressable die in a 3DS stack
      and has no meaning for monolithic or multi-load stacked SDRAMs.</description>
    <enumerator>
      <name>1R</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>2R</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>4R</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>8R</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>16R</name>
      <value>16</value>
    </enumerator>
    <id>MEM_EFF_LOGICAL_RANKS_PER_DIMM</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      Register Type
      Decodes SPD Byte 131</description>
    <enumerator>
      <name>RCD01</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>RCD02</name>
      <value>0x1</value>
    </enumerator>
    <id>MEM_EFF_REGISTER_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      DRAM Manufacturer ID Code
      Decodes SPD Byte 350 and 351</description>
    <enumerator>
      <name>MICRON</name>
      <value>0x802C</value>
    </enumerator>
    <enumerator>
      <name>SAMSUNG</name>
      <value>0x80CE</value>
    </enumerator>
    <enumerator>
      <name>HYNIX</name>
      <value>0x80AD</value>
    </enumerator>
    <id>MEM_EFF_DRAM_MFG_ID</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      DRAM Modlue Height
      Decodes SPD Byte 193</description>
    <enumerator>
      <name>1U</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>2U</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>4U</name>
      <value>2</value>
    </enumerator>
    <id>MEM_EFF_DRAM_MODULE_HEIGHT</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      Register Manufacturer ID Code
      Decodes SPD Byte 133 and 134</description>
    <enumerator>
      <name>INPHI</name>
      <value>0xB304</value>
    </enumerator>
    <enumerator>
      <name>MONTAGE</name>
      <value>0x3286</value>
    </enumerator>
    <enumerator>
      <name>IDT</name>
      <value>0xB380</value>
    </enumerator>
    <id>MEM_EFF_RCD_MFG_ID</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      DIMM Size, in GB Used in various locations</description>
    <enumerator>
      <name>4GB</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>8GB</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>16GB</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>32GB</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>64GB</name>
      <value>64</value>
    </enumerator>
    <enumerator>
      <name>128GB</name>
      <value>128</value>
    </enumerator>
    <enumerator>
      <name>256GB</name>
      <value>256</value>
    </enumerator>
    <enumerator>
      <name>512GB</name>
      <value>512</value>
    </enumerator>
    <id>MEM_EFF_DIMM_SIZE</id>
  </enumerationType>

  <enumerationType>
    <description>Spare DRAM availability. Used in various locations and is computed in mss_eff_cnfg.
      Array indexes are [DIMM][RANK]</description>
    <enumerator>
      <name>NO_SPARE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>LOW_NIBBLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>HIGH_NIBBLE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FULL_BYTE</name>
      <value>3</value>
    </enumerator>
    <id>MEM_EFF_DIMM_SPARE</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
      Specifies the number of master ranks per DIMM.
      Represents the number of physical ranks on a DIMM.
      From SPD spec JEDEC Standard No. 21-C: Page 4.1.2.L-4.
      Byte 12 (Bits 5~3) Number of package ranks per DIMM.
      Package ranks per DIMM refers to the collections of devices
      on the module sharing common chip select signals.</description>
    <enumerator>
      <name>1R</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>2R</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>4R</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>8R</name>
      <value>8</value>
    </enumerator>
    <id>MEM_EFF_NUM_MASTER_RANKS_PER_DIMM</id>
  </enumerationType>

  <enumerationType>
    <description>List of memory frequencies supported by the current system.</description>
    <enumerator>
      <name>MT1866</name>
      <value>1866</value>
    </enumerator>
    <enumerator>
      <name>MT2133</name>
      <value>2133</value>
    </enumerator>
    <enumerator>
      <name>MT2400</name>
      <value>2400</value>
    </enumerator>
    <enumerator>
      <name>MT2666</name>
      <value>2666</value>
    </enumerator>
    <enumerator>
      <name>MT2933</name>
      <value>2933</value>
    </enumerator>
    <enumerator>
      <name>MT3200</name>
      <value>3200</value>
    </enumerator>
    <id>MSS_MRW_SUPPORTED_FREQ</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates if the DIMM connected to this controller
          are in a planar configuration</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x01</value>
    </enumerator>
    <id>MEM_MRW_IS_PLANAR</id>
  </enumerationType>

  <enumerationType>
    <description>Machine Readable Workbook Refresh Rate
        Desired refresh interval used in refresh register 0, MBAREF0Q_CFG_REFRESH_INTERVAL
        7.8 us (SINGLE)
        3.9 us (DOUBLE)
        7.02 us (SINGLE_10_PERCENT_FASTER)
        3.51 us (DOUBLE_10_PERCENT_FASTER)</description>
    <enumerator>
      <name>DOUBLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SINGLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SINGLE_10_PERCENT_FASTER</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>DOUBLE_10_PERCENT_FASTER</name>
      <value>3</value>
    </enumerator>
    <id>MSS_MRW_REFRESH_RATE_REQUEST</id>
  </enumerationType>

  <enumerationType>
    <description>Machine Readable Workbook enablement of the HWP code to adjust the
      VMEM regulator power limit based on number of installed DIMMs.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Used for to determine whether to apply an offset to AVDD. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_AVDD_OFFSET_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Used for to determine whether to apply an offset to VDD. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VDD_OFFSET_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VCS_OFFSET_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VPP_OFFSET_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Used for to determine whether to apply an offset to VDDR. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VDDR_OFFSET_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Fine refresh mode.
      Sets DDR4 MRS3.
      ZZ uses normal mode.
      From JEDEC DDR4 Spec 1716.78C from 07-2016
      Page 47 Table 4.9.1</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FIXED_2X</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FIXED_4X</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FLY_2X</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>FLY_4X</name>
      <value>6</value>
    </enumerator>
    <id>MSS_MRW_FINE_REFRESH_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Temperature refresh range.
      Sets DDR4 MRS4.
      Should be defaulted to extended range.
      NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less degrees C
      Used for calculating periodic refresh intervals
      JEDEC DDR4 spec 1716.78C from 07-2016
      page 46 4.8.1</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>EXTEND</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_TEMP_REFRESH_RANGE</id>
  </enumerationType>

  <enumerationType>
    <description>For resetting the phy delay values at the beginning of calling mss_draminit_training. YES means the vaules will be reset.</description>
    <enumerator>
      <name>YES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NO</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
  </enumerationType>

  <enumerationType>
    <description>Allows user to manually turn on and off 2N Mode.
      AUTO indicates to use Signal Integrity generated setting (from VPD).</description>
    <enumerator>
      <name>AUTO</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCE_TO_1N_MODE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCE_TO_2N_MODE</name>
      <value>2</value>
    </enumerator>
    <id>MSS_MRW_DRAM_2N_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Enables DRAM Write CRC</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_DRAM_WRITE_CRC</id>
  </enumerationType>

  <enumerationType>
    <description>An override switch to shut off broadcast mode
        Enum values:
        YES: broadcast mode is forced off
        NO:  broadcast mode uses the default value</description>
    <enumerator>
      <name>NO</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>YES</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_FORCE_BCMODE_OFF</id>
  </enumerationType>

  <enumerationType>
    <description>A bitmap containing the plug rules for NVDIMM.
        1 if a DIMM supports an NVDIMM being plugged in, 0 if it does not
        DIMM slot 0 is the left most bit
        The index to the bitmap is the position of the DIMM target
        As such, a bitmap of 0b10010000, would allow NVDIMM plugged into DIMM0 and DIMM3
        Note: this attribute is a 64 bit number to account for 16 DIMM per processor if there is ever a 4 processor system</description>
    <enumerator>
      <name>NO_NVDIMM</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NVDIMM_CAPABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_NVDIMM_PLUG_RULES</id>
  </enumerationType>

  <enumerationType>
    <description>Switch that allows unsupported raw card references by providing a
      default raw card setting.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_ALLOW_UNSUPPORTED_RCW</id>
  </enumerationType>

  <enumerationType>
    <description>Bitmap of DRAM widths supported by a system. A 1 indicates that the system supports a density.
      Enums below represent the the bit location in the attribute for a given DRAM width.
      Default value is 0xC -&gt; both x4/x8 supported</description>
    <enumerator>
      <name>X4</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>X8</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_SUPPORTED_DRAM_WIDTH</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM] Register Clock Driver, Input Bus Termination for Command/Address in tens of Ohms.</description>
    <enumerator>
      <name>IBT_OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>IBT_100</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>IBT_150</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>IBT_300</name>
      <value>30</value>
    </enumerator>
    <id>MEM_SI_DIMM_RCD_IBT_CA</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM] Register Clock Driver, Input Bus Termination for Clock Enable in tens of Ohms.</description>
    <enumerator>
      <name>IBT_OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>IBT_100</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>IBT_150</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>IBT_300</name>
      <value>30</value>
    </enumerator>
    <id>MEM_SI_DIMM_RCD_IBT_CKE</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM] Register Clock Driver, Input Bus Termination for Chip Select in tens of Ohms.</description>
    <enumerator>
      <name>IBT_OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>IBT_100</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>IBT_150</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>IBT_300</name>
      <value>30</value>
    </enumerator>
    <id>MEM_SI_DIMM_RCD_IBT_CS</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM] Register Clock Driver, Input Bus Termination for On Die Termination in tens of Ohms.</description>
    <enumerator>
      <name>IBT_OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>IBT_100</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>IBT_150</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>IBT_300</name>
      <value>30</value>
    </enumerator>
    <id>MEM_SI_DIMM_RCD_IBT_ODT</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          DQ and DQS Drive Impedance.</description>
    <enumerator>
      <name>OHM34</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>OHM48</name>
      <value>48</value>
    </enumerator>
    <id>MEM_SI_DRAM_DRV_IMP_DQ_DQS</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Number of clocks used for read/write preamble. Calibration only uses 1 nCK preamble (DEFAULT). Mainline has both 1 nCK and 2 nCK preamble option.
          The value of &quot;0&quot; means 1 nCK preamble, the value of &quot;1&quot; means 2 nCK preamble. Bit 3 for READ preamble, and Bit 7 for WRITE preamble.
          E.g. 0b00010001 means 2 nCK preamble for both READ and WRITE</description>
    <enumerator>
      <name>READ_PREAMBLE_BIT</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>WRITE_PREAMBLE_BIT</name>
      <value>7</value>
    </enumerator>
    <id>MEM_SI_DRAM_PREAMBLE</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          DRAM side Nominal Termination Resistance in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OHM34</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>OHM48</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OHM60</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>OHM80</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>OHM120</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>OHM240</name>
      <value>240</value>
    </enumerator>
    <id>MEM_SI_DRAM_RTT_NOM</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          DRAM side Park Termination Resistance in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OHM34</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>OHM48</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OHM60</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>OHM80</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>OHM120</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>OHM240</name>
      <value>240</value>
    </enumerator>
    <id>MEM_SI_DRAM_RTT_PARK</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          DRAM side Write Termination Resistance in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>HIGHZ</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>OHM80</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>OHM120</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>OHM240</name>
      <value>240</value>
    </enumerator>
    <id>MEM_SI_DRAM_RTT_WR</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM][RANK]
        vrefdq_train range. This is for DDR4 MRS6.</description>
    <enumerator>
      <name>RANGE1</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>RANGE2</name>
      <value>1</value>
    </enumerator>
    <id>MEM_SI_VREF_DQ_TRAIN_RANGE</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM][RANK]
        Gear Down Mode.
        This is for DDR4 MRS3.
        Each memory channel will have a value.</description>
    <enumerator>
      <name>HALF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>QUARTER</name>
      <value>1</value>
    </enumerator>
    <id>MEM_SI_GEARDOWN_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Receiver Equalization for Data and Data Strobe Lines.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MEM_SI_MC_RCV_EQ_DQ_DQS</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Drive Equalization for Data and Data Strobe Lines.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FFE</name>
      <value>1</value>
    </enumerator>
    <id>MEM_SI_MC_DRV_EQ_DQ_DQS</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Drive Impedance for Clock in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_MC_DRV_IMP_CLK</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Drive Impedance for Address, Bank Address, Bank Group and Activate Lines in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_MC_DRV_IMP_CMD_ADDR</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Drive Impedance for Clock Enable, ODT, Parity, and Reset Lines in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_MC_DRV_IMP_CNTL</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Drive Impedance for Chip Select and Chip ID Lines in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_MC_DRV_IMP_CSCID</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Drive Impedance Pull Down for Data and Data Strobe Lines in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_DOWN</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Drive Impedance Pull Up for Data and Data Strobe Lines in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_MC_DRV_IMP_DQ_DQS_PULL_UP</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Drive Slew Rate for Clock in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_MC_DRV_SLEW_RATE_CLK</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Drive Slew Rate for Address, Bank Address, Bank Group and Activate Lines in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_MC_DRV_SLEW_RATE_CMD_ADDR</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Drive Slew Rate for Clock Enable, ODT, Parity, and Reset Lines in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_MC_DRV_SLEW_RATE_CNTL</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Drive Slew Rate for Chip Select and Chip ID Lines in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_MC_DRV_SLEW_RATE_CSCID</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Drive Slew Rate for Data and Data Strobe Lines in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_MC_DRV_SLEW_RATE_DQ_DQS</id>
  </enumerationType>

  <enumerationType>
    <description>Memory Controller side Receiver Impedance. Alert_N line in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_MC_RCV_IMP_ALERT_N</id>
  </enumerationType>

  <enumerationType>
    <description>Array[DIMM][RANK]
          Memory Controller side Receiver Impedance. Data and Data Strobe Lines in Ohms.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_MC_RCV_IMP_DQ_DQS</id>
  </enumerationType>

  <enumerationType>
    <description>Memory Controller side Read Vref setting. Dividing by 1000 gives you percentage of Vdd. Disable = 0, defined as no HW adjustment or Vdd/2 if possible.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MEM_SI_VREF_MC_RD</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates whether the OCMB can support enterprise mode or
            if it has been fused to only support non-enterprise mode.
            Note: needs to be setup by the get ECID functionality</description>
    <enumerator>
      <name>NON_ENTERPRISE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENTERPRISE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_OCMB_ENTERPRISE_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates whether the OCMB is allowed to run in enterprise
            mode, commodity mode, or either.

            ALLOW_ENTERPRISE = Most permissive, uses whatever is installed in
               the way it is intended to be used.
            REQUIRE_ENTERPRISE = Throws an error for any commodity dimms that
               are installed.
            FORCE_NONENTERPRISE = Throws an error for any enterprise dimms that
               are installed.</description>
    <enumerator>
      <name>ALLOW_ENTERPRISE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCE_ENTERPRISE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCE_COMMODITY</name>
      <value>2</value>
    </enumerator>
    <id>MSS_OCMB_ENTERPRISE_POLICY</id>
  </enumerationType>

  <enumerationType>
    <description>An override to allow an enterprise capable DIMM to be run in non-enterprise mode.
            Defaults to NO_OVERRIDE</description>
    <enumerator>
      <name>NO_OVERRIDE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OVERRIDE_NON_ENTERPRISE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_OCMB_NONENTERPRISE_MODE_OVERRIDE</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates whether the OCMB should be run in half DIMM mode or not
            Note: needs to be setup by the get ECID functionality</description>
    <enumerator>
      <name>FULL_DIMM</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>HALF_DIMM</name>
      <value>1</value>
    </enumerator>
    <id>MSS_OCMB_HALF_DIMM_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>An override that allows the user to control full or half DIMM mode</description>
    <enumerator>
      <name>NO_OVERRIDE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OVERRIDE_FULL_DIMM</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>OVERRIDE_HALF_DIMM</name>
      <value>2</value>
    </enumerator>
    <id>MSS_OCMB_HALF_DIMM_MODE_OVERRIDE</id>
  </enumerationType>

  <enumerationType>
    <description>Explorer setting for 3DS stack</description>
    <enumerator>
      <name>PLANAR</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>H2</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>H4</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>H8</name>
      <value>8</value>
    </enumerator>
    <id>MEM_EXP_3DS_HEIGHT</id>
  </enumerationType>

  <enumerationType>
    <description>Contains the settings for write/read reorder queue</description>
    <enumerator>
      <name>REORDER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FIFO</name>
      <value>1</value>
    </enumerator>
    <id>MSS_EXP_REORDER_QUEUE_SETTING</id>
  </enumerationType>

  <enumerationType>
    <description>Enable Special mode for Emulation Support</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>EMULATION</name>
      <value>1</value>
    </enumerator>
    <id>MEM_EXP_FIRMWARE_EMULATION_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Controls whether or not transaction bytes are
          swapped before and after mmio accesses to
          the buffer.</description>
    <enumerator>
      <name>SWAP</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NO_SWAP</name>
      <value>1</value>
    </enumerator>
    <id>MSS_OCMB_EXP_STRUCT_MMIO_ENDIAN_CTRL</id>
  </enumerationType>

  <enumerationType>
    <description>Controls whether the structure fields written
          and read to and from the buffer are big
          or little endian.</description>
    <enumerator>
      <name>BIG_ENDIAN</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>LITTLE_ENDIAN</name>
      <value>1</value>
    </enumerator>
    <id>MSS_OCMB_EXP_STRUCT_ENDIAN</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
          A-Side CA bus drives rank 0/1
          and B-Side CA bus drives rank 2/3, DQ/DQS are
          shared across the ranks</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MEM_EFF_FOUR_RANK_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
          MRAM Support
          Support timing parameters of Everspin DDR4 MRAM</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MEM_EFF_MRAM_SUPPORT</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
          DDP Compatibility
          Support 1 rank 3DS Device in DDP board routing.  CKE[1], CSN[1], ODT[1] of
          PHY are connected to C[0], C[1], C[2] of DRAM</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MEM_EFF_DDP_COMPATIBILITY</id>
  </enumerationType>

  <enumerationType>
    <description>ARRAY[DIMM]
          TSV 8H Support
          Support 8H 3DS routing in board routing when parity check is disabled</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MEM_EFF_TSV_8H_SUPPORT</id>
  </enumerationType>

  <enumerationType>
    <description>Enable Explorer upstream transmit template 1.
         Should be disabled by default.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>EXPLR_ENABLE_US_TMPL_1</id>
  </enumerationType>

  <enumerationType>
    <description>Enable Explorer upstream transmit template 5.
         Should be enabled by default.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>EXPLR_ENABLE_US_TMPL_5</id>
  </enumerationType>

  <enumerationType>
    <description>Enable Explorer upstream transmit template 9.
         Should be enabled by default.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>EXPLR_ENABLE_US_TMPL_9</id>
  </enumerationType>

  <enumerationType>
    <description>Enable Explorer upstream transmit template A.
         Not supported by Axone</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>EXPLR_ENABLE_US_TMPL_A</id>
  </enumerationType>

  <enumerationType>
    <description>Enable Explorer upstream transmit template B.
         Not supported by Axone</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>EXPLR_ENABLE_US_TMPL_B</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates the FW MODE of the OCMB</description>
    <enumerator>
      <name>NORMAL_MODE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MANUFACTURING_MODE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>PRODUCT_QUALIFICATION_MODE</name>
      <value>2</value>
    </enumerator>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_FW_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates wheather to enable the loopback test</description>
    <enumerator>
      <name>NO_LOOPBACK_TESTING</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PERFORM_LOOPBACK_TESTING</name>
      <value>1</value>
    </enumerator>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_OPENCAPI_LOOPBACK_TEST</id>
  </enumerationType>

  <enumerationType>
    <description>The transport layer of OCMB</description>
    <enumerator>
      <name>OPEN_CAPI</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>I2C</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>JTAG</name>
      <value>2</value>
    </enumerator>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_TRANSPORT_LAYER</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates whether the OpenCAPI DL boots immediately
            or waits for host command.</description>
    <enumerator>
      <name>BOOT_RIGHT_AFTER_CONFIG</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>WAIT_FOR_HOST_CMD</name>
      <value>1</value>
    </enumerator>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_DL_LAYER_BOOT_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Set to disable DFE</description>
    <enumerator>
      <name>DEFAULT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>DISABLED</name>
      <value>1</value>
    </enumerator>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_DFE_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>The lane width of the OpenCapi channel</description>
    <enumerator>
      <name>LANE_8</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>LANE_4</name>
      <value>2</value>
    </enumerator>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>The frequency of the OpenCAPI</description>
    <enumerator>
      <name>SERDES_21_33GBPS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SERDES_23_46GBPS</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>SERDES_25_60GBPS</name>
      <value>3</value>
    </enumerator>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY</id>
  </enumerationType>

  <enumerationType>
    <description>The frequency of a processor's nest mesh clock, in MHz.
    This is the same for all chips in the system.
    Provided by the MRW.</description>
    <enumerator>
      <name>1600</name>
      <value>1600</value>
    </enumerator>
    <enumerator>
      <name>1866</name>
      <value>1866</value>
    </enumerator>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <enumerator>
      <name>2133</name>
      <value>2133</value>
    </enumerator>
    <enumerator>
      <name>2400</name>
      <value>2400</value>
    </enumerator>
    <id>FREQ_PB_MHZ</id>
  </enumerationType>

  <enumerationType>
    <description>MC mesh to use Nest mesh or not</description>
    <enumerator>
      <name>IN_SYNC</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NOT_IN_SYNC</name>
      <value>0</value>
    </enumerator>
    <id>MC_SYNC_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>HWP/Init &quot;risk level&quot; enabled. Used by HB to pass to HB driven
      HWPs</description>
    <enumerator>
      <name>RL0</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>RL1</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>RL2</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>RL3</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>RL4</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>RL5</name>
      <value>0x5</value>
    </enumerator>
    <id>RISK_LEVEL</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates if LPC console is enabled on system</description>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <id>LPC_CONSOLE_CNFG</id>
  </enumerationType>

  <enumerationType>
    <description>Switch to enable or disable Power Management Complex FFDC collection to HOMER.
  When set, the PM Complex Reset flow will collect PM Complex data to the chip
  HOMER region to assist with failure analysis and recovery.

  Producer: HB must set or reset this based on the platform use-case and state.
  Consumer: p9_pm_reset.C, p9_pm_callout.C</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x01</value>
    </enumerator>
    <id>PM_RESET_FFDC_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Per-link optics configuration
    0 = default = SMP
    1 = CAPI 2.0
    2 = NV 2.0
    3 = OPENCAPI
    Provided by the MRW.</description>
    <enumerator>
      <name>SMP</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CAPI</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NV</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>OCAPI</name>
      <value>0x3</value>
    </enumerator>
    <id>OPTICS_CONFIG_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Spare DRAM availability. Used in various locations and is computed in mss_eff_cnfg.
      creator: mss_eff_cnfg consumer: various firmware notes: load from spd
      OBSOLETE: Use ATTR_VPD_DIMM_SPARE</description>
    <enumerator>
      <name>NO_SPARE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>LOW_NIBBLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>HIGH_NIBBLE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FULL_BYTE</name>
      <value>3</value>
    </enumerator>
    <id>EFF_DIMM_SPARE</id>
  </enumerationType>

  <enumerationType>
    <description>The frequency of the memory controller channel. In synchronous mode,
    this is equivalent to ATTR_FREQ_PB_MHZ. This may be independently set
    per pair of memory channels if operating in asynchronous mode,
    but this configuration is not anticipated. This clock drives the MCU queues,
    and all the associated logic that drives the inputs to the DMI and reads
    its outputs.</description>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <enumerator>
      <name>2400</name>
      <value>2400</value>
    </enumerator>
    <id>FREQ_MCA_MHZ</id>
  </enumerationType>

  <enumerationType>
    <description>In sub DD1.02 Nimbus the HW VREF calibrations should not be run</description>
    <enumerator>
      <name>RUN</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SKIP</name>
      <value>1</value>
    </enumerator>
    <id>SKIP_HW_VREF_CAL</id>
  </enumerationType>

  <enumerationType>
    <description>In sub DD1.03 Nimbus the HW VREF calibrations should not be run</description>
    <enumerator>
      <name>RUN</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SKIP</name>
      <value>1</value>
    </enumerator>
    <id>SKIP_RD_VREF_VREFSENSE_OVERRIDE</id>
  </enumerationType>

  <enumerationType>
    <description>Set equal to 1 to disable setting of RTT_NOM to use RTT_WR values
    during WR_LEVEL calibration.</description>
    <enumerator>
      <name>NO</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>YES</name>
      <value>1</value>
    </enumerator>
    <id>MSS_RTT_NOM_OVERRIDE_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the L3
   Trace array for debug.  Note:  all configured CMEs will be put into this
   mode if this attribute is ON.

   Consumer: p9_hcode_image_build.c -&gt;
                SGPE Header field

   Platform default:  OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>CME_INSTRUCTION_TRACE_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Enables pstate parameter block code to use the static system vfrt data
   Consumer: p9_pstate_parameter_block.C -&gt;

   Platform default:  OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>VDN_STEP_OFF</name>
      <value>0x02</value>
    </enumerator>
    <id>SYS_VFRT_STATIC_DATA_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Flags to indicate if rx / tx dccal has been run.</description>
    <enumerator>
      <name>NONE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TX</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>RX</name>
      <value>0x2</value>
    </enumerator>
    <id>IO_OBUS_DCCAL_FLAGS</id>
  </enumerationType>

  <enumerationType>
    <description>Indicate if debug data should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_O_DEBUG</id>
  </enumerationType>

  <enumerationType>
    <description>Indicate if manufacturing tests should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_X_MFG_CHK</id>
  </enumerationType>

  <enumerationType>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the CHTM
   for debug.  Note:  all configured CMEs will be put into this
   mode if this attribute is ON.

   Consumer: p9_hcode_image_build.c -&gt;
                SGPE Header field

   Platform default:  OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>CME_CHTM_TRACE_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Disables the enablement of Voltage Droop Monitors (VDM) in the system.

    Producer:  MRW

    Consumers:
      p9_pstate_parameter_block to clear flag for CME QuadManager Hcode
          reaction</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>SYSTEM_VDM_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Indicator that all relevant attributes and required data for
  Voltage Droop Monitors (VDM) to be enabled is present and valid

  Producer: p9_build_pstate_datablock

  Consumers: p9_hcode_image_build -&gt;
                    SGPE Header
                    CME Header</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>VDM_ENABLED</id>
  </enumerationType>

  <enumerationType>
    <description>Disables IVRM enablement in the system

  Producer: Override

  Consumers: p9_build_pstate_datablock -&gt;
                    Pstate Parameter Block (PSPB) for PGPE/OCC
                    CME Quad Pstate Region (CQPR) for CM Quad Manager</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_IVRM_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Indicator that all relevant attributes and required data for
  Internal Voltage Regulator Macros (IVRMs) to be enabled is present and valid

  Producer: p9_build_pstate_datablock

  Consumers: p9_hcode_image_build -&gt;
                    PGPE Header
                    CME Header</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>IVRM_ENABLED</id>
  </enumerationType>

  <enumerationType>
    <description>Controls ENABLE/DISABLE of workaround that sets
      the PHY sequencer to trigger refresh after draminit.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_PHY_SEQ_REFRESH</id>
  </enumerationType>

  <enumerationType>
    <description>If wof_enabled, defines the Frequency Ratio calculation performed.
  (THIS IS NOT SUPPORTED IN P9 GA1!).</description>
    <enumerator>
      <name>FIXED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>STEPPED</name>
      <value>1</value>
    </enumerator>
    <id>WOF_ENABLE_FRATIO</id>
  </enumerationType>

  <enumerationType>
    <description>If wof_enabled, defines the Voltage Ratio calculation performed.
  THIS IS NOT SUPPORTED AT PRESENT. GA1 SUPPORT IS TBD).</description>
    <enumerator>
      <name>FIXED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CALCULATED</name>
      <value>1</value>
    </enumerator>
    <id>WOF_ENABLE_VRATIO</id>
  </enumerationType>

  <enumerationType>
    <description>If wof_enabled AND ATTR_WOF_ENABLE_VRATIO = CALCULATED, this attribute
  selects the Vratio calculation type.
  ACTIVE_CORES: Vratio is the number of active cores to the
  number of good cores
  FULL: Vratio is Vaverage to Vclip(Fclip) where Vclip(Fclip) is
  the normal interpolated regulator voltage (including load line uplife @ RDP
  current) derated with presently measured Idd current (from the AVSBus) and
  the loadline.</description>
    <enumerator>
      <name>ACTIVE_CORES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FULL</name>
      <value>1</value>
    </enumerator>
    <id>WOF_VRATIO_SELECT</id>
  </enumerationType>

  <enumerationType>
    <description>Selects whether or not DCD should be run</description>
    <enumerator>
      <name>NO</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>YES</name>
      <value>1</value>
    </enumerator>
    <id>MSS_RUN_DCD_CALIBRATION</id>
  </enumerationType>

  <enumerationType>
    <description>Controls ENABLE/DISABLE of Write CRC</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_EFF_WR_CRC</id>
  </enumerationType>

  <enumerationType>
    <description>Indicate if manufcaturing tests should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_O_MFG_CHK</id>
  </enumerationType>

  <enumerationType>
    <description>To allow for selective enablement for lab testing
  To allow skew function to be enabled/disabled.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>SYSTEM_CORECACHE_SKEWADJ_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>To allow for selective enablement for lab testing
  To allow dcadj function to be enabled/disabled.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>SYSTEM_CORECACHE_DCADJ_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates that a special wakeup is in progress for an EQ

  Producer: p9_cpu_special_wakeup_eq.C

  Consumers: p9_cpu_special_wakeup_eq.C</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>EQ_INSIDE_SPECIAL_WAKEUP</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates that a special wakeup is in progress for an EX.

  Producer: p9_cpu_special_wakeup_ex.C

  Consumers: p9_cpu_special_wakeup_ex.C</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>EX_INSIDE_SPECIAL_WAKEUP</id>
  </enumerationType>

  <enumerationType>
    <description>Alternate settings for short Xbus channels
    bit 0 -- Disable RX LTE
    bit 1 -- Disable AC BOOST
    bit 2 -- Low Gain/Peaking Init Settings
    bit 3 -- Lower VGA Gain Target -10%</description>
    <enumerator>
      <name>DIS_RX_LTE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>DIS_TX_AC_BOOST</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>LOWER_GAIN_PEAK_INITS</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>LOWER_VGA_GAIN_TARGET</name>
      <value>0x08</value>
    </enumerator>
    <id>IO_XBUS_CHAN_EQ</id>
  </enumerationType>

  <enumerationType>
    <description>Indicates if the Obus channel is a board or a cable</description>
    <enumerator>
      <name>BOARD</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_O_CHANNEL_TYPE</id>
  </enumerationType>

  <enumerationType>
    <default>NONE</default>
    <description>
        Enumeration specifying a target's CEC degraded mode domain
    </description>
    <enumerator>
      <name>NONE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CPU</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FABRIC</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEM</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>IO</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CLOCK</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>ALL</name>
      <value>10</value>
    </enumerator>
    <id>CDM_DOMAIN</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration of CDM_POLICIES flags</description>
    <enumerator>
      <description>
        MFG_Guard policy:
        Used in MFG only to prevent and disable the following:
        . Storing or creation of new Guard records from Diagno`stic or other
            faults through error logs. This is all domains, CEC
            processor/memory, VPD, FSP, etc.
        . Storing or creation of Manual Guard record from user.
            NOTE: this does not stop FCO.
        . Using an already stored System or Manual Guard record from
            deconfiguring resources. This is all domains, CEC
            processor/memory, VPD, FSP, etc.
        </description>
      <name>MANUFACTURING_DISABLED</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <description>
        Predictive_Guard policy:
        Used in Field or development to prevent and disable the following:
        . Storing or creation of new Guard records from diagnostics or other
            faults through error logs with the error_type of Predictive.
        . Using an already stored System Guard record with error_type of
            Predictive from deconfiguring resources.
        </description>
      <name>PREDICTIVE_DISABLED</name>
      <value>0x02</value>
    </enumerator>
    <id>CDM_POLICIES</id>
  </enumerationType>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's class</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CARD</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENC</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>CHIP</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>UNIT</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>DEV</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>LOGICAL_CARD</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>BATTERY</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>LED</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>ASIC</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MAX</name>
      <value>12</value>
    </enumerator>
    <id>CLASS</id>
  </enumerationType>

  <enumerationType>
    <default>RAW</default>
    <description>Enumeration indicating a target's eeprom
        content type.
        RAW - eeprom has no specified layout
        ISDIMM - uses standard JEDEC layout for DDR memory
        IBM_FRUVPD - uses ipz converged vpd layout with records/keywords for
                     generic FRUs
        IBM_MVPD - use ipz converged vpd layout with records/keywords for
                   processor modules
        DDIMM - uses Differential DIMM layout
    </description>
    <enumerator>
      <name>RAW</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ISDIMM</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>IBM_FRUVPD</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>IBM_MVPD</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>DDIMM</name>
      <value>4</value>
    </enumerator>
    <id>EEPROM_CONTENT_TYPE</id>
  </enumerationType>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's engine type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_IIC</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_SCOM</name>
      <value>2</value>
    </enumerator>
    <id>ENGINE_TYPE</id>
  </enumerationType>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration defining special FAPI_POS values</description>
    <enumerator>
      <name>NA</name>
      <value>0xFFFFFFFF</value>
    </enumerator>
    <id>FAPI_POS</id>
  </enumerationType>

  <enumerationType>
    <default>NO_MASTER</default>
    <description>Enumeration indicating the master's FSI type</description>
    <enumerator>
      <name>MFSI</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CMFSI</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NO_MASTER</name>
      <value>2</value>
    </enumerator>
    <id>FSI_MASTER_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>Enum for FUSED_CORE_MODE_HB</description>
    <enumerator>
      <name>SMT4_DEFAULT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SMT4_ONLY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SMT8_ONLY</name>
      <value>2</value>
    </enumerator>
    <id>FUSED_CORE_MODE_HB</id>
  </enumerationType>

  <enumerationType>
    <description>Enum for FUSED_CORE_OPTION</description>
    <enumerator>
      <name>USING_DEFAULT_CORES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>USING_NORMAL_CORES</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>USING_FUSED_CORES</name>
      <value>2</value>
    </enumerator>
    <id>FUSED_CORE_OPTION</id>
  </enumerationType>

  <enumerationType>
    <description>Pulled from the MRW, this describes the device
            purpose to the HDAT.  This is for I2C devices only.
    </description>
    <enumerator>
      <name>CABLE_CARD_PRES</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_PGOOD</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_CONTROL</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>MODULE_VPD</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>DIMM_SPD</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>PROC_MODULE_VPD</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>SBE_SEEPROM</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>PLANAR_VPD</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_TOPOLOGY_VERIFICATION</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_MICRO_RESET</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>I2C_ASSOC_WITH_NVLINK_CABLE</name>
      <value>0xC</value>
    </enumerator>
    <enumerator>
      <name>WINDOW_OPEN</name>
      <value>0xD</value>
    </enumerator>
    <enumerator>
      <name>PHYSICAL_PRESENCE</name>
      <value>0xE</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0xF</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
  </enumerationType>

  <enumerationType>
    <description>Pulled from the MRW, this describes the device
            type to the HDAT.  This is for I2C devices only.
    </description>
    <enumerator>
      <name>9551</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>955X</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c128</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>NUVOTON_TPM</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>UCX90XX</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9552</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9553</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>9554</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>9555</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>SMP_or_OpenCAPI_Cable</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c256</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>THERMAL_SENSOR</name>
      <value>0x0C</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c04</name>
      <value>0x0D</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c412</name>
      <value>0x0E</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c32</name>
      <value>0x0F</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c64</name>
      <value>0x10</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c16</name>
      <value>0x11</value>
    </enumerator>
    <enumerator>
      <name>NVDIA_GPU</name>
      <value>0x12</value>
    </enumerator>
    <enumerator>
      <name>NXP_LPC_Microcontroller_LPC11U35</name>
      <value>0x13</value>
    </enumerator>
    <enumerator>
      <name>9550</name>
      <value>0x14</value>
    </enumerator>
    <enumerator>
      <name>TCG_I2C_TPM</name>
      <value>0x15</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the services that are concerned
        with target changes (ie, via HCDB change).
        The values can be combined using a bitwise 'OR'.
    </description>
    <enumerator>
      <name>GARD</name>
      <value>0x00000001</value>
    </enumerator>
    <enumerator>
      <name>MEMDIAG</name>
      <value>0x00000002</value>
    </enumerator>
    <enumerator>
      <name>PSIDIAG</name>
      <value>0x00000004</value>
    </enumerator>
    <enumerator>
      <name>DIAG_MASK</name>
      <value>0x00000006</value>
    </enumerator>
    <enumerator>
      <name>HOSTSVC_HBEL</name>
      <value>0x00000008</value>
    </enumerator>
    <enumerator>
      <name>RESRC_RECOV</name>
      <value>0x00000010</value>
    </enumerator>
    <enumerator>
      <name>GARD_APPLIED</name>
      <value>0x00000020</value>
    </enumerator>
    <id>HWAS_CHANGED_BIT</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enum indicating the current Secure Boot key transition state for the
        node.
    </description>
    <enumerator>
      <description>
            Secure Boot key transition not yet requested for the node
        </description>
      <name>KEY_TRANSITION_NOT_REQUESTED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <description>
            About to write new system Secure Boot key to first SBE SEEPROM
            side in the node
        </description>
      <name>KEY_TRANSITION_STARTED</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <description>
            Failed to apply new system Secure Boot key to one or more functional
            SBE SEEPROM sides in the node
        </description>
      <name>KEY_TRANSITION_FAILED</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <description>
            Successfully applied new system Secure Boot key to every functional
            SBE SEEPROM side in the node
        </description>
      <name>KEY_TRANSITION_SUCCEEDED</name>
      <value>3</value>
    </enumerator>
    <id>KEY_TRANSITION_STATE</id>
  </enumerationType>

  <enumerationType>
    <description>Enum for MFG_WRAP_TEST_ABUS_LINKS_SET</description>
    <enumerator>
      <name>SET_NONE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>SET_1</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>SET_2</name>
      <value>0x2</value>
    </enumerator>
    <id>MFG_WRAP_TEST_ABUS_LINKS_SET</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the mnfg flags
        that are set by the user.  The values can be
        combined using a bitwise 'OR'.  The values will
        need to be kept in sync with the FAPI
        enumerator values.  Also the enumeration type
        is used by the ATTR_MNFG_FLAGS attribute.  Should
        note that the MNFG_FLAG values are of type uint32_t
    </description>
    <enumerator>
      <name>THRESHOLDS</name>
      <value>0x00000001</value>
    </enumerator>
    <enumerator>
      <name>AVP_ENABLE</name>
      <value>0x00000002</value>
    </enumerator>
    <enumerator>
      <name>HDAT_AVP_ENABLE</name>
      <value>0x00000004</value>
    </enumerator>
    <enumerator>
      <name>SRC_TERM</name>
      <value>0x00000008</value>
    </enumerator>
    <enumerator>
      <name>IPL_MEMORY_CE_CHECKING</name>
      <value>0x00000010</value>
    </enumerator>
    <enumerator>
      <name>FAST_BACKGROUND_SCRUB</name>
      <value>0x00000020</value>
    </enumerator>
    <enumerator>
      <name>TEST_DRAM_REPAIRS</name>
      <value>0x00000040</value>
    </enumerator>
    <enumerator>
      <name>DISABLE_DRAM_REPAIRS</name>
      <value>0x00000080</value>
    </enumerator>
    <enumerator>
      <name>ENABLE_EXHAUSTIVE_PATTERN_TEST</name>
      <value>0x00000100</value>
    </enumerator>
    <enumerator>
      <name>ENABLE_STANDARD_PATTERN_TEST</name>
      <value>0x00000200</value>
    </enumerator>
    <enumerator>
      <name>ENABLE_MINIMUM_PATTERN_TEST</name>
      <value>0x00000400</value>
    </enumerator>
    <enumerator>
      <name>DISABLE_FABRIC_eREPAIR</name>
      <value>0x00000800</value>
    </enumerator>
    <enumerator>
      <name>DISABLE_MEMORY_eREPAIR</name>
      <value>0x00001000</value>
    </enumerator>
    <enumerator>
      <name>FABRIC_DEPLOY_LANE_SPARES</name>
      <value>0x00002000</value>
    </enumerator>
    <enumerator>
      <name>DMI_DEPLOY_LANE_SPARES</name>
      <value>0x00004000</value>
    </enumerator>
    <enumerator>
      <name>PSI_DIAGNOSTIC</name>
      <value>0x00008000</value>
    </enumerator>
    <enumerator>
      <name>BRAZOS_WRAP_CONFIG</name>
      <value>0x00010000</value>
    </enumerator>
    <enumerator>
      <name>FSP_UPDATE_SBE_IMAGE</name>
      <value>0x00020000</value>
    </enumerator>
    <enumerator>
      <name>UPDATE_BOTH_SIDES_OF_SBE</name>
      <value>0x00040000</value>
    </enumerator>
    <enumerator>
      <name>IMMEDIATE_HALT</name>
      <value>0x00080000</value>
    </enumerator>
    <id>MNFG_FLAG</id>
  </enumerationType>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's model</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>RESERVED</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>VENICE</name>
    </enumerator>
    <enumerator>
      <name>MURANO</name>
    </enumerator>
    <enumerator>
      <name>NAPLES</name>
    </enumerator>
    <enumerator>
      <name>NIMBUS</name>
    </enumerator>
    <enumerator>
      <name>CUMULUS</name>
    </enumerator>
    <enumerator>
      <name>AXONE</name>
    </enumerator>
    <enumerator>
      <name>CENTAUR</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OCMB</name>
    </enumerator>
    <enumerator>
      <name>JEDEC</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>CDIMM</name>
    </enumerator>
    <enumerator>
      <name>POWER8</name>
      <value>112</value>
    </enumerator>
    <enumerator>
      <name>POWER9</name>
      <value>144</value>
    </enumerator>
    <enumerator>
      <name>POWER10</name>
      <value>145</value>
    </enumerator>
    <enumerator>
      <name>CECTPM</name>
    </enumerator>
    <enumerator>
      <name>BMC</name>
    </enumerator>
    <enumerator>
      <name>AST2500</name>
    </enumerator>
    <enumerator>
      <name>AST2600</name>
    </enumerator>
    <enumerator>
      <name>PCA9847</name>
    </enumerator>
    <enumerator>
      <name>UCD9090</name>
    </enumerator>
    <enumerator>
      <name>UCD90120A</name>
    </enumerator>
    <enumerator>
      <name>UCD90320</name>
    </enumerator>
    <id>MODEL</id>
  </enumerationType>

  <enumerationType>
    <default>NONE</default>
    <description>Memory power control settings for IDLE powersave mode
        Used by OCC when entering idle power-save mode</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR_CLK_STOP</name>
      <value>0x03</value>
    </enumerator>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
  </enumerationType>

  <enumerationType>
    <default>OFF</default>
    <description>Memory power control settings programmed during IPL
        Used by OCC when exiting idle power-save mode</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR_CLK_STOP</name>
      <value>0x03</value>
    </enumerator>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
  </enumerationType>

  <enumerationType>
    <description>Used in MR4 A3
        Temperature refresh mode
        Should be defaulted to disable</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the multi scome
        buffer size. The values can be combined using a
        bitwise 'OR'.  The values will need to be kept
        in sync with the FAPI enumerator values.  Also
        the enumeration type is used by the
        ATTR_MULTI_SCOM_BUFFER_MAX_SIZE.  Should
        note that the MULTI_SCOM_BUFFER_MAX_SIZE values
        are of type uint32_t
    </description>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1KB</name>
      <value>0x00000400</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_2KB</name>
      <value>0x00000800</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_4KB</name>
      <value>0x00001000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_8KB</name>
      <value>0x00002000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_16KB</name>
      <value>0x00004000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_32KB</name>
      <value>0x00008000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_64KB</name>
      <value>0x00010000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_128KB</name>
      <value>0x00020000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_256KB</name>
      <value>0x00040000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_512KB</name>
      <value>0x00080000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1MB</name>
      <value>0x00100000</value>
    </enumerator>
    <id>MULTI_SCOM_BUFFER_MAX_SIZE_BIT</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the BAR size
        used with ATTR_PROC_NPU_MMIO_BAR_SIZE</description>
    <enumerator>
      <name>2_MB</name>
      <value>0x0000000000200000</value>
    </enumerator>
    <enumerator>
      <name>1_MB</name>
      <value>0x0000000000100000</value>
    </enumerator>
    <enumerator>
      <name>512_KB</name>
      <value>0x0000000000080000</value>
    </enumerator>
    <enumerator>
      <name>256_KB</name>
      <value>0x0000000000040000</value>
    </enumerator>
    <enumerator>
      <name>128_KB</name>
      <value>0x0000000000020000</value>
    </enumerator>
    <enumerator>
      <name>64_KB</name>
      <value>0x0000000000010000</value>
    </enumerator>
    <id>NPU_MMIO_BAR_SIZE</id>
  </enumerationType>

  <enumerationType>
    <default>UNKNOWN</default>
    <description>
        Enumeration indicating what kind of payload is to be started
    </description>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PHYP</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SAPPHIRE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <id>PAYLOAD_KIND</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the OFF setting for the core and cache chiplet
        VCS PFET controllers
    </description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VCS_VOFF_SEL</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the OFF setting for the core and cache chiplet
        DD PFET controllers
    </description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VDD_VOFF_SEL</id>
  </enumerationType>

  <enumerationType>
    <default>ALLOW_COMPATIBILITY</default>
    <description>
        Enumeration specifying the compatibility setting for Processor ECs
        ALLOW_COMPATIBILITY = set RISK_LEVEL to best allowed
        FORCED_COMPATIBILITY = set RISK_LEVEL to a compatible level
        FORCED_NATIVE = set RISK_LEVEL to ECs native setting
    </description>
    <enumerator>
      <name>ALLOW_COMPATIBILITY</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCED_COMPATIBILITY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCED_NATIVE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_COMPATIBILITY_REQ</id>
  </enumerationType>

  <enumerationType>
    <description>Processor epsilon table type.
    Used to calculate the processor nest epsilon register values.
    Provided by the MRW.</description>
    <enumerator>
      <name>EPS_TYPE_LE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>EPS_TYPE_MR</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>EPS_TYPE_HE</name>
      <value>0x03</value>
    </enumerator>
    <id>PROC_EPS_TABLE_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_A_BUS_WIDTH
    </description>
    <enumerator>
      <name>2_BYTE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_FABRIC_A_BUS_WIDTH</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_CAPI_MODE
    </description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_CAPI_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Processor SMP Fabric broadcast scope configuration.
    CHIP_IS_NODE = MODE1 = default
    CHIP_IS_GROUP = MODE2
    Provided by the MRW.</description>
    <enumerator>
      <name>CHIP_IS_NODE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>CHIP_IS_GROUP</name>
      <value>0x02</value>
    </enumerator>
    <id>PROC_FABRIC_PUMP_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_SMP_OPTICS_MODE
    </description>
    <enumerator>
      <name>OPTICS_IS_X_BUS</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>OPTICS_IS_A_BUS</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_SMP_OPTICS_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_X_BUS_WIDTH
    </description>
    <enumerator>
      <name>2_BYTE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_FABRIC_X_BUS_WIDTH</id>
  </enumerationType>

  <enumerationType>
    <default>NOT_MASTER</default>
    <description>
        Enumeration indicating the role of proc as master/alt_master/not_master
    </description>
    <enumerator>
      <name>ACTING_MASTER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MASTER_CANDIDATE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NOT_MASTER</name>
      <value>2</value>
    </enumerator>
    <id>PROC_MASTER_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating which _PBIEX_ASYNC_SEL should be use</description>
    <enumerator>
      <name>SEL0</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SEL1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SEL2</name>
      <value>2</value>
    </enumerator>
    <id>PROC_PBIEX_ASYNC_SEL</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating which chip should be used as the PROC_SELECT_BOOT_MASTER</description>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_BOOT_MASTER</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating which SEEPROM image should be used to boot a processor</description>
    <enumerator>
      <name>FIRST</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECOND</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating which SEEPROM image should be used for the boot master</description>
    <enumerator>
      <name>FIRST</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECOND</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_SEEPROM_IMAGE</id>
  </enumerationType>

  <enumerationType>
    <description>Used to inidicate if a reconfigure loop is needed</description>
    <enumerator>
      <name>DECONFIGURE</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>BAD_DQ_BIT_SET</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>RCD_PARITY_ERROR</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>OCMB_FW_UPDATE</name>
      <value>0x8</value>
    </enumerator>
    <id>RECONFIGURE_LOOP</id>
  </enumerationType>

  <enumerationType>
    <default>USER</default>
    <description>
        Enumeration specifying what was used to setup the RISK_LEVEL
    </description>
    <enumerator>
      <name>USER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MRW</name>
      <value>1</value>
    </enumerator>
    <id>RISK_LEVEL_ORIGIN</id>
  </enumerationType>

  <enumerationType>
    <default>NA</default>
    <description>
        Enumeration indication which Hot Plug Controllers are supported by
        the current system.
    </description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MAX5961</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PCA9551</name>
      <value>0x02</value>
    </enumerator>
    <id>SUPPORTED_HOT_PLUG</id>
  </enumerationType>

  <enumerationType>
    <default>NON_MASTER</default>
    <description>
        Enumeration indicating what role this chip has in tod topology
    </description>
    <enumerator>
      <name>NON_MASTER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY</name>
      <value>2</value>
    </enumerator>
    <id>TOD_ROLE</id>
  </enumerationType>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>PROC</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>EX</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>L2</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>L3</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>L4</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>MCS</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MBA</name>
      <value>13</value>
    </enumerator>
    <enumerator>
      <name>XBUS</name>
      <value>14</value>
    </enumerator>
    <enumerator>
      <name>ABUS</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>PCI</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>DPSS</name>
      <value>17</value>
    </enumerator>
    <enumerator>
      <name>APSS</name>
      <value>18</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>19</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>21</value>
    </enumerator>
    <enumerator>
      <name>PNOR</name>
      <value>22</value>
    </enumerator>
    <enumerator>
      <name>OSC</name>
      <value>23</value>
    </enumerator>
    <enumerator>
      <name>TODCLK</name>
      <value>24</value>
    </enumerator>
    <enumerator>
      <name>CONTROL_NODE</name>
      <value>25</value>
    </enumerator>
    <enumerator>
      <name>OSCREFCLK</name>
      <value>26</value>
    </enumerator>
    <enumerator>
      <name>OSCPCICLK</name>
      <value>27</value>
    </enumerator>
    <enumerator>
      <name>REFCLKENDPT</name>
      <value>28</value>
    </enumerator>
    <enumerator>
      <name>PCICLKENDPT</name>
      <value>29</value>
    </enumerator>
    <enumerator>
      <name>NX</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>PORE</name>
      <value>31</value>
    </enumerator>
    <enumerator>
      <name>PCIESWITCH</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>CAPP</name>
      <value>33</value>
    </enumerator>
    <enumerator>
      <name>FSI</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>EQ</name>
      <value>35</value>
    </enumerator>
    <enumerator>
      <name>MCA</name>
      <value>36</value>
    </enumerator>
    <enumerator>
      <name>MCBIST</name>
      <value>37</value>
    </enumerator>
    <enumerator>
      <name>MI</name>
      <value>38</value>
    </enumerator>
    <enumerator>
      <name>DMI</name>
      <value>39</value>
    </enumerator>
    <enumerator>
      <name>OBUS</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>SBE</name>
      <value>42</value>
    </enumerator>
    <enumerator>
      <name>PPE</name>
      <value>43</value>
    </enumerator>
    <enumerator>
      <name>PERV</name>
      <value>44</value>
    </enumerator>
    <enumerator>
      <name>PEC</name>
      <value>45</value>
    </enumerator>
    <enumerator>
      <name>PHB</name>
      <value>46</value>
    </enumerator>
    <enumerator>
      <name>SYSREFCLKENDPT</name>
      <value>47</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLKENDPT</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>49</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>50</value>
    </enumerator>
    <enumerator>
      <name>UART</name>
      <value>51</value>
    </enumerator>
    <enumerator>
      <name>PS</name>
      <value>52</value>
    </enumerator>
    <enumerator>
      <name>FAN</name>
      <value>53</value>
    </enumerator>
    <enumerator>
      <name>VRM</name>
      <value>54</value>
    </enumerator>
    <enumerator>
      <name>USB</name>
      <value>55</value>
    </enumerator>
    <enumerator>
      <name>ETH</name>
      <value>56</value>
    </enumerator>
    <enumerator>
      <name>PANEL</name>
      <value>57</value>
    </enumerator>
    <enumerator>
      <name>BMC</name>
      <value>58</value>
    </enumerator>
    <enumerator>
      <name>FLASH</name>
      <value>59</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>TMP</name>
      <value>61</value>
    </enumerator>
    <enumerator>
      <name>GPIO_EXPANDER</name>
      <value>62</value>
    </enumerator>
    <enumerator>
      <name>POWER_SEQUENCER</name>
      <value>63</value>
    </enumerator>
    <enumerator>
      <name>RTC</name>
      <value>64</value>
    </enumerator>
    <enumerator>
      <name>FANCTLR</name>
      <value>65</value>
    </enumerator>
    <enumerator>
      <name>OBUS_BRICK</name>
      <value>66</value>
    </enumerator>
    <enumerator>
      <name>NPU</name>
      <value>67</value>
    </enumerator>
    <enumerator>
      <name>MC</name>
      <value>68</value>
    </enumerator>
    <enumerator>
      <name>TEST_FAIL</name>
      <value>69</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLK</name>
      <value>70</value>
    </enumerator>
    <enumerator>
      <name>SMPGROUP</name>
      <value>71</value>
    </enumerator>
    <enumerator>
      <name>OMI</name>
      <value>72</value>
    </enumerator>
    <enumerator>
      <name>MCC</name>
      <value>73</value>
    </enumerator>
    <enumerator>
      <name>OMIC</name>
      <value>74</value>
    </enumerator>
    <enumerator>
      <name>OCMB_CHIP</name>
      <value>75</value>
    </enumerator>
    <enumerator>
      <name>MEM_PORT</name>
      <value>76</value>
    </enumerator>
    <enumerator>
      <name>I2C_MUX</name>
      <value>77</value>
    </enumerator>
    <enumerator>
      <name>PMIC</name>
      <value>78</value>
    </enumerator>
    <enumerator>
      <name>NMMU</name>
      <value>79</value>
    </enumerator>
    <enumerator>
      <name>PAU</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>IOHS</name>
      <value>81</value>
    </enumerator>
    <enumerator>
      <name>PAUC</name>
      <value>82</value>
    </enumerator>
    <enumerator>
      <name>FC</name>
      <value>83</value>
    </enumerator>
    <enumerator>
      <name>LAST_IN_RANGE</name>
      <value>84</value>
    </enumerator>
    <id>TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration for Voltage Drop Monitor enable</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>VDM_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration to select WOF Power Limit</description>
    <enumerator>
      <name>NOMINAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TURBO</name>
      <value>1</value>
    </enumerator>
    <id>WOF_POWER_LIMIT</id>
  </enumerationType>

  <enumerationType>
    <description>Enum for CHKSTOP_ANALYSIS_ON_STARTUP</description>
    <enumerator>
      <name>NOT_ANALYZING_DEFAULT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ANALYZING_CHECKSTOP</name>
      <value>1</value>
    </enumerator>
    <id>CHKSTOP_ANALYSIS_ON_STARTUP</id>
  </enumerationType>

  <enumerationType>
    <description>Enum for HB_INITIATED_PM_RESET</description>
    <enumerator>
      <name>INACTIVE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>IN_PROGRESS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>COMPLETE</name>
      <value>2</value>
    </enumerator>
    <id>HB_INITIATED_PM_RESET</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration of HIDDEN_ERRLOGS_ENABLE</description>
    <enumerator>
      <name>NO_HIDDEN_LOGS</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLOW_INFORMATIONAL</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLOW_RECOVERED</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLOW_ALL_LOGS</name>
      <value>3</value>
    </enumerator>
    <id>HIDDEN_ERRLOGS_ENABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration defining the offsets into the
        IPMI_SENSORS array.</description>
    <enumerator>
      <name>NAME_OFFSET</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>NUMBER_OFFSET</name>
      <value>0x01</value>
    </enumerator>
    <id>IPMI_SENSOR_ARRAY</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the IPMI sensor name, which will
        be used by hostboot when determining the sensor number to return.
        The sensor name consists of one byte of sensor type plus one byte of
        sub-type, to differentiate similar sensors under the same target.
        Our implementaion uses the IPMI defined entity ID as the sub-type.
    </description>
    <enumerator>
      <name>PROC_TEMP</name>
      <value>0x0103</value>
    </enumerator>
    <enumerator>
      <name>DIMM_TEMP</name>
      <value>0x0120</value>
    </enumerator>
    <enumerator>
      <name>CORE_TEMP</name>
      <value>0x01D0</value>
    </enumerator>
    <enumerator>
      <name>STATE</name>
      <value>0x0500</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF_TEMP</name>
      <value>0x01D1</value>
    </enumerator>
    <enumerator>
      <name>GPU_TEMP</name>
      <value>0x01D8</value>
    </enumerator>
    <enumerator>
      <name>GPU_MEM_TEMP</name>
      <value>0x01D9</value>
    </enumerator>
    <enumerator>
      <name>VRM_VDD_TEMP</name>
      <value>0x01DA</value>
    </enumerator>
    <enumerator>
      <name>GPU_STATE</name>
      <value>0x17D8</value>
    </enumerator>
    <enumerator>
      <name>PROC_STATE</name>
      <value>0x0703</value>
    </enumerator>
    <enumerator>
      <name>CORE_STATE</name>
      <value>0x07D0</value>
    </enumerator>
    <enumerator>
      <name>HOST_AUTO_REBOOT_CONTROL</name>
      <value>0x0921</value>
    </enumerator>
    <enumerator>
      <name>DIMM_STATE</name>
      <value>0x0C20</value>
    </enumerator>
    <enumerator>
      <name>HB_VOLATILE</name>
      <value>0x0C21</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF_STATE</name>
      <value>0x0CD1</value>
    </enumerator>
    <enumerator>
      <name>FW_BOOT_PROGRESS</name>
      <value>0x0F22</value>
    </enumerator>
    <enumerator>
      <name>SYSTEM_EVENT</name>
      <value>0x1201</value>
    </enumerator>
    <enumerator>
      <name>OS_BOOT</name>
      <value>0x1F23</value>
    </enumerator>
    <enumerator>
      <name>HOST_STATUS</name>
      <value>0x2223</value>
    </enumerator>
    <enumerator>
      <name>OCC_ACTIVE</name>
      <value>0x07D2</value>
    </enumerator>
    <enumerator>
      <name>CORE_FREQ</name>
      <value>0xC1D0</value>
    </enumerator>
    <enumerator>
      <name>APSS_CHANNEL</name>
      <value>0xC2D7</value>
    </enumerator>
    <enumerator>
      <name>PCI_ACTIVE</name>
      <value>0xC423</value>
    </enumerator>
    <enumerator>
      <name>REBOOT_COUNT</name>
      <value>0xC322</value>
    </enumerator>
    <enumerator>
      <name>FAULT</name>
      <value>0xC700</value>
    </enumerator>
    <enumerator>
      <name>BACKPLANE_FAULT</name>
      <value>0xC707</value>
    </enumerator>
    <enumerator>
      <name>REF_CLOCK_FAULT</name>
      <value>0xC7D4</value>
    </enumerator>
    <enumerator>
      <name>PCI_CLOCK_FAULT</name>
      <value>0xC7D5</value>
    </enumerator>
    <enumerator>
      <name>TOD_CLOCK_FAULT</name>
      <value>0xC7D6</value>
    </enumerator>
    <enumerator>
      <name>APSS_FAULT</name>
      <value>0xC7D7</value>
    </enumerator>
    <enumerator>
      <name>VRM_VDD_FAULT</name>
      <value>0xC707</value>
    </enumerator>
    <enumerator>
      <name>DERATING_FACTOR</name>
      <value>0xC815</value>
    </enumerator>
    <enumerator>
      <name>REDUNDANT_PS_POLICY</name>
      <value>0xCA22</value>
    </enumerator>
    <enumerator>
      <name>TURBO_ALLOWED</name>
      <value>0xCB03</value>
    </enumerator>
    <enumerator>
      <name>TPM_REQUIRED</name>
      <value>0xCC03</value>
    </enumerator>
    <enumerator>
      <name>PCI_BIFURCATED</name>
      <value>0xCD03</value>
    </enumerator>
    <id>SENSOR_NAME</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration of possible roles a TPM can play within a node.  A TPM has
        the primary role if it's connected to the acting master processor,
        otherwise it has the backup role.
    </description>
    <enumerator>
      <name>TPM_PRIMARY</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TPM_BACKUP</name>
      <value>1</value>
    </enumerator>
    <id>TPM_ROLE</id>
  </enumerationType>

  <enumerationType>
    <default>DD10</default>
    <description>Enumeration indicating the chip version</description>
    <enumerator>
      <name>DD10</name>
      <value>0x10</value>
    </enumerator>
    <enumerator>
      <name>DD11</name>
      <value>0x11</value>
    </enumerator>
    <enumerator>
      <name>DD20</name>
      <value>0x20</value>
    </enumerator>
    <enumerator>
      <name>DD21</name>
      <value>0x21</value>
    </enumerator>
    <id>CHIP_VER</id>
  </enumerationType>

  <enumerationType>
    <default>BMC_HW_VER</default>
    <description>Enumeration indicating the chip HW version</description>
    <enumerator>
      <name>FSP_HW_VER</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>BMC_HW_VER</name>
      <value>0x3</value>
    </enumerator>
    <id>HW_VER</id>
  </enumerationType>

  <enumerationType>
    <default>PRIMARY</default>
    <description>Enumeration indicating the master's FSI type</description>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>BACKUP</name>
      <value>0</value>
    </enumerator>
    <id>ROLE</id>
  </enumerationType>

  <enumerationType>
    <default>BMC_SW_VER</default>
    <description>Enumeration indicating the SW version</description>
    <enumerator>
      <name>FSP_SW_VER</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>BMC_SW_VER</name>
      <value>0x2</value>
    </enumerator>
    <id>SW_VER</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the IPMI entity ID, these values are
        defined in the IPMI specification.  These values will be used in place
        of target type when events are sent to the BMC.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OTHER</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PROCESSOR</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>SYSTEM_BOARD</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>POWER_MGMT</name>
      <value>0x15</value>
    </enumerator>
    <enumerator>
      <name>CHASSIS</name>
      <value>0x17</value>
    </enumerator>
    <enumerator>
      <name>MEMORY_DEVICE</name>
      <value>0x20</value>
    </enumerator>
    <enumerator>
      <name>SYS_MGMT_SOFTWARE</name>
      <value>0x21</value>
    </enumerator>
    <enumerator>
      <name>BIOS</name>
      <value>0x22</value>
    </enumerator>
    <enumerator>
      <name>OS</name>
      <value>0x23</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>0xD0</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF</name>
      <value>0xD1</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>0xD2</value>
    </enumerator>
    <enumerator>
      <name>REF_CLOCK</name>
      <value>0xD4</value>
    </enumerator>
    <enumerator>
      <name>PCI_CLOCK</name>
      <value>0xD5</value>
    </enumerator>
    <enumerator>
      <name>TOD_CLOCK</name>
      <value>0xD6</value>
    </enumerator>
    <enumerator>
      <name>APSS</name>
      <value>0xD7</value>
    </enumerator>
    <enumerator>
      <name>GPU_CORE</name>
      <value>0xD8</value>
    </enumerator>
    <enumerator>
      <name>GPU_MEMORY</name>
      <value>0xD9</value>
    </enumerator>
    <id>ENTITY_ID</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration defining the offsets into the GPU_SENSORS array.
    </description>
    <enumerator>
      <name>FUNC_OFFSET</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>FUNC_ID_OFFSET</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>TEMP_OFFSET</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>TEMP_ID_OFFSET</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>MEM_TEMP_OFFSET</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>MEM_TEMP_ID_OFFSET</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>OBUS_CFG_OFFSET</name>
      <value>0x06</value>
    </enumerator>
    <id>GPU_SENSOR_ARRAY</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the IPMI sensor type, these values
        are defined in the IPMI specification. These values will be used when
    sending sensor reading events to the BMC.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TEMPERATURE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PROCESSOR</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>POWER_UNIT</name>
      <value>0x09</value>
    </enumerator>
    <enumerator>
      <name>MEMORY</name>
      <value>0x0c</value>
    </enumerator>
    <enumerator>
      <name>SYS_FW_PROGRESS</name>
      <value>0x0F</value>
    </enumerator>
    <enumerator>
      <name>SYS_EVENT</name>
      <value>0x12</value>
    </enumerator>
    <enumerator>
      <name>ADDIN_CARD</name>
      <value>0x17</value>
    </enumerator>
    <enumerator>
      <name>OS_BOOT</name>
      <value>0x1F</value>
    </enumerator>
    <enumerator>
      <name>APCI_POWER_STATE</name>
      <value>0x22</value>
    </enumerator>
    <enumerator>
      <name>FREQ</name>
      <value>0xC1</value>
    </enumerator>
    <enumerator>
      <name>POWER</name>
      <value>0xC2</value>
    </enumerator>
    <enumerator>
      <name>BOOT_COUNT</name>
      <value>0xC3</value>
    </enumerator>
    <enumerator>
      <name>PCI_LINK_PRES</name>
      <value>0xC4</value>
    </enumerator>
    <enumerator>
      <name>PWR_LIMIT_ACTIVE</name>
      <value>0xC4</value>
    </enumerator>
    <enumerator>
      <name>FAULT</name>
      <value>0xC7</value>
    </enumerator>
    <id>SENSOR_TYPE</id>
  </enumerationType>

</attributes>
